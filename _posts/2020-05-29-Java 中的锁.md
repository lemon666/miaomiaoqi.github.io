---
layout: post
title: Java 中的锁
categories: [Others]
description: 
keywords: 
---

* content
{:toc}




## Lock 简介, 地位, 作用

锁是一种工具, 用于控制对共享资源的访问

Lock 和 Synchronized, 这两个是最常见的锁, 它们都可以达到线程安全的目的, 但是在使用上和功能上又有较大的不同

Lock 并不是用来代替 Synchronized 的, 而是当使用 Synchronized 不合适或不足以满足要求的时候, 来提供高级功能的

Lock 接口最常见的实现类是 ReentrantLock

### 为什么需要 Lock

#### 为什么 synchronized 不够用

效率低: 锁的释放情况少, 试图获得锁时不能设定超时, 不能中断一个正在试图获得锁的线程

不够灵活(读写锁更灵活): 加锁和释放的时机单一, 每个锁仅有单一的条件(某个对象), 可能是不够的

#### Lock 主要方法介绍

lock(): 最普通的获取锁, 如果锁已经被其他线程获取了, 则进行等待

tryLock(), tryLock(long time, TimeUnit unit) 和 lockInterruptibly()

Lock 不会像 Synchronized 一样在异常时自动释放锁, 因此最佳实践是, 在 finally 中释放锁, 以保证发生异常时锁一定释放



### 可见性保证

happens-before 原则



## 锁的分类

![http://www.milky.show/images/java/lock/lock_1.png](http://www.milky.show/images/java/lock/lock_1.png)

### 乐观锁和悲观锁

互斥同步锁(悲观锁)的劣势

*   阻塞和唤醒带来的性能劣势
*   永久阻塞: 如果持有锁的线程被永久阻塞, 比如遇到了无限循环, 死锁等活跃性问题, 那么等待该线程释放锁的那几个悲催的线程, 将永远也得不到执行
*   优先级反转

非互斥同步锁(乐观锁)

#### 悲观锁





## 请描述 synchronized 和 Reentrantlock 的底层实现及重入的底层原理

synchronized 的底层汇编还是 lock cmpxchg 命令

## 请描述锁的四种状态和升级过程

在 JDK1.2 时 synchronized 的性能非常差, 在 JDK1.6 后优化了锁的升级状态

**JDK 早期, synchronized 叫做重量级锁, 因为申请锁资源必须通过 kernel(内核), 早期 APP 可以直接系统调用底层硬件**

现代操作系统会分为两层, 内核态和用户态, 自己的 APP 就是用户态, 系统资源就是内核态, 如果用户态想访问内核态的资源需要通过 kernel 的允许, 将用户态转向内核态, 拿到结果后再从内核态返回用户态. 早期 synchronized 加锁就需要申请系统资源, 进行用户态和内核态的转换, 所以是重量级锁, 经过优化后在某些情况下不需要通过内核态就可以解决, 比如 CAS(轻量级锁), 只需要用户态就可以完成

![http://www.milky.show/images/mashibing/synchronized/syn_3.png](http://www.milky.show/images/mashibing/synchronized/syn_3.png)

### 无锁态

最后是 001

### 偏向锁

最后是 101, 用户态完成

将自己的线程号写进了 markword 上, 此时只是贴了一个自己的 id 上去, 并没有发生锁的竞争

多数 synchronized 方法, 在很多情况下, 只有一个线程在运行, 没有必要向内核态申请资源, 例如 StringBuffer 中的 sync 方法

**只要有另外的线程来竞争, 就会升级为轻量级锁**

### 轻量级锁, 自旋锁, 无锁(CAS)

最后是 00, 用户态完成

当发生了多线程争锁的情况, 哪个线程能将自己的 id 写进 markword 谁就能获得锁, 此时是在用户空间完成的 CAS 操作, 此时偏向锁的线程也会发起争锁, 但是会有一定优势

CAS 适合操作特别快或者线程数较小的情况, 因为自旋会消耗 CPU 资源

### 重量级锁

最后是 10, 需要向内核态申请

向操作系统申请锁

为什么有了自旋锁, 还需要重量级锁, 因为重量级锁不需要消耗 CPU 资源, 会将其他线程放到一个队列中(waitset),  因此不需要自旋的过程了

## 请谈一下 AQS, 为什么 AQS 的底层是 CAS + volatile

## 解释一下锁的四种状态

## 对象在内存中的布局

JOL = Java Object Layout(Java 对象内存布局)

在堆内存中 new 出来一个对象, 这个对象在堆中分为四个部分

1.  markword, 8 个字节, synchronized(o) 锁定对象的本质是修改了 markword, **使 markword 包含了锁的信息**, 我们平时所说的加锁, 就是修改对象的 markword 的内容

    *   锁信息, 无锁态, 偏向锁...
    *   GC 标记信息
    *   HashCode

    ![http://www.milky.show/images/mashibing/synchronized/syn_2.png](http://www.milky.show/images/mashibing/synchronized/syn_2.png)

2.  klass poniter, 是一个指针, 指向 T.class, 表名这个对象属于哪一个 class, 压缩是 4 字节, 不压缩是 8 字节

3.  instance state, 成员变量所占的位置, byte, short, int, long...

4.  padding, 对齐, 64 位虚拟机 padding 是需要 4 块内容可以被 8 字节整除, 如果前 3 块不能被 8 整除, 就用 padding 补齐

![http://www.milky.show/images/mashibing/synchronized/syn_1.png](http://www.milky.show/images/mashibing/synchronized/syn_1.png)

## Object o = new Object() 在内存中占了多少字节

16 字节

JOL 是 openjdk 的一个工具类

Object o = new Object();
sysout ClassLayout.parseInstance(o).toPrintable();

## 请描述一下锁的分类以及 JDK 的应用

## 自旋锁一定比重量级锁效率高吗

自旋是消耗CPU资源的，如果锁的时间长，或者自旋线程多，CPU会被大量消耗

重量级锁有等待队列，所有拿不到锁的进入等待队列，不需要消耗CPU资源

## 偏向锁一定比自旋锁效率高吗

**偏向锁是在 JVM 启动 4s 后开启的, 因为 JVM 启动时有很多内存区域需要进行加锁, 这时已经明确知道有多线程去竞争锁, 就不需要开启偏向锁了**

很多情况下我明知道会存在锁的竞争情况, 就不需要加偏向锁了, 如果加了偏向锁还存在一个偏向锁升级的过程, 反而效率会降低



不一定，在明确知道会有多线程竞争的情况下，偏向锁肯定会涉及锁撤销，这时候直接使用自旋锁

JVM启动过程，会有很多线程竞争（明确），所以默认情况启动时不打开偏向锁，过一段儿时间再打开



## synchronized vs Lock (CAS)

 在高争用 高耗时的环境下synchronized效率更高
 在低争用 低耗时的环境下CAS效率更高
 synchronized到重量级之后是等待队列（不消耗CPU）
 CAS（等待期间消耗CPU）

 一切以实测为准



## 锁消除 lock eliminate

```java
public void add(String str1,String str2){
    StringBuffer sb = new StringBuffer();
    sb.append(str1).append(str2);
}
```

我们都知道 StringBuffer 是线程安全的，因为它的关键方法都是被 synchronized 修饰过的，但我们看上面这段代码，我们会发现，sb 这个引用只会在 add 方法中使用，不可能被其它线程引用（因为是局部变量，栈私有），因此 sb 是不可能共享的资源，JVM 会自动消除 StringBuffer 对象内部的锁。



## 锁粗化 lock coarsening

```java
public String test(String str){
    int i = 0;
    StringBuffer sb = new StringBuffer():
    while(i < 100){
        sb.append(str);
        i++;
    }
    return sb.toString():
}
```

JVM 会检测到这样一连串的操作都对同一个对象加锁（while 循环内 100 次执行 append，没有锁粗化的就要进行 100  次加锁/解锁），此时 JVM 就会将加锁的范围粗化到这一连串的操作的外部（比如 while 虚幻体外），使得这一连串操作只需要加一次锁即可。



## 锁过程

偏向锁 - markword 上记录当前线程指针，下次同一个线程加锁的时候，不需要争用，只需要判断线程指针是否同一个，所以，偏向锁，偏向加锁的第一个线程 。hashCode备份在线程栈上 线程销毁，锁降级为无锁

有争用 - 锁升级为轻量级锁 - 每个线程有自己的LockRecord在自己的线程栈上，用CAS去争用markword的LR的指针，指针指向哪个线程的LR，哪个线程就拥有锁

自旋超过10次，升级为重量级锁 - 如果太多线程自旋 CPU消耗过大，不如升级为重量级锁，进入等待队列（不消耗CPU）-XX:PreBlockSpin



自旋锁在 JDK1.4.2 中引入，使用 -XX:+UseSpinning 来开启。JDK 6 中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。

自适应自旋锁意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。



偏向锁由于有锁撤销的过程revoke，会消耗系统资源，所以，在锁争用特别激烈的时候，用偏向锁未必效率高。还不如直接使用轻量级锁。











