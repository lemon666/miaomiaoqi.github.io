---
layout: post
title: 字符串匹配算法
categories: [Algorithm]
description: 
keywords: 
---

* content
{:toc}


## 什么是字符串匹配算法

![http://www.milky.show/images/algorithm/stringmatch/sm_1.png](http://www.milky.show/images/algorithm/stringmatch/sm_1.png)

在上图中，字符串B是A的子串，B第一次在A中出现的位置下标是2（字符串的首位下标是0），所以返回 **2**。

我们再看另一个例子:

![http://www.milky.show/images/algorithm/stringmatch/sm_2.png](http://www.milky.show/images/algorithm/stringmatch/sm_2.png)

在上图中，字符串B在A中并不存在，所以返回 **-1**.

为了统一概念，在后文中，我们把字符串A称为**主串**，把字符串B称为**模式串**。

## BF 算法 (Brute Force 暴力算法)

BF 的思想很简单, 从头开始将主串和模式串的字符一个一个进行匹配, 如果发现不匹配就从主串的下一个位置继续

**第一轮**，我们从主串的首位开始，把主串和模式串的字符逐个比较：

![http://www.milky.show/images/algorithm/stringmatch/sm_3.png](http://www.milky.show/images/algorithm/stringmatch/sm_3.png)

显然，主串的首位字符是a，模式串的首位字符是b，两者并不匹配。

**第二轮**，我们把模式串后移一位，从主串的第二位开始，把主串和模式串的字符逐个比较：

![http://www.milky.show/images/algorithm/stringmatch/sm_4.png](http://www.milky.show/images/algorithm/stringmatch/sm_4.png)

主串的第二位字符是b，模式串的第二位字符也是b，两者匹配，继续比较：

![http://www.milky.show/images/algorithm/stringmatch/sm_5.png](http://www.milky.show/images/algorithm/stringmatch/sm_5.png)

主串的第三位字符是b，模式串的第三位字符也是c，两者并不匹配。

**第三轮**，我们把模式串再次后移一位，从主串的第三位开始，把主串和模式串的字符逐个比较：

![http://www.milky.show/images/algorithm/stringmatch/sm_6.png](http://www.milky.show/images/algorithm/stringmatch/sm_6.png)

主串的第三位字符是b，模式串的第三位字符也是b，两者匹配，继续比较：

![http://www.milky.show/images/algorithm/stringmatch/sm_7.png](http://www.milky.show/images/algorithm/stringmatch/sm_7.png)

主串的第四位字符是c，模式串的第四位字符也是c，两者匹配，继续比较：

![http://www.milky.show/images/algorithm/stringmatch/sm_8.png](http://www.milky.show/images/algorithm/stringmatch/sm_8.png)

主串的第五位字符是e，模式串的第五位字符也是e，两者匹配，比较完成！

由此得到结果，模式串 bce 是主串 abbcefgh 的子串，在主串第一次出现的位置下标是 2：

![http://www.milky.show/images/algorithm/stringmatch/sm_9.png](http://www.milky.show/images/algorithm/stringmatch/sm_9.png)

这个思路确实可以解决问题, 但是在某些极端情况下算法的效率会非常低

![http://www.milky.show/images/algorithm/stringmatch/sm_10.png](http://www.milky.show/images/algorithm/stringmatch/sm_10.png)

上图的情况，在每一轮进行字符匹配时，模式串的前三个字符a都和主串中的字符相匹配，一直检查到模式串最后一个字符b，才发现不匹配：

![http://www.milky.show/images/algorithm/stringmatch/sm_11.png](http://www.milky.show/images/algorithm/stringmatch/sm_11.png)

这样一来，两个字符串在每一轮都需要白白比较4次，显然非常浪费。

假设主串的长度是m，模式串的长度是n，那么在这种极端情况下，BF算法的最坏时间复杂度是**O（mn）**。

## RK 算法(基于 BF 算法的改进)

