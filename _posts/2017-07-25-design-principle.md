---
layout: post
title:  "软件设计模式六大原则"
date:   2017-07-26 10:14:05
categories: SoftwareEngineering
tags: DesignPrinciple
author: miaoqi
---

* content
{:toc}

## 单一职责原则(SRP)
    
* 定义:

    There should never be more than one reason for a class to change, 应该有且仅有一个原因引起类的变更. 
    
* 职责

    业务逻辑, 或者对象能够承担的责任, 并以某种行为方式来执行. 
    
* 问题由来

    类Ｔ负责两个不事的职责:职责Ｐ１、职责Ｐ２. 当由于职责Ｐ１需求发生改变而需要修改类Ｔ时, 有可能会导致原来运行的职责Ｐ２功能发生故障. 解决方法:分别建立两个类完成对应的功能

* 好处

    类的复杂性降低, 实现什么职责都有清晰明确的定义
    
    可读性提高, 复杂性降低, 那当然可读性提高了
    
    可维护性提高, 那当然了, 可读性提高, 那当然更容易维护了
    
    变更引起的风险降低, 变更是必不可少的, 接口的单一职责做的好的话, 一个接口修改只对相应的实现类有影响, 与其他的接口无影响, 这个是对项目有非常大的帮助. 

* 难点

    职责划分无量化标准:学究理论还是工程应用?后者时, 要考虑可变因素与不可变因素, 以及相关的收益成本比率等

    单一职责妥协:项目中单一职责原则很少得以体现, 或者非常难(囿于国内技术人员的地位、话语权、项目中的环境、工作量、人员的技术水平、硬件资源等, 最终的结果就是常常违背单一职责原则)

* 实践建议

    接口一定要做到ＳＲＰ, 类的设计尽量做到只有一个原因引起变化

    妥协原则:     
    
    Ａ. 只有逻辑足够简单, 才可以在代码级别上违背ＳＲＰ    
    Ｂ. 只有类中方法数量足够少, 才可以在方法级别上违背ＳＲＰ      
    Ｃ. 实际应用中的类都要复杂的多, 一旦发生职责扩散而需要修改类时, 除非这个类本身非常简单, 否则还是要遵循ＳＲＰ

## 里氏替代原则(LSP)

* 定义: 

    Functions that use pointers or referrnces to base classes must be able to use objects of derived classes without knowing it. (所有引用基类的地方必须能透明地使用其子类的对象)

* 理解: 

    只要父类能出现的地方, 子类就可以出现, 并且替换为子类也不会产生任何错误或异常, 使用者可能根本就不需要知道是父类还是子类. 但反之, 未要求

    继承机制的优点:

    代码共享, 减少创建类的工作量；     
    提高代码的重用性；    
    子类可以形似父类, 又异于父类；   
    提高父类的扩展性, 实现父类的方法即可随意而为
        
    继承机制的缺点:
    
    继承是入侵性的(只要继承, 就必须拥有父类的所有属性与方法)      
    降低了代码的灵活性(子类拥有了父类的属性方法, 会增多约束)       
    增强了耦合性(当父类的常量、变量、方法被修改时, 必需要考虑子类的修改)   
        
    定义所包含的四层意思:(另一种通俗的LSP原则讲解:子类可以扩展父类的功能, 但不能改变父类原有的功能)
    
    子类可以实现父的抽象方法, 但不能覆盖父类的非抽象方法(做系统设计时, 经常会定义一个接口或抽象类, 然后编码实现(定义的方法或接口), 调用类则直接传入接口或抽象类, 这里也是LSP的应用体现)
    
    子类可以有自己的方法和属性(因为LSP可以正用, 不能反用:在子类出现的地方, 父类未必就可以胜任(本来就无此要求). 即不要死扣——所有的地方(如参数)都要以父类的形式出现(再作转化), 实现中有需要依赖子类的情况, 这是正常的)
    
    覆盖或实现父类的方法时输入参数可以被放大(放大的实质为重载, 因为参数不同；为什么只能放大?因为父类方法的参数类型相对较小, 所以当传入父类方法的参数类型(或更窄类型)时, 重载时, 将优先匹配父类的方法, 因此子类重载的方法并不会对此参数类型被执行, 因此保证了LSP, 且不会引起想不到的业务逻辑混乱. 若为覆写, 则程序员必清楚其逻辑要义)
    
    覆写或实现父类的方法时输出结果可以被缩小(若放大, 还能用子类替换父类吗?)

## 依赖倒置原则(DIP)
    
* 定义:

    High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions. (高层模块不应该依赖低层模块, 两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象)
    
* 理解:

    低层模块:不可分割的原子逻辑
    
    高层模块:低层模块的再组合
    
    抽象: 接口或抽象类(特点:不能直接被实例化)
    
    细节: 与接口或抽象类对应的实现类(特点:可以直拉被实例化)
    
    据此, DIP在Java语言中的表现就是:
    
    模块间的依赖通过抽象类或接口发生, 实现类之间的依赖关系也是通过抽象类或接口产生(实现类之间不应发生直接的依赖关系)；     
    接口或抽象不依赖于实现类, 但实现类依赖接口或抽象类；
    
    再次理解DIP:
    
    依赖倒置原则要求"高层模块不应该依赖于低层模块, 二者都应该依赖于抽象. "这一原则在分层架构模式中, 得到了淋漓尽致地运用. 例如, 业务逻辑层(高层模块)的对象就不应该直接依赖于数据访问层(低层模块)的具体实现对象, 而应该通过数据访问层的抽象接口进行访问, 如下图所示. 如果高层模块直接依赖于低层模块, 一旦低层模块发生变化, 就会影响到高层模块. 通过引入抽象, 对于高层模块而言, 低层模块的实现是可替换的. 这实际上也是"开放封闭原则"的体现. 这一原则同时还体现了软件设计对"间接"的追求. 下图中的数据访问抽象层就是在设计中引入的一层间接性. 
    
* 使用DIP的好处:

    可以通过抽象使各个类或模块的实现彼此独立, 不互相影响, 实现模块间的松耦合(也是本质)；
    
    可以规避一些非技术因素引起的问题(如项目大时, 需求变化的概率也越大, 通过采用依赖倒置原则设计的接口或抽象类对实现类进行约束, 可以减少需求变化引起的工作量剧增情况. 同时, 发生人员变动, 只要文档完善, 也可让维护人员轻松地扩展和维护)；
    
    可以促进并行开发(如, 两个类之间有依赖关系, 只要制定出两者之间的接口(或抽象类)就可以独立开发了, 而且项目之间的单元测试也可以独立地运行, 而TDD开发模式更是DIP的最高级应用(特别适合项目人员整体水平较低时使用)). 
        
## 接口隔离原则(ISP)

* 定义:

    Clients should not be forced to depend upon interfaces that they don't use. (客户端不应该依赖它不需要的接口). 或The dependcy of one class to another one should depend on the smallest possible interface. (类间的依赖关系应该建立在最小的接口上). 或使用多个专门的接口比使用单一的总接口要好. 

* 理解:

    接口隔离原则的含义是:建立单一接口, 不要建立庞大臃肿的接口, 尽量细化接口, 接口中的方法尽量少. 也就是说, 我们要为各个类建立专用的接口, 而不要试图去建立一个很庞大的接口供所有依赖它的类去调用.  在程序设计中, 依赖几个专用的接口要比依赖一个综合的接口更灵活. 接口是设计时对外部设定的“契约”, 通过分散定义多个接口, 可以预防外来变更的扩散, 提高系统的灵活性和可维护性. 
    
    单一职责与接口隔离的区别:
    
    单一职责原则注重的是职责:而接口隔离原则注重对接口依赖的隔离.      
    单一职责原则主要是约束类, 其次才是接口和方法, 它针对的是程序中的实现和细节;而接口隔离原则主要约束接口, 主要针对抽象, 针对程序整体框架的构建. 

* 使用ISP的好处:

    原则意义上的好处:接口如果能够保持粒度够小, 就能保证它足够稳定, 正如单一职责原则所飘洋过海榜的那样. (举例:多个专门的接口就好比采用活字制版, 可以随时拼版拆版, 既利于修改, 又利于文字的重用. 而单一的总接口就是雕版的印刷, 一旦发现错别字, 既难改, 又需要整块重新雕刻)

    使用多个专门的接口还能够体现对象的层次, 因为我们可以通过接口的继承, 实现对总接口的定义. (例如, . NET框架中IList接口的定义)

## 迪米特法则(LoD)

* 定义:

    Only talk to your immedate friends. (只与直接的朋友通信). 一个对象应该对其他对象有最少的了解. (通俗地讲, 一个类应该对自己需要耦合或调用的类知道得最少)

* 理解:

    只和朋友交流(更准确来讲是:直接的朋友)
    
    每个对象都必然会与其他对象有耦合关系, 两个对象之间的耦合就成为朋友关系, 这种关系的类型有很多, 如组合、聚合、依赖等. 
        
    朋友类的定义:出现在成员变量、方法的输入输出参数中的类.   而方法体类内部的类不能算.
    
    朋友之间也有间距如果朋友把太多的方法或属性暴露给你, 则过于亲密, 耦合关系变得异常牢固, 而且, 修改时涉及的面也就越大, 变更引起的风险就越大. 因此, 要适时反复衡量:是否可以减少public方法和属性, 改为private、package－private、protected等访问权限, 及是否可以加上final关键字. 

## 开闭原则(OCP)

* 定义:

    Software entities like classes, modules and functions should be open for extension but closed for modifications. (一个软件实体如类, 模块和函数应该对扩展开放, 对修改关闭)

* 理解:
 
    软件实体应该对扩展开放, 对修改关闭, 其含义是说一个软件实体应该通过扩展来实现变化, 而不是通过修改已有的代码来实现变化. 
    
    软件实体包括以下几个部分:
        项目或软件产品中按照一定的逻辑规则划分的模块；
        抽象和类；
        方法;
        
    修改:

    可以分为两个层次来分析. 一个层次是对抽象定义的修改, 如对象公开的接口, 包括方法的名称、参数与返回类型. 
        
    我们必须保证一个接口, 尤其要保证被其他对象调用的接口的稳定；否则, 就会导致修改蔓延, 牵一发而动全身. 从某种程度上讲, 接口就是标准, 要保障接口的稳定, 就应该对对象进行合理的封装. 
    
    另一个层次是指对具体实现的修改. "对修改封闭"是开放封闭原则的两个要素之一. 原则上, 要做到避免对源代码的修改, 即使仅修改具体实现, 也需要慎之又慎. 这是因为具体实现的修改, 可能会给调用者带来意想不到的结果, 这一结果并非我们预期的, 甚至可能与预期相反. 如果确实需要修改具体的实现, 就需要做好达到测试覆盖率要求的单元测试. 

## 参考

  * [设计模式六大原则之--单一职责原则(SRP)][1]
  * [设计模式六大原则之--里氏替代原则(LSP)][2]
  * [设计模式六大原则之--依赖倒置原则(DIP)][3]
  * [设计模式六大原则之--接口隔离原则(ISP)][4]
  * [设计模式六大原则之--迪米特法则(LoD)][5]
  * [设计模式六大原则之--开闭原则(OCP)][6]
  

[1]: http://blog.csdn.net/benbenxiongyuan/article/details/23940989 
[2]: http://blog.csdn.net/benbenxiongyuan/article/details/23999989
[3]: http://blog.csdn.net/benbenxiongyuan/article/details/24002477
[4]: http://blog.csdn.net/benbenxiongyuan/article/details/24003915
[5]: http://blog.csdn.net/benbenxiongyuan/article/details/24020091
[6]: http://blog.csdn.net/benbenxiongyuan/article/details/24021039
        
        
        
        
        
        
        
        