---
layout: post
title:  "CAS机制"
date:   2018-07-27 15:33:17
categories: Java
tags: Concurrent
author: miaoqi
---

* content
{:toc}

## 什么是CAS？

CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。

CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。

更新一个变量的时候，只有当变量的预期值(A)和内存地址(V)当中的实际值相同时，才会将内存地址(V)对应的值修改为(B)

**内存值(V), 旧的预期值(A), 如果V == A代表没人修改过, 可以将更新值(B)赋值给(V)**

从思想上来说，Synchronized属于悲观锁，悲观地认为程序中的并发情况严重，所以严防死守。CAS属于乐观锁，乐观地认为程序中的并发情况不那么严重，所以让线程不断去尝试更新。如果并发量非常高的情况下, 使用Synchronized效率会更高

## 缺点

* CPU开销较大

    在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，循环往复，会给CPU带来很大的压力。这时候使用sychronized反而效果会更好

* 不能保证代码块的原子性

    CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。

* ABA问题

    这是CAS机制最大的问题所在。

    比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。如果链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化。

    解决ABA问题只需要加一个版本号就可以解决, java中提供了现成的类AtomicStampedReference来实现带版本号的CAS机制

    
    
    
    
    
    
    
    
    
    