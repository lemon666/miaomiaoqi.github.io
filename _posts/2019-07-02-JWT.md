---
layout: post
title: "JWT"
categories: [Security]
description:
keywords:
---

* content
{:toc} 


## 无状态登录原理

### 什么是有状态？

有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如tomcat中的session。

例如登录：用户登录后，我们把登录者的信息保存在服务端session中，并且给用户一个cookie值，记录对应的session。然后下次请求，用户携带cookie值来，我们就能识别到对应session，从而找到用户的信息。

缺点是什么？

- 服务端保存大量数据，增加服务端压力
- 服务端保存用户状态，无法进行水平扩展
- 客户端请求依赖服务端，多次请求必须访问同一台服务器



### 什么是无状态

微服务集群中的每个服务，对外提供的都是Rest风格的接口。而Rest风格的一个最重要的规范就是：服务的无状态性，即：

- 服务端不保存任何客户端请求者信息
- 客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份

带来的好处是什么呢？

- 客户端请求不依赖服务端的信息，任何多次请求不需要必须访问到同一台服务
- 服务端的集群和状态对客户端透明
- 服务端可以任意的迁移和伸缩
- 减小服务端存储压力

### 如何实现无状态

无状态登录的流程：

- 当客户端第一次请求服务时，服务端对用户进行信息认证（登录）
- 认证通过，将用户信息进行加密形成token，返回给客户端，作为登录凭证
- 以后每次请求，客户端都携带认证的token
- 服务的对token进行解密，判断是否有效。

流程图：

   ![http://miaomiaoqi.github.io/images/security/jwt/jwt_1.png](http://miaomiaoqi.github.io/images/security/jwt/jwt_1.png)



整个登录过程中，最关键的点是什么？

**token的安全性**

token是识别客户端身份的唯一标示，如果加密不够严密，被人伪造那就完蛋了。

采用何种方式加密才是安全可靠的呢？

我们将采用`JWT + RSA非对称加密`



## JWT

### 简介

JWT，全称是Json Web Token， 是JSON风格轻量级的授权和身份认证规范，可实现无状态、分布式的Web应用授权；官网：https://jwt.io

![http://miaomiaoqi.github.io/images/security/jwt/jwt_2.png](http://miaomiaoqi.github.io/images/security/jwt/jwt_2.png)

GitHub上jwt的java客户端：https://github.com/jwtk/jjwt



### 数据格式

JWT包含三部分数据：

- Header：头部，通常头部有两部分信息：

  - 声明类型，这里是JWT
  - 加密算法，自定义

  我们会对头部进行base64加密（可解密），得到第一部分数据

- Payload：载荷，就是有效数据，一般包含下面信息：

  - 用户身份信息（注意，这里因为采用base64加密，可解密，因此不要存放敏感信息）
  - 注册声明：如token的签发时间，过期时间，签发人等

  这部分也会采用base64加密，得到第二部分数据

- Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥（secret）（不要泄漏，最好周期性更换），通过加密算法生成。用于验证整个数据完整和可靠性

生成的数据格式：

![http://miaomiaoqi.github.io/images/security/jwt/jwt_3.png](http://miaomiaoqi.github.io/images/security/jwt/jwt_3.png)

可以看到分为3段，每段就是上面的一部分数据



### JWT 交互流程

流程图：

![http://miaomiaoqi.github.io/images/security/jwt/jwt_4.png](http://miaomiaoqi.github.io/images/security/jwt/jwt_4.png)

步骤翻译：

1. 用户登录

2. 服务的认证，通过后根据secret生成token

3. 将生成的token返回给用户

4. 用户每次请求携带token

5. 服务端利用公钥解读jwt签名，判断签名有效后，从Payload中获取用户信息

6. 处理请求，返回响应结果



因为JWT签发的token中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，完全符合了Rest的无状态规范。



### 非对称加密

加密技术是对信息进行编码和解码的技术，编码是把原来可读信息（又称明文）译成代码形式（又称密文），其逆过程就是解码（解密），加密技术的要点是加密算法，加密算法可以分为三类：  

- 对称加密，如AES
  - 基本原理：将明文分成N个组，然后使用密钥对各个组进行加密，形成各自的密文，最后把所有的分组密文进行合并，形成最终的密文。
  - 优势：算法公开、计算量小、加密速度快、加密效率高
  - 缺陷：双方都使用同样密钥，安全性得不到保证
- 非对称加密，如RSA
  - 基本原理：同时生成两把密钥：私钥和公钥，私钥隐秘保存，公钥可以下发给信任客户端
    - 私钥加密，持有私钥或公钥才可以解密
    - 公钥加密，持有私钥才可解密
  - 优点：安全，难以破解
  - 缺点：算法比较耗时
- 不可逆加密，如MD5，SHA
  - 基本原理：加密过程中不需要使用[密钥](https://baike.baidu.com/item/%E5%AF%86%E9%92%A5)，输入明文后由系统直接经过加密算法处理成密文，这种加密后的数据是无法被解密的，无法根据密文推算出明文。



RSA算法历史：

1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字缩写：RSA



### 结合 Zuul 的鉴权流程

我们逐步演进系统架构设计。需要注意的是：secret是签名的关键，因此一定要保密，我们放到鉴权中心保存，其它任何服务中都不能获取secret。



### 没有 RSA 加密时

在微服务架构中，我们可以把服务的鉴权操作放到网关中，将未通过鉴权的请求直接拦截，如图：

![http://miaomiaoqi.github.io/images/security/jwt/jwt_5.png](http://miaomiaoqi.github.io/images/security/jwt/jwt_5.png)

1. 用户请求登录

2. Zuul将请求转发到授权中心，请求授权

3. 授权中心校验完成，颁发JWT凭证

4. 客户端请求其它功能，携带JWT

5. Zuul将jwt交给授权中心校验，通过后放行

6. 用户请求到达微服务

7. 微服务将jwt交给鉴权中心，鉴权同时解析用户信息

8. 鉴权中心返回用户数据给微服务

9. 微服务处理请求，返回响应

发现什么问题了？

每次鉴权都需要访问鉴权中心，系统间的网络请求频率过高，效率略差，鉴权中心的压力较大。



### 结合 RSA 的鉴权

直接看图：

![http://miaomiaoqi.github.io/images/security/jwt/jwt_6.png](http://miaomiaoqi.github.io/images/security/jwt/jwt_6.png)

1. 我们首先利用RSA生成公钥和私钥。私钥保存在授权中心，公钥保存在Zuul和各个微服务

2. 用户请求登录

3. 授权中心校验，通过后用私钥对JWT进行签名加密

4. 返回jwt给用户

5. 用户携带JWT访问

6. Zuul直接通过公钥解密JWT，进行验证，验证通过则放行

7. 请求到达微服务，微服务直接用公钥解析JWT，获取用户信息，无需访问授权中心



## 服务暴露的问题？

### 避免被暴露

限制内网访问

### jwt 服务间鉴权

可以新建一张表, 存储每台机器的 ip 与可访问机器的 ip, 每次发起服务间调用时, 先去认证中心换取票, 将票作为参数发送请求, 服务端收到请求后对票进行解析, 判断是否可以访问做双重校验.


