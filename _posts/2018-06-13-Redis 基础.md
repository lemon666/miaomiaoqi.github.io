---
layout: post
title: "Redis 基础"
categories: [NoSql]
description:
keywords:
---

* content
{:toc}

# 简介

Redis是非关系型数据库, 即NoSql数据库, 存储的数据模型是key-value, 特点是访问速度快

# 为什么使用Redis

**性能:** 我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。

**并发:** 在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。

# 单线程Redis为什么这么快?

纯内存操作

单线程操作，避免了频繁的上下文切换

基本对象使用多种底层数据结构，且灵活变化是redis高性能的另一个原因

**采用了非阻塞I/O多路复用机制**

我们现在要仔细的说一说I/O多路复用机制，因为这个说法实在是太通俗了，通俗到一般人都不懂是什么意思。博主打一个比方：小曲在S城开了一家快递店，负责同城快送服务。小曲因为资金限制，雇佣了一批快递员，然后小曲发现资金不够了，只够买一辆车送快递。

* 经营方式一

    客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。慢慢的小曲就发现了这种经营方式存在下述问题
    
    几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递
    
    随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了
    
    快递员之间的协调很花时间
    
    综合上述缺点，小曲痛定思痛，提出了下面的经营方式
    
* 经营方式二

    小曲只雇佣一个快递员。然后呢，客户送来的快递，小曲按送达地点标注好，然后依次放在一个地方。最后，那个快递员依次的去取快递，一次拿一个，然后开着车去送快递，送好了就回来拿下一个快递。

    对比上述两种经营方式对比，是不是明显觉得第二种，效率更高，更好呢。在上述比喻中:

每个快递员------------------>每个线程

每个快递-------------------->每个socket(I/O流)

快递的送达地点-------------->socket的不同状态

客户送快递请求-------------->来自客户端的请求

小曲的经营方式-------------->服务端运行的代码

一辆车---------------------->CPU的核数

1. 于是我们有如下结论:
   
    * 经营方式一就是传统的并发模型，每个I/O流(快递)都有一个新的线程(快递员)管理。

    * 经营方式二就是I/O多路复用。只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流。

    下面类比到真实的redis线程模型，如图所示

    ![](http://miaomiaoqi.github.io/images/redis/redis的io多路复用.png) 

# 数据结构

## String类型

这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做一些**复杂的计数功能的缓存**。

| **命令** | **描述**                                                     | **用法**                                              |
| -------- | ------------------------------------------------------------ | ----------------------------------------------------- |
| SET      | （1）将字符串值Value关联到Key<br/>（2）Key已关联则覆盖，无视类型<br/>（3）原本Key带有生存时间TTL，那么TTL被清除 | SET key value [EX seconds] [PX milliseconds] [NX\|XX] |
| GET      | （1）返回key关联的字符串值<br/>（2）Key不存在返回nil<br/>（3）Key存储的不是字符串，返回错误，因为GET只用于处理字符串 | GET key                                               |
| MSET     | （1）同时设置一个或多个Key-Value键值对<br/>（2）某个给定Key已经存在，那么MSET新值会覆盖旧值<br/>（3）如果上面的覆盖不是希望的，那么使用MSETNX命令，**所有Key都不存在才会进行覆盖**<br/>（4）**MSET是一个原子性操作**，所有Key都会在同一时间被设置，不会存在有些更新有些没更新的情况 | MSET key value [key value ...]                        |
| MGET     | （1）返回一个或多个给定Key对应的Value<br/>（2）某个Key不存在那么这个Key返回nil | MGET key [key ...]                                    |
| SETEX    | （1）将Value关联到Key<br/>（2）设置Key生存时间为seconds，单位为秒<br/>（3）如果Key对应的Value已经存在，则覆盖旧值<br/>（4）SET也可以设置失效时间，但是不同在于SETNX是一个原子操作，即关联值与设置生存时间同一时间完成 | SETEX key seconds value                               |
| SETNX    | （1）将Key的值设置为Value，当且仅当Key不存在<br/>（2）若给定的Key已经存在，SEXNX不做任何动作 | SETNX key value                                       |
| INCR     | （1）Key中存储的数字值+1，返回增加之后的值<br/>（2）Key不存在，那么Key的值被初始化为0再执行INCR<br/>（3）如果值包含错误类型或者字符串不能被表示为数字，那么返回错误<br/>（4）值限制在64位有符号数字表示之内，即-9223372036854775808~9223372036854775807 | INCR key                                              |
| DECR     | （1）Key中存储的数字值-1<br/>（2）其余同INCR                 | DECR key                                              |
| INCRBY   | （1）将key所存储的值加上增量返回增加之后的值<br/>（2）其余同INCR | INCRBY key increment                                  |
| DECRBY   | （1）将key所存储的值减去减量decrement<br/>（2）其余同INCR    | DECRBY key decrement                                  |
| APPEND   | (1)给指定key的value追加字符串，并返回新字符串的长度          |                                                       |
| GETSET   | （1）设置key的值，并返回key旧的值                            |                                                       |
| STRLEN   | （1）取指定key的value的长度                                  |                                                       |

实际上type=string代表value存储的是一个普通字符串，那么对应的encoding可以是raw或者是int，如果是int则代表实际redis内部是按数值型类存储和表示这个字符串的，当然前提是这个字符串本身可以用数值表示，**比如"20"这样的字符串，当遇到incr、decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int**。如果你试图对name进行incr操作则报错。



## Hash类型, 可以对key进行分类

Hash是一个String类型的field和value之间的映射表，即redis的Hash数据类型的key（hash表名称）对应的value实际的内部存储结构为一个HashMap，因此Hash特别适合存储对象。相对于把一个对象的每个属性存储为String类型，将整个对象存储在Hash类型中会占用更少内存。

当前HashMap的实现有两种方式：当HashMap的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，这时对应的value的redisObject的encoding为zipmap，当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。

用一个对象来存储用户信息，商品信息，订单信息等等。

![http://www.miaomiaoqi.github.io/images/redis/hashstructure.png](http://www.miaomiaoqi.github.io/images/redis/hashstructure.png)



| **命令** | **描述**                                                     | **用法**                                |
| -------- | ------------------------------------------------------------ | --------------------------------------- |
| HSET     | （1）将哈希表Key中的域field的值设为value<br/>（2）key不存在，一个新的Hash表被创建<br/>（3）field已经存在，旧的值被覆盖 | HSET key field value                    |
| HSETNX   | (1)置key对应的HashMap中的field的value，如果不存在则先创建    |                                         |
| HGET     | （1）返回哈希表key中给定域field的值                          | HGET key field                          |
| HDEL     | （1）删除哈希表key中的一个或多个指定域<br/>（2）不存在的域将被忽略 | HDEL key filed [field ...]              |
| HEXISTS  | （1）查看哈希表key中，给定域field是否存在，存在返回1，不存在返回0 | HEXISTS key field                       |
| HGETALL  | （1）返回哈希表key中，所有的域和值                           | HGETALL key                             |
| HINCRBY  | （1）为哈希表key中的域field加上增量increment<br/>（2）其余同INCR命令 | HINCRYBY key filed increment            |
| HLEN     | （1）返回哈希表key中域的数量                                 | HLEN key                                |
| HMGET    | （1）返回哈希表key中，一个或多个给定域的值<br/>（2）如果给定的域不存在于哈希表，那么返回一个nil值 | HMGET key field [field ...]             |
| HMSET    | （1）同时将多个field-value对设置到哈希表key中<br/>（2）会覆盖哈希表中已存在的域<br/>（3）key不存在，那么一个空哈希表会被创建并执行HMSET操作 | HMSET key field value [field value ...] |
| HKEYS    | （1）返回哈希表key中的所有域                                 | HKEYS key                               |
| HVALS    | （1）返回哈希表key中所有的域和值                             | HVALS key                               |



## List类型, 所有元素是有序的

Redis的List类型其实就是每一个元素都是String类型的双向链表。我们可以从链表的头部和尾部添加或者删除元素。这样的List既可以作为栈，也可以作为队列使用。

如好友列表，粉丝列表，消息队列，最新消息排行等。另外还有一个就是，可以利用lrange命令，做**基于redis的分页功能**，性能极佳，用户体验好。

![http://www.miaomiaoqi.github.io/images/redis/liststructure.png](http://www.miaomiaoqi.github.io/images/redis/liststructure.png)



| **命令**  | **描述**                                                     | **用法**                              |
| --------- | ------------------------------------------------------------ | ------------------------------------- |
| LPUSH     | （1）将一个或多个值value插入到列表key的表头<br/>（2）如果有多个value值，那么各个value值按从左到右的顺序依次插入表头<br/>（3）key不存在，一个空列表会被创建并执行LPUSH操作<br/>（4）key存在但不是列表类型，返回错误 | LPUSH key value [value ...]           |
| LPUSHX    | （1）将值value插入到列表key的表头，当且晋档key存在且为一个列表<br/>（2）key不存在时，LPUSHX命令什么都不做 | LPUSHX key value                      |
| LPOP      | （1）移除并返回列表key的头元素                               | LPOP key                              |
| LRANGE    | （1）返回列表key中指定区间内的元素，区间以偏移量start和stop指定<br/>（2）start和stop都以0位底<br/>（3）可使用负数下标，-1表示列表最后一个元素，-2表示列表倒数第二个元素，以此类推<br/>（4）start大于列表最大下标，返回空列表<br/>（5）stop大于列表最大下标，stop=列表最大下标 | LRANGE key start stop                 |
| LREM      | （1）根据count的值，移除列表中与value相等的元素<br/>（2）count>0表示从头到尾搜索，移除与value相等的元素，数量为count<br/>（3）count<0表示从从尾到头搜索，移除与value相等的元素，数量为count<br/>（4）count=0表示移除表中所有与value相等的元素 | LREM key count value                  |
| LSET      | （1）将列表key下标为index的元素值设为value<br/>（2）index参数超出范围，或对一个空列表进行LSET时，返回错误 | LSET key index value                  |
| LINDEX    | （1）返回列表key中，下标为index的元素                        | LINDEX key index                      |
| LINSERT   | （1）将值value插入列表key中，位于pivot前面或者后面<br/>（2）pivot不存在于列表key时，不执行任何操作<br/>（3）key不存在，不执行任何操作 | LINSERT key BEFORE\|AFTER pivot value |
| LLEN      | （1）返回列表key的长度<br/>（2）key不存在，返回0             | LLEN key                              |
| LTRIM     | （1）对一个列表进行修剪，让列表只返回指定区间内的元素，不存在指定区间内的都将被移除 | LTRIM key start stop                  |
| RPOP      | （1）移除并返回列表key的尾元素                               | RPOP key                              |
| RPOPLPUSH | 在一个原子时间内，执行两个动作：<br/>（1）将列表source中最后一个元素弹出并返回给客户端<br/>（2）将source弹出的元素插入到列表desination，作为destination列表的头元素 | RPOPLPUSH source destination          |
| RPUSH     | （1）将一个或多个值value插入到列表key的表尾                  | RPUSH key value [value ...]           |
| RPUSHX    | （1）将value插入到列表key的表尾，当且仅当key存在并且是一个列表<br/>（2）key不存在，RPUSHX什么都不做 | RPUSHX key value                      |





## Set类型, 元素是无序的, 元素不能重复. 并集, 交集, 差集

因为set堆放的是一堆不重复值的集合。所以可以做**全局去重**的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。
另外，就是利用交集、并集、差集等操作，可以计算**共同喜好，全部的喜好，自己独有的喜好等功能**

Redis 集合（Set类型）是一个无序的String类型数据的集合，类似List的一个列表，与List不同的是Set不能有重复的数据。实际上，Set的内部是用HashMap实现的，Set只用了HashMap的key列来存储对象

**集合有取交集、并集、差集等操作，因此可以求共同好友、共同兴趣、分类标签等**

| **命令**    | **描述**                                                     | **用法**                              |
| ----------- | ------------------------------------------------------------ | ------------------------------------- |
| SADD        | （1）将一个或多个member元素加入到key中，已存在在集合的member将被忽略<br/>（2）假如key不存在，则只创建一个只包含member元素做成员的集合<br/>（3）当key不是集合类型时，将返回一个错误 | SADD key number [member ...]          |
| SCARD       | （1）返回key对应的集合中的元素数量                           | SCARD key                             |
| SDIFF       | （1）返回一个集合的全部成员，该集合是第一个Key对应的集合和后面key对应的集合的差集 | SDIFF key [key ...]                   |
| SDIFFSTORE  | （1）和SDIFF类似，但结果保存到destination集合而不是简单返回结果集<br/>（2） destination如果已存在，则覆盖 | SDIFFSTORE destionation key [key ...] |
| SINTER      | （1）返回一个集合的全部成员，该集合是所有给定集合的交集<br/>（2）不存在的key被视为空集 | SINTER key [key ...]                  |
| SINTERSTORE | （1）和SINTER类似，但结果保存早destination集合而不是简单返回结果集<br/>（2）如果destination已存在，则覆盖<br/>（3）destination可以是key本身 | SINTERSTORE destination key [key ...] |
| SUNION      | （1）返回一个集合的全部成员，该集合是所有给定集合的并集<br/>（2）不存在的key被视为空集 | SUNION key [key ...]                  |
| SUNIONSTORE | （1）类似SUNION，但结果保存到destination集合而不是简单返回结果集<br/>（2）destination已存在，覆盖旧值<br/>（3）destination可以是key本身 | SUNION destination key [key ...]      |
| SISMEMBER   | （1）判断member元素是否key的成员，0表示不是，1表示是         | SISMEMBER key member                  |
| SMEMBERS    | （1）返回集合key中的所有成员<br/>（2）不存在的key被视为空集  | SMEMBERS key                          |
| SMOVE       | （1）原子性地将member元素从source集合移动到destination集合<br/>（2）source集合中不包含member元素，SMOVE命令不执行任何操作，仅返回0<br/>（3）destination中已包含member元素，SMOVE命令只是简单做source集合的member元素移除 | SMOVE source desination member        |
| SPOP        | （1）移除并返回集合中的一个随机元素，如果count不指定那么随机返回一个随机元素<br/>（2）count为正数且小于集合元素数量，那么返回一个count个元素的数组且数组中的**元素各不相同**<br/>（3）count为正数且大于等于集合元素数量，那么返回整个集合<br/>（4）count为负数那么命令返回一个数组，数组中的**元素可能重复多次**，数量为count的绝对值 | SPOP key [count]                      |
| SRANDMEMBER | （1）如果count不指定，那么返回集合中的一个随机元素<br/>（2）count同上 | SRANDMEMBER key [count]               |
| SREM        | （1）移除集合key中的一个或多个member元素，不存在的member将被忽略 | SREM key member [member ...]          |



## SortedSet, 有序的set, 元素不能重复且有序

SortSet顾名思义，是一个排好序的Set，它在Set的基础上增加了一个顺序属性score，这个属性在添加修改元素时可以指定，每次指定后，SortSet会自动重新按新的值排序。

sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score。 

**可以做排行榜应用，取TOP N操作。可以用来做延时任务。最后一个应用就是可以做范围查找。**

| **命令**         | **描述**                                                     | **用法**                                                  |
| ---------------- | ------------------------------------------------------------ | --------------------------------------------------------- |
| ZADD             | （1）将一个或多个member元素及其score值加入有序集key中<br/>（2）如果member已经是有序集的成员，那么更新member对应的score并重新插入member保证member在正确的位置上<br/>（3）score可以是整数值或双精度浮点数 | ZADD key score member [[score member] [score member] ...] |
| ZCARD            | （1）返回有序集key的元素个数                                 | ZCARD key                                                 |
| ZCOUNT           | （1） 返回有序集key中，score值>=min且<=max的成员的数量       | ZCOUNT key min max                                        |
| ZRANGE           | （1）返回有序集key中指定区间内的成员，成员位置按score从小到大排序<br/>（2）具有相同score值的成员按字典序排列<br/>（3）需要成员按score从大到小排列，使用ZREVRANGE命令<br/>（4）下标参数start和stop都以0为底，也可以用负数，-1表示最后一个成员，-2表示倒数第二个成员<br/>（5）可通过WITHSCORES选项让成员和它的score值一并返回 | ZRANGE key start stop [WITHSCORES]                        |
| ZREVRANGE        | (1)返回有序集key中，指定区间内的成员。其中成员的位置按score值递减(从大到小)来排列 |                                                           |
| ZRANGBYSCORE     | (1)返回有序集key中，指定分数范围的元素列表                   |                                                           |
| ZRANK            | （1）返回有序集key中成员member的排名，有序集成员按score值从小到大排列<br/>（2）排名以0为底，即score最小的成员排名为0<br/>（3）ZREVRANK命令可将成员按score值从大到小排名 | ZRANK key number                                          |
| ZREVRANK         | (1)得成员按score值递减(从大到小)排列的排名                   |                                                           |
| ZREM             | （1）移除有序集key中的一个或多个成员，不存在的成员将被忽略<br/>（2）当key存在但不是有序集时，返回错误 | ZREM key member [member ...]                              |
| ZREMRANGEBYRANK  | （1）移除有序集key中指定排名区间内的所有成员                 | ZREMRANGEBYRANK key start stop                            |
| ZREMRANGEBYSCORE | （1）移除有序集key中，所有score值>=min且<=max之间的成员      | ZREMRANGEBYSCORE key min max                              |
| ZINCRBY          | (1)如果key对应的zset中已经存在元素member，则对member的score属性加指定的值 |                                                           |

## Key命令

| **命令**        | **描述**                                                     | **用法**                                                     |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| DEL             | （1）删除给定的一个或多个key<br/>（2）不存在的Key将被忽略    | DEL key [key ...]                                            |
| EXISTS          | （1）检查给定key是否存在                                     | EXISTS key                                                   |
| EXPIRE          | （1）为给定key设置生存时间，key过期时它会被自动删除<br/>（2）对一个已经指定生存时间的Key设置执行EXPIRE，新的值会代替旧的值 | EXPIRE key seconds                                           |
| EXPIREAT        | （1）同EXPIRE，但此命令指定的是UNIX时间戳，单位为秒          | EXPIRE key timestamp                                         |
| KEYS            | （1）查找所有符合给定模式pattern的key，下面举一下例子<br/>（2）KEYS *匹配所有key<br/>（3）KEYS h?llo匹配hello、hallo、hxllo等<br/>（4）KEYS h*llo匹配hllo、heeeeello等<br/>（5）KEYS h[ae]llo匹配hello和hallo<br/>（6）特殊符号想当做查找内容经的使用\ <br />**(7)线上禁用该命令** | KEYS pattern                                                 |
| MIGRATE         | （1）原子性地将key从当前实例传送到目标实例指定的数据库上<br/>（2）原数据库Key删除，新数据库Key增加<br/>（3）阻塞进行迁移的两个实例，直到迁移成功、迁移失败、等待超时三个之一发生 | MIGRATE host port key destination-db timeout [COPY] [REPLACE] |
| MOVE            | （1）将当前数据库的key移动到给定数据库的db中<br/>（2）执行成功的条件为当前数据库有key，给定数据库没有key | MOVE key db                                                  |
| PERSIST         | （1）移除给定key的生存时间，将key变为持久的                  | PERSIST key                                                  |
| RANDOMKEY       | （1）从当前数据库随机返回且不删除一个key，                   | RANDOMKEY                                                    |
| RENAME          | （1）将key改名为newkey<br/>（2）当key和newkey相同或key不存在，报错<br/>（3）newkey已存在，RENAME将覆盖旧值 | RENAME key newkey                                            |
| TTL             | （1）以秒为单位，返回给定的key剩余生存时间                   | TTL key                                                      |
| PTTL            | （1）以毫秒为单位，返回给定的key剩余生存时间                 | PTTL key                                                     |
| TYPE            | （1）返回key锁存储的值的类型                                 | TYPE key                                                     |
| OBJECT ENCODING | (1)显示数据类型的底层数据结构                                | OBJECT ENCODING key                                          |

## 系统相关命令

| **命令**         | **描述**                                                     | **用法**                   |
| ---------------- | ------------------------------------------------------------ | -------------------------- |
| BGREWRITEAOF     | （1）手动触发AOF重写操作，用于减小AOF文件体积                | BGREWRITEAOF               |
| BGSAVE           | （1）后台异步保存当前数据库的数据到磁盘                      | BGSAVE                     |
| CLIENT KILL      | （1）关闭地址为ip:port的客户端<br/>（2）由于Redis为单线程设计，因此当当前命令执行完之后才会关闭客户端 | CLIENT KILL ip:port        |
| CLIENT LIST      | （1）以可读的格式，返回所有连接到服务器的客户端信息和统计数据 | CLIENT LIST                |
| CONFIG GET       | （1）取得运行中的Redis服务器配置参数<br/>（2）支持*          | CONFIG GET parameter       |
| CONFIG RESETSTAT | （1）重置INFO命令中的某些统计数据，例如Keyspace hits、Keyspace misses等 | CONFIG RESETSTAT           |
| CONFIG REWRITE   | （1）对**启动Redis时指定的redis.conf文件进行改写**           | CONFIG REWRITE             |
| CONFIG SET       | （1）动态调整Redis服务器的配置而无需重启<br/>（2）修改后的配置**立即生效** | CONFIG SET parameter value |
| SELECT           | （1）切换到指定数据库，数据库索引index用数字指定，以0作为起始索引值<br/>（2）默认使用0号数据库 | SELECT index               |
| DBSIZE           | （1）返回当前数据库的Key的数量                               | DBSIZE                     |
| DEBUG OBJECT     | （1）这是一个调试命令，不应当被客户端使用<br/>（2）key存在时返回有关信息，key不存在时返回错误 | DEBUG OBJECT key           |
| FLUSHALL         | （1）清空整个Redis服务器的数据<br />(2)线上禁用              | FLUSHALL                   |
| FLUSHDB          | （1）清空当前数据库中的所有数据                              | FLUSHDB                    |
| INFO             | （1）以一种易于解释且易于阅读的格式，返回Redis服务器的各种信息和统计数值（2）通过给定可选参数section，可以让命令只返回某一部分信息 | INFO [section]             |
| LASTSAVE         | （1）返回最近一次Redis成功将数据保存到磁盘上的时间，以UNIX时间戳格式表示 | LASTSAVE                   |
| MONITOR          | （1）实时打印出Redis服务器接收到的命令，调试用               | MONITOR                    |
| SHUTDOWN         | （1）停止所有客户端<br/>（2）如果至少有一个保存点在等待，执行SAVE命令<br/>（3）如果AOF选项被打开，更新AOF文件<br/>（4）关闭Redis服务器 | SHUTDOWN [SAVE\|NOSAVE]    |
