---
layout: post
title: "Java 底层原理"
categories: [Java]
description:
keywords:
---

* content
{:toc}
## HashMap

众所周知，HashMap是一个用于存储Key-Value键值对的集合，每一个键值对也叫做**Entry**。这些个键值对（Entry）分散存储在一个数组当中，这个数组就是HashMap的主干。

HashMap数组每一个元素的初始值都是Null。

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_1.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_1.png)

对于HashMap，我们最常使用的是两个方法：**Get** 和 **Put**。**利用 hashCode 方法找到链表, 利用 equals 方法找到重复的 key**

### Put 方法的原理

调用Put方法的时候发生了什么呢？

比如调用 hashMap.put("apple", 0), 插入一个Key为“apple"的元素。这时候我们需要利用一个哈希函数来确定 Entry 的插入位置（index）：

**index = Hash（“apple”）**

假定最后计算出的 index 是 2，那么结果如下：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_2.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_2.png)

**但是，因为HashMap的长度是有限的，当插入的Entry越来越多时，再完美的Hash函数也难免会出现 index 冲突的情况。比如下面这样：**

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_3.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_3.png)

这时候该怎么办呢？我们可以利用**链表**来解决。

HashMap数组的每一个元素不止是一个Entry对象，也是一个链表的头节点。每一个Entry对象通过Next指针指向它的下一个Entry节点。当新来的Entry映射到冲突的数组位置时，只需要插入到对应的链表即可：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_4.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_4.png)

**在链表中插入的时候会调用 equals 方法比较两个 key 是否为同一个元素, 如果相等会覆盖原有的数据**

**需要注意的是，新来的Entry节点插入链表时，使用的是“头插法”。至于为什么不插入链表尾部，后面会有解释。**



### Get 方法的原理

使用Get方法根据Key来查找Value的时候，发生了什么呢？

首先会把输入的Key做一次Hash映射，得到对应的index：

**index = Hash（“apple”）**

由于刚才所说的Hash冲突，同一个位置有可能匹配到多个Entry，这时候就需要顺着对应链表的头节点，一个一个向下来查找。假设我们要查找的Key是“apple”：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_5.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_5.png)

第一步，我们查看的是头节点Entry6，Entry6的Key是banana，显然不是我们要找的结果。

第二步，我们查看的是Next节点Entry1，Entry1的Key是apple，正是我们要找的结果。

**之所以把Entry6放在头节点，是因为HashMap的发明者认为，后插入的Entry被查找的可能性更大**。



### HashMap 的初始长度

**HashMap 的默认初始长度是 16, 并且每次自动扩展或是手动初始化时, 长度必须是 2 的幂**

**之所以选择 16, 是为了服务于从 Key 映射到 index 的 hash 算法**

**index = Hash（“apple”）**

如何实现一个尽量均匀分布的Hash函数呢？我们通过利用 Key 的 HashCode 值来做某种运算。

**index = HashCode(Key) % Length**, 这种取模运算很简单, 但是效率很低. 为了实现高效的 Hash 算法, HashMap 发明者采用了位运算的方式

如何进行位运算呢？有如下的公式（Length 是 HashMap的长度）：

**index = HashCode（Key） & （Length - 1）** 

下面我们以值为 “book” 的 Key 来演示整个过程：

1. 计算 book 的 hashcode，结果为十进制的 3029737, 二进制的 101110001110101110 1001
2. 假定HashMap长度是默认的 16，计算 Length - 1 的结果为十进制的 15，二进制的 1111

3. 把以上两个结果做**与运算**, 101110001110101110 1001 & 1111 = 1001, 十进制是 9, 所以 index = 9

可以说，Hash 算法最终得到的 index 结果，完全取决于 Key 的 Hashcode 值的最后几位

**这样做的效果上等同于取模, 而且还大大提高了性能, 至于为什么采用 16, 我们可以试试长度是 10会出现什么问题**

假设HashMap的长度是 10，重复刚才的运算步骤：

1. 计算 book 的 hashcode，结果为十进制的 3029737, 二进制的 101110001110101110 1001
2. HashMap 的长度是 10, 计算 Length - 1 的结果为十进制的 9, 二进制 1001
3. 把以上两个结果做**与运算**, 101110001110101110 1001 & 1001 = 1001, 十进制是 9, 所以 index = 9

单独看这个结果，表面上并没有问题。我们再来尝试一个新的HashCode 101110001110101110 **1011:** 结果为 1001

让我们再换一个HashCode 101110001110101110 **1111:**  结果为 1001

**虽然 HashCode 的倒数第二第三位从  0 变成了 1，但是运算的结果都是 1001。也就是说，当 HashMap 长度为 10 的时候，有些index 结果的出现几率会更大，而有些 index 结果永远不会出现(比如 0111), 因为二三位是 0, 永远 & 不出 1 来**

**这样，显然不符合Hash算法均匀分布的原则**

**反观长度 16 或者其他 2 的幂，Length - 1 的值是所有二进制位全为 1，这种情况下，index 的结果等同于 HashCode 后几位的值。只要输入的 HashCode 本身分布均匀，Hash 算法的结果就是均匀的**

### 高并发下的 HashMap

HashMap的容量是有限的。当经过多次元素插入，使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。

这时候，HashMap需要扩展它的长度，也就是进行 **Resize**

**影响发生 Resize 的因素有两个：**

1. Capacity

    HashMap的当前长度，HashMap的长度是2的幂, 默认是 16

2. LoadFactor

    HashMap 负载因子，默认值为 0.75f。

**衡量 HashMap 是否进行 Resize 的条件如下：**

**HashMap.Size  >= Capacity \* LoadFactor**

**HashMap 的 resize 操作要经过下面两个步骤**

1. 扩容

    创建一个新的 Entry 空数组, 长度是原来数组的 2 倍

2. ReHash

    遍历原Entry数组，把所有的 Entry 重新 Hash 到新数组。为什么要重新 Hash 呢？因为长度扩大以后，Hash 的规则也随之改变。

让我们回顾一下Hash公式：

**index = HashCode(key) & (Length - 1)**

当原数组长度为 8 时，Hash 运算是和 111B 做与运算；新数组长度为 16，Hash 运算是和 1111B 做与运算。Hash 结果显然不同。

**Resize 前的 HashMap:**

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_6.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_6.png)

**Resize 后的 HashMap:**

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_7.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_7.png)



**ReHash的Java代码如下**

```java
void transfer(Entry[] newTable, boolean rehash) {
    int newCapacity = newTable.length;
    for (Entry<K,V> e : table) {
        while(null != e) {
            Entry<K,V> next = e.next;
            if (rehash) {
                e.hash = null == e.key ? 0 : hash(e.key);
            }
            int i = indexFor(e.hash, newCapacity);
            e.next = newTable[i];
            newTable[i] = e;
            e = next;
        }
    }
}
```

上述流程在单线程下没有什么问题, 但是 HashMap 并不是线程安全的, 在多线程环境下, rehash 操作会带来线程安全问题

假设一个 HashMap 已经到了 Resize 的临界点。此时有两个线程 A 和 B，在同一时刻对 HashMap 进行 Put 操作：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_8.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_8.png)

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_9.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_9.png)

此时达到 Resize 条件，两个线程各自进行 Rezie 的第一步，也就是扩容：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_10.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_10.png)

这时候，两个线程都走到了 ReHash 的步骤。让我们回顾一下 ReHash 的代码：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_11.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_11.png)

假如此时线程 B 遍历到 Entry3 对象，刚执行完红框里的这行代码，线程就被挂起。对于线程 B 来说：

**e = Entry3**

**next = Entry2**

这时候线程 A 畅通无阻地进行着 ReHash，当 ReHash 完成后，结果如下（图中的 e 和 next，代表线程 B 的两个引用）

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_12.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_12.png)

直到这一步，看起来没什么毛病。接下来线程 B 恢复，继续执行属于它自己的 ReHash。线程 B 刚才的状态是：

**e = Entry3**

**next = Entry2**

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_13.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_13.png)

当执行到上面这一行时，显然 i = 3，因为刚才线程 A 对于 Entry3 的 hash 结果也是 3。

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_14.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_14.png)

我们继续执行到这两行，Entry3 放入了线程 B 的数组下标为 3 的位置，并且 **e 指向了 Entry2**。此时 e 和 next 的指向如下：

**e = Entry2**

**next = Entry2**

整体情况如图所示：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_15.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_15.png)

接着是新一轮循环，又执行到红框内的代码行：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_16.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_16.png)

**e = Entry2**

**next = Entry3**

整体情况如图所示：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_17.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_17.png)

接下来执行下面的三行，用头插法把 Entry2 插入到了线程B的数组的头结点：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_18.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_18.png)

整体情况如图所示：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_19.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_19.png)

第三次循环开始，又执行到红框的代码：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_20.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_20.png)

**e = Entry3**

**next = Entry3.next = null**

最后一步，当我们执行下面这一行的时候，见证奇迹的时刻来临了：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_21.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_21.png)

**newTable[i] = Entry2**

**e = Entry3**

**Entry2.next = Entry3**

**Entry3.next = Entry2**

**链表出现了环形！**

整体情况如图所示：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_22.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_22.png)

**此时，问题还没有直接产生。当调用 Get 查找一个不存在的 Key，而这个 Key 的 Hash 结果恰好等于 3 的时候，由于位置 3 带有环形链表，所以程序将会进入死循环！**

## ConcurrentHashMap

简单来说，HashMap 是一个 Entry 对象的数组。数组中的每一个 Entry 元素，又是一个链表的头节点。

**Hashmap 不是线程安全的。在高并发环境下做插入操作，有可能出现环型列表导致下一次查询死循环, 想要避免线程安全问题有很多办法, 比如改用 HashTable 或者 Collections.synchronizedMap 方法, 但是这两者有着共同的问题, 性能非常低下, 无论读操作还是写操作, 它们都会给整个集合加锁, 导致同一时间的其他操作阻塞**

在并发环境下, 如何能够兼顾线程安全和运行效率呢, 这时候 ConcurrentHashMap 就应运而生了

**ConcurrentHashMap 其实很简单, 最关键是要理解一个概念: Segment**

同 HashMap 一样，Segment 包含一个 HashEntry 数组，数组中的每一个 HashEntry 既是一个键值对，也是一个链表的头节点。

单一的Segment结构如下：

![http://www.miaomiaoqi.cn/images/java/concurrenthashmap/ch_1.png](http://www.miaomiaoqi.cn/images/java/concurrenthashmap/ch_1.png)

**像这样的 Segment 对象，在 ConcurrentHashMap 集合中有多少个呢？有 2 的 N 次方个，共同保存在一个名为 segments的数组当中。**

因此整个ConcurrentHashMap的结构如下：

![http://www.miaomiaoqi.cn/images/java/concurrenthashmap/ch_2.png](http://www.miaomiaoqi.cn/images/java/concurrenthashmap/ch_2.png)

**可以说，ConcurrentHashMap是一个二级哈希表。在一个总的哈希表下面，有若干个子哈希表。**

**这样的二级结构，和数据库的水平拆分有些相似。**

ConcurrentHashMap 的优势就是采用了**锁分段技术**, 每一个 Segment 就好比一个自治区, 读写操作高度自治, Segment 之间互不影响

**Case1: 不同Segment的并发写入**

![http://www.miaomiaoqi.cn/images/java/concurrenthashmap/ch_3.png](http://www.miaomiaoqi.cn/images/java/concurrenthashmap/ch_3.png)

不同Segment的写入是可以并发执行的。

**Case2：同一Segment的一写一读**

![http://www.miaomiaoqi.cn/images/java/concurrenthashmap/ch_4.png](http://www.miaomiaoqi.cn/images/java/concurrenthashmap/ch_4.png)

**Case3：同一Segment的并发写入**

![http://www.miaomiaoqi.cn/images/java/concurrenthashmap/ch_5.png](http://www.miaomiaoqi.cn/images/java/concurrenthashmap/ch_5.png)

**Segment 的写入是需要上锁的，因此对同一 Segment 的并发写入会被阻塞。**

**由此可见，ConcurrentHashMap 当中每个 Segment 各自持有一把锁。在保证线程安全的同时降低了锁的粒度，让并发操作效率更高。**

### Get 方法

1. 为输入的Key做Hash运算，得到hash值(Hash 的过程实际上是 2 次保证平均)

2. 通过hash值，定位到对应的Segment对象

3. 再次通过hash值，定位到Segment当中数组的具体位置。

### PUT 方法

1. 为输入的Key做Hash运算，得到hash值

2. 通过hash值，定位到对应的Segment对象

3. 获取可重入锁

4. 再次通过hash值，定位到Segment当中数组的具体位置

5. 插入或覆盖HashEntry对象

6. 释放锁

从步骤可以看出, ConcurrentHashMap 在读写时都需要二次定位. 首先定位到 Segment, 之后定位到 Segment 内的具体数组下标

### size 方法如何保证一致性

每个 segment 都各自加锁, 在调用 size 方法时怎么解决一致性问题呢

Size方法的目的是统计 ConcurrentHashMap 的总元素数量， 自然需要把各个 Segment 内部的元素数量汇总起来。

**但是，如果在统计Segment元素数量的过程中，已统计过的Segment瞬间插入新的元素，这时候该怎么办呢？**

![http://www.miaomiaoqi.cn/images/java/concurrenthashmap/ch_6.png](http://www.miaomiaoqi.cn/images/java/concurrenthashmap/ch_6.png)

![http://www.miaomiaoqi.cn/images/java/concurrenthashmap/ch_7.png](http://www.miaomiaoqi.cn/images/java/concurrenthashmap/ch_7.png)

![http://www.miaomiaoqi.cn/images/java/concurrenthashmap/ch_8.png](http://www.miaomiaoqi.cn/images/java/concurrenthashmap/ch_8.png)

**ConcurrentHashMap的Size方法是一个嵌套循环，大体逻辑如下**

1. 遍历所有的 Segment。

2. 把 Segment 的元素数量累加起来。

3. 把 Segment 的修改次数累加起来。

4. 判断所有 Segment 的总修改次数是否大于上一次的总修改次数。如果大于，说明统计过程中有修改，重新统计，尝试次数+1, 如果不是。说明没有修改，统计结束。

5. 如果尝试次数超过阈值，则对每一个 Segment 加锁，再重新统计。

6. 再次判断所有 Segment 的总修改次数是否大于上一次的总修改次数。由于已经加锁，次数一定和上次相等。

7. 释放锁，统计结束。

**为什么这样设计呢？这种思想和乐观锁悲观锁的思想如出一辙。**

**为了尽量不锁住所有 Segment，首先乐观地假设 Size 过程中不会有修改。当尝试一定次数，才无奈转为悲观锁，锁住所有Segment 保证强一致性。**



## List

### 常见 List 初始化方式

1. **先创建 List 在赋值**

    标准方式, 先创建集合对象, 然后逐个调用`add`方法初始化. 用起来比较繁琐, 不太方便

    ```java
    List<Integer> list = new ArrayList<>();
    list.add(1);
    list.add(2);
    list.add(3);
    ```

2. **使用`{{}}`双大括号初始化**

    使用匿名内部类完成初始化. 外层的`{}`定义了一个ArrayList的匿名内部类, 内层的`{}`定义了一个实例初始化的非静态构造代码块. **有内存泄露风险**

    ```java
    List<Integer> list = new ArrayList(){
    	{
    		add(1);
    		add(2);
    		add(3);
    	}
    }
    ```

3. **使用 Arrays.asList**

    使用 Arrays 的静态方法 `asList` 初始化. **返回的 list 集合是不可变的**

    ```java
    List<Integer> list = Arrays.asList(1, 2, 3);
    ```

4. **使用 Stream (JDK8 以上)**

    使用 JDK8 引入的 Stream 的 of 方法生成一个 stream 对象, 调用 `collect` 方法进行收集, 形成一个 List 集合

    ```java
    List<Integer> list = Stream.of(1, 2, 3).collect(Collectors.toList());
    ```

5. **使用 Google Guava(需要引入 Guava 工具包)**

    借助 Google Guava 工具集中的 `Lists` 工具类初始化. 需要引入 Guava 才能使用

    ```java
    List<Integer> list = Lists.newArrayList(1, 2, 3);
    ```

6. **使用 Lists(JDK9 以上)**

    使用 JDK9 引入的 `Lists` 完成初始化

    ```java
    List<Integer> list = Lists.of(1, 2, 3);
    ```

    

## 类加载过程(以 Person 类为例 Person p = new Person())

1. 静态方法区为 Person 类开辟一个空间
2. Person 的静态成员变量加载进该空间
3. Person 类的静态成员变量默认初始化
4. Person 类的静态成员变量显示初始化
5. Person 类的静态方法加载进该空间
6. 非静态方法区为 Person 类开辟一个空间
7. Person 类的非静态方法(构造方法, 普通方法) 加载进该空间
8. 栈内存中声明变量`p`
9. 堆内存中为 new Person() 开辟一个空间
10. 非静态成员变量默认初始化
11. 调用 Person() 的构造方法
12. 默认第一行调用父类的构造方法 super()
13. 非静态成员变量显示初始化
14. 执行非静态构造代码块
15. 构造函数继续向下执行
16. 将栈内存中的变量`p`指向堆内存中的`new Person()`