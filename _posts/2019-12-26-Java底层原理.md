---
layout: post
title:  "Java 底层原理"
date:   2019-12-17 17:38:04
categories: Java
tags: Grammar
author: miaoqi
---

* content
{:toc}
## HashMap

众所周知，HashMap是一个用于存储Key-Value键值对的集合，每一个键值对也叫做**Entry**。这些个键值对（Entry）分散存储在一个数组当中，这个数组就是HashMap的主干。

HashMap数组每一个元素的初始值都是Null。

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_1.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_1.png)

对于HashMap，我们最常使用的是两个方法：**Get** 和 **Put**。**利用 hashCode 方法找到链表, 利用 equals 方法找到重复的 key**

### Put 方法的原理

调用Put方法的时候发生了什么呢？

比如调用 hashMap.put("apple", 0), 插入一个Key为“apple"的元素。这时候我们需要利用一个哈希函数来确定 Entry 的插入位置（index）：

**index = Hash（“apple”）**

假定最后计算出的 index 是 2，那么结果如下：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_2.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_2.png)

**但是，因为HashMap的长度是有限的，当插入的Entry越来越多时，再完美的Hash函数也难免会出现 index 冲突的情况。比如下面这样：**

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_3.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_3.png)

这时候该怎么办呢？我们可以利用**链表**来解决。

HashMap数组的每一个元素不止是一个Entry对象，也是一个链表的头节点。每一个Entry对象通过Next指针指向它的下一个Entry节点。当新来的Entry映射到冲突的数组位置时，只需要插入到对应的链表即可：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_4.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_4.png)

**在链表中插入的时候会调用 equals 方法比较两个 key 是否为同一个元素, 如果相等会覆盖原有的数据**

**需要注意的是，新来的Entry节点插入链表时，使用的是“头插法”。至于为什么不插入链表尾部，后面会有解释。**



### Get 方法的原理

使用Get方法根据Key来查找Value的时候，发生了什么呢？

首先会把输入的Key做一次Hash映射，得到对应的index：

**index = Hash（“apple”）**

由于刚才所说的Hash冲突，同一个位置有可能匹配到多个Entry，这时候就需要顺着对应链表的头节点，一个一个向下来查找。假设我们要查找的Key是“apple”：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_5.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_5.png)

第一步，我们查看的是头节点Entry6，Entry6的Key是banana，显然不是我们要找的结果。

第二步，我们查看的是Next节点Entry1，Entry1的Key是apple，正是我们要找的结果。

**之所以把Entry6放在头节点，是因为HashMap的发明者认为，后插入的Entry被查找的可能性更大**。



### HashMap 的初始长度

**HashMap 的默认初始长度是 16, 并且每次自动扩展或是手动初始化时, 长度必须是 2 的幂**

**之所以选择 16, 是为了服务于从 Key 映射到 index 的 hash 算法**

**index = Hash（“apple”）**

如何实现一个尽量均匀分布的Hash函数呢？我们通过利用 Key 的 HashCode 值来做某种运算。

**index = HashCode(Key) % Length**, 这种取模运算很简单, 但是效率很低. 为了实现高效的 Hash 算法, HashMap 发明者采用了位运算的方式

如何进行位运算呢？有如下的公式（Length 是 HashMap的长度）：

**index = HashCode（Key） & （Length - 1）** 

下面我们以值为 “book” 的 Key 来演示整个过程：

1. 计算 book 的 hashcode，结果为十进制的 3029737, 二进制的 101110001110101110 1001
2. 假定HashMap长度是默认的 16，计算 Length - 1 的结果为十进制的 15，二进制的 1111

3. 把以上两个结果做**与运算**, 101110001110101110 1001 & 1111 = 1001, 十进制是 9, 所以 index = 9

可以说，Hash 算法最终得到的 index 结果，完全取决于 Key 的 Hashcode 值的最后几位

**这样做的效果上等同于取模, 而且还大大提高了性能, 至于为什么采用 16, 我们可以试试长度是 10会出现什么问题**

假设HashMap的长度是 10，重复刚才的运算步骤：

1. 计算 book 的 hashcode，结果为十进制的 3029737, 二进制的 101110001110101110 1001
2. HashMap 的长度是 10, 计算 Length - 1 的结果为十进制的 9, 二进制 1001
3. 把以上两个结果做**与运算**, 101110001110101110 1001 & 1001 = 1001, 十进制是 9, 所以 index = 9

单独看这个结果，表面上并没有问题。我们再来尝试一个新的HashCode 101110001110101110 **1011:** 结果为 1001

让我们再换一个HashCode 101110001110101110 **1111:**  结果为 1001

**虽然 HashCode 的倒数第二第三位从  0 变成了 1，但是运算的结果都是 1001。也就是说，当 HashMap 长度为 10 的时候，有些index 结果的出现几率会更大，而有些 index 结果永远不会出现(比如 0111), 因为二三位是 0, 永远 & 不出 1 来**

**这样，显然不符合Hash算法均匀分布的原则**

**反观长度 16 或者其他 2 的幂，Length - 1 的值是所有二进制位全为 1，这种情况下，index 的结果等同于 HashCode 后几位的值。只要输入的 HashCode 本身分布均匀，Hash 算法的结果就是均匀的**

### 高并发下的 HashMap

HashMap的容量是有限的。当经过多次元素插入，使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。

这时候，HashMap需要扩展它的长度，也就是进行 **Resize**

**影响发生 Resize 的因素有两个：**

1. Capacity

    HashMap的当前长度，HashMap的长度是2的幂, 默认是 16

2. LoadFactor

    HashMap 负载因子，默认值为 0.75f。

**衡量 HashMap 是否进行 Resize 的条件如下：**

**HashMap.Size  >= Capacity \* LoadFactor**

**HashMap 的 resize 操作要经过下面两个步骤**

1. 扩容

    创建一个新的 Entry 空数组, 长度是原来数组的 2 倍

2. ReHash

    遍历原Entry数组，把所有的 Entry 重新 Hash 到新数组。为什么要重新 Hash 呢？因为长度扩大以后，Hash 的规则也随之改变。

让我们回顾一下Hash公式：

**index = HashCode(key) & (Length - 1)**

当原数组长度为 8 时，Hash 运算是和 111B 做与运算；新数组长度为 16，Hash 运算是和 1111B 做与运算。Hash 结果显然不同。

**Resize 前的 HashMap:**

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_6.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_6.png)

**Resize 后的 HashMap:**

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_7.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_7.png)



**ReHash的Java代码如下**

```java
void transfer(Entry[] newTable, boolean rehash) {
    int newCapacity = newTable.length;
    for (Entry<K,V> e : table) {
        while(null != e) {
            Entry<K,V> next = e.next;
            if (rehash) {
                e.hash = null == e.key ? 0 : hash(e.key);
            }
            int i = indexFor(e.hash, newCapacity);
            e.next = newTable[i];
            newTable[i] = e;
            e = next;
        }
    }
}
```

上述流程在单线程下没有什么问题, 但是 HashMap 并不是线程安全的, 在多线程环境下, rehash 操作会带来线程安全问题

假设一个 HashMap 已经到了 Resize 的临界点。此时有两个线程 A 和 B，在同一时刻对 HashMap 进行 Put 操作：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_8.png](http://www.miaomiaoqi.cn/images/java/hashamap/hashmap_8.png)

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_9.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_9.png)

此时达到Resize条件，两个线程各自进行Rezie的第一步，也就是扩容：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_10.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_10.png)

这时候，两个线程都走到了ReHash的步骤。让我们回顾一下ReHash的代码：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_11.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_11.png)

假如此时线程B遍历到Entry3对象，刚执行完红框里的这行代码，线程就被挂起。对于线程B来说：

**e = Entry3**

**next = Entry2**

这时候线程A畅通无阻地进行着Rehash，当ReHash完成后，结果如下（图中的e和next，代表线程B的两个引用）

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_12.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_12.png)

直到这一步，看起来没什么毛病。接下来线程B恢复，继续执行属于它自己的ReHash。线程B刚才的状态是：

**e = Entry3**

**next = Entry2**

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_13.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_13.png)

当执行到上面这一行时，显然 i = 3，因为刚才线程A对于Entry3的hash结果也是3。

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_14.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_14.png)

我们继续执行到这两行，Entry3放入了线程B的数组下标为3的位置，并且**e指向了Entry2**。此时e和next的指向如下：

**e = Entry2**

**next = Entry2**

整体情况如图所示：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_15.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_15.png)

接着是新一轮循环，又执行到红框内的代码行：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_16.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_16.png)

**e = Entry2**

**next = Entry3**

整体情况如图所示：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_17.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_17.png)

接下来执行下面的三行，用头插法把Entry2插入到了线程B的数组的头结点：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_18.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_18.png)

整体情况如图所示：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_19.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_19.png)

第三次循环开始，又执行到红框的代码：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_20.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_20.png)

**e = Entry3**

**next = Entry3.next = null**

最后一步，当我们执行下面这一行的时候，见证奇迹的时刻来临了：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_21.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_21.png)

**newTable[i] = Entry2**

**e = Entry3**

**Entry2.next = Entry3**

**Entry3.next = Entry2**

**链表出现了环形！**

整体情况如图所示：

![http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_22.png](http://www.miaomiaoqi.cn/images/java/hashmap/hashmap_22.png)

**此时，问题还没有直接产生。当调用Get查找一个不存在的Key，而这个Key的Hash结果恰好等于3的时候，由于位置3带有环形链表，所以程序将会进入死循环！**

## ConcurrentHashMap

## List

### 常见 List 初始化方式

1. **先创建 List 在赋值**

    标准方式, 先创建集合对象, 然后逐个调用`add`方法初始化. 用起来比较繁琐, 不太方便

    ```java
    List<Integer> list = new ArrayList<>();
    list.add(1);
    list.add(2);
    list.add(3);
    ```

2. **使用`{{}}`双大括号初始化**

    使用匿名内部类完成初始化. 外层的`{}`定义了一个ArrayList的匿名内部类, 内层的`{}`定义了一个实例初始化的非静态构造代码块. **有内存泄露风险**

    ```java
    List<Integer> list = new ArrayList(){
    	{
    		add(1);
    		add(2);
    		add(3);
    	}
    }
    ```

3. **使用Arrays.asList**

    使用 Arrays 的静态方法 `asList` 初始化. **返回的 list 集合是不可变的**

    ```java
    List<Integer> list = Arrays.asList(1, 2, 3);
    ```

4. **使用 Stream (JDK8 以上)**

    使用 JDK8 引入的 Stream 的 of 方法生成一个 stream 对象, 调用 `collect` 方法进行收集, 形成一个 List 集合

    ```java
    List<Integer> list = Stream.of(1, 2, 3).collect(Collectors.toList());
    ```

5. **使用Google Guava(需要引入 Guava 工具包)**

    借助 Google Guava 工具集中的 `Lists` 工具类初始化. 需要引入 Guava 才能使用

    ```java
    List<Integer> list = Lists.newArrayList(1, 2, 3);
    ```

6. **使用Lists(JDK9 以上)**

    使用 JDK9 引入的 `Lists` 完成初始化

    ```java
    List<Integer> list = Lists.of(1, 2, 3);
    ```

    

## 类加载过程(以 Person 类为例 Person p = new Person())

1. 静态方法区为 Person 类开辟一个空间
2. Person 的静态成员变量加载进该空间
3. Person 类的静态成员变量默认初始化
4. Person 类的静态成员变量显示初始化
5. Person 类的静态方法加载进该空间
6. 非静态方法区为 Person 类开辟一个空间
7. Person 类的非静态方法(构造方法, 普通方法) 加载进该空间
8. 栈内存中声明变量`p`
9. 堆内存中为 new Person() 开辟一个空间
10. 非静态成员变量默认初始化
11. 调用 Person() 的构造方法
12. 默认调用父类的构造方法
13. 非静态成员变量显示初始化
14. 执行非静态构造代码块
15. 构造函数继续向下执行
16. 将栈内存中的变量`p`指向堆内存中的`new Person()`