---
layout: post
title:  "Redis分布式锁"
date:   2018-06-16 15:12:38
categories: NoSql
tags: Redis
author: miaoqi
---

* content
{:toc}


## 使用Redis实现分布式锁

和Memcached的方式类似，利用Redis的setnx命令。此命令同样是原子性操作，只有在key不存在的情况下，才能set成功。（setnx命令并不完善，后续会介绍替代方案）
    
1. 加锁: 

    最简单的方法是使用setnx命令。key是锁的唯一标识，按业务来决定命名。比如想要给一种商品的秒杀活动加锁，可以给key命名为 “lock_sale_商品ID” 。而value设置成什么呢？我们可以姑且设置成1。加锁的伪代码如下：    

        setnx（key，1）

    当一个线程执行setnx返回1，说明key原本不存在，该线程成功得到了锁；当一个线程执行setnx返回0，说明key已经存在，该线程抢锁失败。

2. 解锁:

    有加锁就得有解锁。当得到锁的线程执行完任务，需要释放锁，以便其他线程可以进入。释放锁的最简单方式是执行del指令，伪代码如下：

        del（key）

    释放锁之后，其他线程就可以继续执行setnx命令来获得锁

3. 锁超时:

    锁超时是什么意思呢？如果一个得到锁的线程在执行任务的过程中挂掉，来不及显式地释放锁，这块资源将会永远被锁住，别的线程再也别想进来。所以，setnx的key必须设置一个超时时间，以保证即使没有被显式释放，这把锁也要在一定时间后自动释放。setnx不支持超时参数，所以需要额外的指令，伪代码如下：

        expire（key， 30）

    综合起来，我们分布式锁实现的第一版伪代码如下：

        if（setnx（key，1） == 1）{
            expire（key，30）
            try {
                do something ......
            } finally {
                del（key）
            }
        }
    
4. 第一版存在的问题:

    1.  setnx和expire的非原子性, 当A线程得到了锁, 还未来得及设置超时时间就挂掉了, 会导致锁没有超时时间, 在Redis2.6.12以上版本增加了set（key，1，30，NX）取代了setnx

    2. del 导致误删, 假如A线程得到了锁, 并且设置30秒超时, 如果某些原因导致了A超过了30秒, 自动释放锁, B线程获得了锁, 当A运行完成后, 删除了锁, 直接删除的是B线程的锁, 可以再del之前判断一下这个锁是不是自己的, 即将value设置成线程id, 每次删除前判断一下是不是自己的锁, 这样实际上有并发问题

    3. 还是刚才第二点所描述的场景，虽然我们避免了线程A误删掉key的情况，但是同一时间有A，B两个线程在访问代码块，仍然是不完美的。怎么办呢？我们可以让获得锁的线程开启一个守护线程，用来给快要过期的锁“续航”。这样就避免了A线程执行时间过长, 导致锁自动释放的问题, 假设锁是30秒, 让守护线程29秒时给锁续命20秒, 当A线程销毁时, 守护线程也就销毁了 
    
    
    
    