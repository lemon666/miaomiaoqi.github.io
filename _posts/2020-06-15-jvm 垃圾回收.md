---
layout: post
title: jvm 垃圾回收
categories: [Java]
description: 
keywords: 
---

* content
{:toc}


## 如何判断对象可以回收

### 引用计数法

无法避免循环引用方法

### 可达性分析法

Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象

扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，找不到，表示可以回收

哪些对象可以作为 GC Root ?





### 四种引用

1.  强引用

    只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收

2.  软引用（SoftReference）

    仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象

    可以配合引用队列来释放软引用自身

3.  弱引用（WeakReference）

    仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象

    可以配合引用队列来释放弱引用自身

4.  虚引用（PhantomReference）

    必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存

5.  终结器引用（FinalReference）

    无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize方法，第二次 GC 时才能回收被引用对象





## 垃圾回收算法

### 标记清除

Mark Sweep

速度较快

### 标记整理

Mark Compact

速度慢



### 复制

Copy

不会有内存碎片

需要占用双倍内存空间





## 分代垃圾回收

![http://www.milky.show/images/java/jvm/jvm_10.png](http://www.milky.show/images/java/jvm/jvm_10.png)

对象首先分配在伊甸园区域

新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且交换 from to

minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行

当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）

当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时间更长



### 相关 JVM 参数

| 含义                   | 参数                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 堆初始大小             | -Xms                                                         |
| 堆最大大小             | -Xmx 或 -XX:MaxHeapSize=size                                 |
| 新生代大小             | -Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size )            |
| 幸存区比例（动态）     | -XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy |
| 幸存区比例(伊甸园占比) | -XX:SurvivorRatio=ratio                                      |
| 晋升阈值               | -XX:MaxTenuringThreshold=threshold                           |
| 晋升详情               | -XX:+PrintTenuringDistribution                               |
| GC详情                 | -XX:+PrintGCDetails -verbose:gc                              |
| FullGC 前 MinorGC      | -XX:+ScavengeBeforeFullGC                                    |



## 垃圾回收器

串行

* 单线程

*   堆内存较小，适合个人电脑

吞吐量优先

*   多线程
*   堆内存较大, 多核 cpu

*   让单位时间内，STW 的**总时间**最短 0.2 0.2 = 0.4，垃圾回收时间占比最低，这样就称吞吐量高

响应时间优先

*   多线程

*   堆内存较大，多核 cpu

*   尽可能让**单次** STW 的时间最短 0.1 0.1 0.1 0.1 0.1 = 0.5

### 串行

-XX:+UseSerialGC = Serial(新生代, 复制算法) + SerialOld(老年代, 标记整理算法)

![http://www.milky.show/images/java/jvm/jvm_11.png](http://www.milky.show/images/java/jvm/jvm_11.png)

单线程的只会有一个线程进行垃圾回收



### 吞吐量优先

-XX:+UseParallelGC ~ -XX:+UseParallelOldGC (1.8 中默认)

-XX:+UseAdaptiveSizePolicy(采用自适应的大小调整策略, 调整新生代的大小)

-XX:GCTimeRatio=ratio(1 / (1 + ratio))

 -XX:MaxGCPauseMillis=ms (200ms)

-XX:ParallelGCThreads=n

![http://www.milky.show/images/java/jvm/jvm_12.png](http://www.milky.show/images/java/jvm/jvm_12.png)



### 响应时间优先

-XX:+UseConcMarkSweepGC(老年代垃圾回收) ~ -XX:+UseParNewGC ~ SerialOld(有时会退化成串行)

-XX:ParallelGCThreads=n(并行线程数, 建议 CPU 核数) ~ -XX:ConcGCThreads=threads(并发线程数, 建议并行线程数的四分之一)

-XX:CMSInitiatingOccupancyFraction=percent

-XX:+CMSScavengeBeforeRemark

![http://www.milky.show/images/java/jvm/jvm_13.png](http://www.milky.show/images/java/jvm/jvm_13.png)





### G1

Garbage First

*   2004 论文发布

*   2009 JDK 6u14 体验

*   2012 JDK 7u4 官方支持

*   2017 JDK 9 默认

适用场景

*   同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms

*   超大堆内存，会将堆划分为多个大小相等的 Region

*   整体上是标记+整理算法，两个区域之间是复制算法

相关 JVM 参数

-XX:+UseG1GC

-XX:G1HeapRegionSize=size

-XX:MaxGCPauseMillis=time

#### G1 回收阶段

![http://www.milky.show/images/java/jvm/jvm_14.png](http://www.milky.show/images/java/jvm/jvm_14.png)

##### Young Collection

会 STW

![http://www.milky.show/images/java/jvm/jvm_15.png](http://www.milky.show/images/java/jvm/jvm_15.png)



##### Young Collection + CM

在 Young GC 时会进行 GC Root 的初始标记

老年代占用堆空间比例达到阈值时，进行并发标记（不会 STW），由下面的 JVM 参数决定

-XX:InitiatingHeapOccupancyPercent=percent （默认45%）

![http://www.milky.show/images/java/jvm/jvm_16.png](http://www.milky.show/images/java/jvm/jvm_16.png)



##### Mixed Collection

会对 E、S、O 进行全面垃圾回收

*   最终标记（Remark）会 STW

*   拷贝存活（Evacuation）会 STW

-XX:MaxGCPauseMillis=ms

![http://www.milky.show/images/java/jvm/jvm_17.png](http://www.milky.show/images/java/jvm/jvm_17.png)



#### JDK 8u20 字符串去重

优点：节省大量内存

缺点：略微多占用了 cpu 时间，新生代回收时间略微增加

-XX:+UseStringDeduplication

```java
String s1 = new String("hello"); // char[]{'h','e','l','l','o'}
String s2 = new String("hello"); // char[]{'h','e','l','l','o'}
```

将所有新分配的字符串放入一个队列

当新生代回收时，G1并发检查是否有字符串重复

如果它们值一样，让它们引用同一个 char[]

注意，与 String.intern() 不一样

*   String.intern() 关注的是字符串对象

*   而字符串去重关注的是 char[]

*   在 JVM 内部，使用了不同的字符串表

#### JDK 8u40 并发标记类卸载

所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类

--XX:+ClassUnloadingWithConcurrentMark 默认启用



#### JDK 8u60 回收巨型对象

一个对象大于 region 的一半时，称之为巨型对象

G1 不会对巨型对象进行拷贝

回收时被优先考虑

G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生代垃圾回收时处理掉



#### JDK 9 并发标记起始时间的调整

并发标记必须在堆空间占满前完成，否则退化为 FullGC

JDK 9 之前需要使用 -XX:InitiatingHeapOccupancyPercent

JDK 9 可以动态调整

*   -XX:InitiatingHeapOccupancyPercent 用来设置初始值

*   进行数据采样并动态调整

*   总会添加一个安全的空档空间

#### JDK 9 更高效的回收

250+增强

180+bug修复

https://docs.oracle.com/en/java/javase/12/gctuning





### Full GC

SerialGC

*   新生代内存不足发生的垃圾收集 - minor gc

*   老年代内存不足发生的垃圾收集 - full gc

ParallelGC

*   新生代内存不足发生的垃圾收集 - minor gc

*   老年代内存不足发生的垃圾收集 - full gc

CMS

*   新生代内存不足发生的垃圾收集 - minor gc

*   老年代内存不足

G1

*   新生代内存不足发生的垃圾收集 - minor gc

*   老年代内存不足







## 垃圾回收调优

