---
layout: post
title:  "JVM学习"
date:   2018-05-17 21:12:38
categories: Work
tags: JVM
author: miaoqi
---

* content
{:toc}
            

## JVM笔记

### 虚拟机

1. Sun Classic VM

    * 世界上第一款商用的Java虚拟机

    * 只能使用纯解释器的方式来执行Java代码

1. Exact VM

    * Exact Memory Management准确试内存管理

    * 编译器和解释器混合工作以及两级即时编译器

    * 只在Solaris平台发布

    * 英雄气短

1. HotSpot VM

    * 称霸武林

1. K VM

    * Kilobyte简单, 轻量, 高度可移植
    
    * 在手机平台运行

1. JRockit

    * BEA公司

    * 世界上最快的Java虚拟机

    * 专注服务器端应用

    * 优势:    
    
        垃圾收集器
        
        MissionControl服务套件

1. J9

    * IBM公司

    * IBM Technology for Java Virtual Machine
    
1. Microsoft JVM

1. TaobaoVM

### 内存区域

#### 线程独占区

1. 程序计数器

    * 程序计数器是一块较小的内存空间, 它可以看做是当前线程所执行的字节码的行号指示器

    * 程序计数器处于线程独占去

    * 如果线程执行的是Java方法, 这个计数器记录的是正在执行的虚拟机字节码指令的地址. 如果正在执行的是native方法, 这个计数器的值为undefined

    * 此区域是唯一一个在Java虚拟机规范中没有任何OutOfMemoryError情况的区域

1. Java虚拟机栈

    * 虚拟机栈描述的是Java方法执行的动态内存模型

    * 栈桢

        * 每个方法执行都会创建一个栈桢, 伴随着方法从创建到执行完成. 用于存储局部变量表, 操作数栈, 动态链接, 方法出口等

    * 局部变量表

        * 存放编译期可知的各种基本数据类型, 引用类型, returnAddress类型

        * 局部变量表的内存空间在编译期完成分配, 当进入一个方法时, 这个方法需要在帧分配多少内存是固定的, 在方法运行期间是不会改变局部变量表的大小

    * 大小

        * StackOverflowError

        * OutOfMemoryError

1. 本地方法栈

    * 虚拟机栈为虚拟机执行Java方法服务

    * 本地方法栈为虚拟机执行native方法服务

#### 线程共享区

1. Java堆

    * 存放对象实例

    * 垃圾收集器管理的主要区域

    * 新生代, 老年代, Eden空间

    * OutOfMemoryError

    * -Xmx -Xms

1. 方法区

    * 存储虚拟机加载的类信息, 常量, 静态变量, 即时编译器编译后的代码等数据

        * 类的版本

        * 字段

        * 方法

        * 接口

    * 方法区和永久代

    * 垃圾回收在方法区的行为

    * 异常的定义

        * OutOfMemoryError

### 元空间

* 元空间的本质和永久代类似, 都是对JVM规范方法区的实现, 元空间使用本地内存

### 直接内存和运行时常量池

1. 运行时常量池

    * 方法区内有一块内存存储运行时常量

1. 直接内存

    * NIO中使用到的, 可以分配堆外内存, 不受约于JVM限制, 可以提高性能

### 对象结构

1. Header(对象头)

    * 自身运行时数据(Mark Word)

        * 哈希值, GC分代年龄, 锁状态标识, 线程持有的锁, 偏向线程id, 偏向时间戳

    * 类型指针

1. InstanceData

    * 相同宽度的字段会被分配到一起, Long/Double short/char

1. Padding

    * 填充内存, 无实际意义

### 对象访问定位

1. 使用句柄

    * 指向堆中一个区域(句柄池), 保存了实例对象的地址, 栈内存的地址不会变

1. 直接指针

    * 从虚拟机栈直接指向堆内存区域, 速度会快, HotSpot就是采用的这种方式

### 垃圾回收

#### 如何判定对象为垃圾对象

1. 引用计数法

    * 在对象中添加一个引用计数器, 当有地方引用这个对象的时候, 引用计数器的值+1, 当引用失效的时候, 引用计数器的值-1

    * -verbose:gc(简单打印日志信息)

    * -XX:+PrintGCDetails(详细打印日志信息)

1. 可达性分析法

    * 从GCRoot向下搜索, 如果不在引用链上的对象, 都视为垃圾对象

    * 作为GCRoot对象

        * 虚拟机栈(虚拟机栈中的局部变量表)

        * 方法区的类属性所引用的对象

        * 方法区中常量所引用的对象

        * 本地方法栈中所引用的对象

#### 回收策略

1. 标记-清除算法

    * 效率比较低, 又要标记, 又要清除

    * 空间问题, 会导致清除的地方内存空间不连续, 如果申请大内存, 查找会浪费时间
        
1. 复制算法(针对新生代)

    * 堆(垃圾回收主要关注的地方)

        * 新生代

            * Eden(伊甸园), 新创建的对象都会放到该区域(80%)

            * Survivor(存活区, 有2块该区域)(10%)(10%)

        * 老年代

            * Tenured Gen

    * 方法区

    * 虚拟机栈, 本地方法栈, 程序计数器

    * 会将内存分为两个区域, 将第一个区域未被标记的内存空间, 复制到另一半区域中并且重新排序, 下一次创建对象再第二块内存区域中创建, 再次清除后, 将第二个区域未被标记的内存空间, 复制到第一块内存区域中, 该算法减少了不连续的空间, 但可使用的空间减少了, 这两块区域就是两块Survivor, 如果内存不够了, 有内存担保, 会将内存放到老年代中
        
1. 标记-整理-清除算法(针对老年代, 回收率较低)

    * 将有用的放一端, 没用的放一端, 直接将没用的清除
         
1. 分代收集算法

    * 针对不同内存, 采用不同算法

#### 常见垃圾收集器

1. Serial(针对新生代, 采用复制算法)

    * 最基本, 发展最悠久

    * 单线程垃圾收集器, 会导致其他所有线程停顿一下, 导致用户体验不好

    * 桌面应用

1. Parnew

    * 跟Serial是相同的, 只不过是多线程的

1. Parallel Scavenge收集器, 提高了用户体验, 相比Parnew多了吞吐量

    * 复制算法(新生代收集器)

    * 多线程收集器

    * 达到可控制的吞吐量

        * 吞吐量: CPU用于运行用户代码的时间与CPU消耗的总时间的比值

        * 吞吐量 = (执行用户代码时间) / (执行用户代码时间 + 垃圾回收所占用的时间)

    * -XX:MaxGCPauseMillis垃圾收集器停顿最大时间, 单位是毫秒 1

        这个值设置的小了, 机会增加频率, 所以要设置合理的值

    * -XX:GCTimeRatio 0 < 吞吐量大小 < 100


1. Cms, Concurrent Mark Sweep(针对老年代)

    * 工作过程

        * 初始标记(GCRoot直接关联的对象)

        * 并发标记

        * 重新标记(对并发标记进行修正)

        * 并发清理

    * 优点

        * 并发收集

        * 低停顿

    * 缺点

        * 占用大量的CPU资源

        * 无法处理浮动垃圾

        * 出现Concurrent Mode Failure

        * 空间碎片

1. G1(标记, 整理, 清除)

    * 优势

        * 并行与并发

        * 分代收集

        * 空间整合

        * 可预测的停顿

    * 步骤

        * 初始标记

        * 并发标记

        * 最终标记

        * 筛选回收(维护了一张表)

### 内存分配

#### 内存分配策略

* 优先分配到Eden区域

    * 如果放不下了, 会将内存放到Survivor中, Survivor中也放不下, 会放到老年代中

    * -Xmn10M, 指定新生代内存

    * -XX:SurvivorRatio=8 指定Eden内存大小

* 大对象直接分配到老年代(垃圾回收次数低)

    * -XX:PretenureSizeThreshold=10M 指定多大的内存是大内存

* 长期存活的对象分配到老年代

    * -XX:MaxTenuringThreshold 15

    * Age 1 + 1 + 1 每次GC之后对象的年龄+1

* 空间分配担保

    * -XX:+HandlePromotionFailure 是否开启空间分配担保

* 动态对象年龄

* 逃逸分析与栈上分配

    * 逃逸分析: 分析对象的作用域, 如果没有方法外部引用方法内部的对象, 就认为这个对象没有发生逃逸, 就可以把这个对象放到栈内存中

    * 栈上分配: 根据方法的执行进行分配与释放, 不需要垃圾回收, 性能高


### 虚拟机工具

#### jps

* jps(java process status)

* 本地虚拟机唯一id lvmid local virtual machine id

* jps -l 可以查看主类

* jps -m 进程所接受的输入参数

* jps -v 进程锁接受的vm参数

#### jstat

* 监控虚拟机运行信息

* 类装载, 内存, 垃圾收集, jit编译的信息

#### jinfo

* 实时查看和调整虚拟机参数

#### jmap

* jmap -dump:format=b,file=/asf/a.bin pid

#### jhat(jvm heap analysis tool)

#### jstack

* 生成线程快照

    jstack -l pid

### 可视化虚拟机工具

#### jConsole

* 内存监控

* 线程监控

* 死锁监控

#### VisualVM

* 首页: https://visualvm.github.io/index.html

* 插件地址: https://visualvm.github.io/pluginscenters.html


### 性能调优

* 知识 + 工具 + 数据 + 经验

* 案例1

    频繁发生Full GC, 堆内存设置的过大, 而且大内存对象非常多, 所以会触发Full GC, 导致每次GC时间过长, 出现卡顿, 通过部署多个web容器, 减少每个web容器的堆内存来解决这个问题

* 案例2

    不定期内存溢出, 把内存加大也无济于事. 导出内存快照信息, 没有任何信息, 内存监控正常. 因为使用了NIO的堆外内存, 所以监控不到内存信息

* 案例3

    连接过度, 中间增加MQ


### Class文件

#### Class文件简介和发展历史

* Eclipse编译Java代码, 是使用javac吗?

#### Class文件结构

* Class文件是一组以8位字节为基础单位的二进制流, 各个数据项目严格按照顺序紧凑的排列在Class文件之中, 中间没有添加任何分隔符, 整个Class文件中存储的内容几乎全部是程序运行的必要数据, 没有空隙存在

* 当遇到8位自己以上的空间的数据项时, 则会按照高位在前的方式分割成若干个8位字节进行存储

* Class文件有两种数据类型, 分别是无符号数和表

1. Class文件格式

    |类型|名称|数量|
    |-----|-----|-------|
    |u4|magic|1|
    |u2|minor_version|1|
    |u2|major_version|1|
    |u2|`constant_pool_count`|1|
    |cp_info|constant_pool| `constant_pool_count` - 1 |
    |u2|access_flags|1|
    |u2|this_class|1|
    |u2|super_class|1|
    |u2|interfaces_count|1|
    |u2|interfaces|interfaces_count|
    |u2|fields_count|1|
    |field_info|fields|fields_count|
    |u2|methods_count|1|
    |method_info|methods|methods_count|
    |u2|attribute_count|1|
    |attribute_info|attributes|attributes_count|

1. 魔数

    * CAFE BABE就是标识一个文件是class文件

1. Class文件版本

    * JDK1.8 = 52
    * JDK1.7 = 51
    * JDK1.6 = 50
    * JDK1.5 = 49
    * JDK1.4 = 48
    * JDK1.3 = 47
    * JDK1.2 = 46
    * JDK1.1 = 45

1. 常量池

1. 访问标志

1. 类索引, 父类索引, 接口索引集合

1. 字段表集合

1. 方法表集合

1. 属性表集合

### 字节码指令

* Java虚拟机的指令由一个字节长度的, 代表着某种特定操作含义的数字, 称之为操作码, 以及跟随其后的零至多个代表此操作所需参数的操作数而构成

* 操作码的长度为1个字节, 因此最大只有256条

* 基于栈的指令集架构

* javap -verbose HelloWorld.class

#### 加载和存储指令

* 加载和存储指令用于将数据在栈桢中的局部变量表和操作数栈之间来回传输

* 将局部变量表加载到操作数栈: iload lload fload dload aload

* 将一个数值从操作数栈存储到局部变量表: istore lfda

* 将一个常量加载到操作数栈: bipush sipush ldc ldc_w ldc2_w aconst_null iconst_m1 iconst

* 扩充局部变量表的访问索引指令: wide

#### 运算指令

* 运算或算数指令用于对两个操作数栈上的值进行某种特定的运算, 并把运算结果存储到操作数栈顶

* 加法指令: add

* 减法指令: sub

* 乘法指令: mul

* 除法指令: div

* 取余指令: rem

* 取反指令: neg

#### 类型转换指令

* 类型转换指令可以将两种不同的数值类型进行相互转换, 这些转换操作一般用于实现用户代码中的显示类型转换操作以及用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题

* 宽化类型处理和窄化类型处理

* i2b i2c i2s l2i...

#### 对象创建于访问指令

* 创建对象实例的指令: new

* 创建数组的指令: newarray anewarray multianewarray

* 访问类字段: getfield putfield getstatic putstatic

* 把数组元素加载到操作数栈的指令: baload c s l l f d a

* 将操作数栈的值存储到数组元素: astore

* 取数组长度的指令: arraylength

* 检查实例类型的指令: instanceof checkcast


### 类加载

* 虚拟机把描述类的数据从Class文件加载到内存, 并对数据进行校验, 解析和初始化, 最终形成可以被虚拟机直接使用的Java类型, 这就是虚拟机的类加载机制

* 懒加载

* 生命周期

    加载 -> 连接(验证, 准备, 解析) -> 初始化 -> 使用 -> 卸载

    初始化:

    1. 遇到new, getstatic, putstatic, invokestatic这4条字节码指令, 如果类没进行过初始化, 则需要先触发其初始化. 使用 new 创建对象时, 读取或设置一个类的静态字段(被final修饰, 已在编译器把结果放入常量池的静态字段除外), 以及调用一个类的静态方法

    2. 使用反射对类进行反射调用时

    3. 当初始化一个类的时候, 如果发现父类没初始化, 则需要先触发父类的初始化

    4. 当虚拟机启动时候, 需要一个程序入口, 就是包含Main方法的类


    不被初始化:

    1. 子类引用父类的静态变量, 不会初始化子类

    1. 通过数组定义来引用

    1. 调用类的常量

#### 类加载

* 通过一个类的全限定名来获取定义此类的二进制流

* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构

* 在内存中生成一个代表这个类的Class对象, 作为这个类的各种数据的访问入口

* 加载源: 文件(Class文件, Jar文件), 网络, 计算生成一个二进制流(Proxy), 由其他文件生成(jsp), 数据库

#### 验证(安全性考虑)

* 验证是连接的第一步, 这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求, 并且不会危害虚拟机自身的安全

* 文件格式验证

* 元数据验证

* 字节码验证

* 符合引用验证

#### 准备

* 准备阶段正式为类变量分配内存并设置变量的初始值, 这些变量的内存都将在方法区中进行分配

* 这里的初始值并非我们指定的值, 而是其默认值, 如果被final修饰, 常量值会被一同指定

#### 解析

* 解析阶段是虚拟机将常量池中的符号引用替换为直接引用

* 类或者接口的解析

* 字段解析

* 类方法解析

* 接口方法解析

#### 初始化是类加载的最后一步

* 初始化是类加载的最后一步

* 初始化是执行<clinit>方法的过程


### 类加载器

* 虚拟机的设计团队把类加载阶段中的"通过一个类的全限定名来获取描述此类的二进制字节流"这个动作放到Java虚拟机外部去实现, 以便让应用程序自己决定如何去获取所需要的类, 实现这个动作的代码模块称之为类加载器

* 只有被同一个类加载器加载的类才可能会相等, 相同的字节码被不同的类加载器加载的类不相等


    
    
    
    
    
    
    
    
    
    