---
layout: post
title:  "JVM学习"
date:   2018-05-17 21:12:38
categories: Java
tags: JVM
author: miaoqi
---

* content
{:toc}

## 虚拟机

1. Sun Classic VM

    * 世界上第一款商用的Java虚拟机

    * 只能使用纯解释器的方式来执行Java代码

1. Exact VM

    * Exact Memory Management准确试内存管理

    * 编译器和解释器混合工作以及两级即时编译器

    * 只在Solaris平台发布

    * 英雄气短

1. HotSpot VM

    * 称霸武林

1. K VM

    * Kilobyte简单, 轻量, 高度可移植
    
    * 在手机平台运行

1. JRockit

    * BEA公司

    * 世界上最快的Java虚拟机

    * 专注服务器端应用

    * 优势:    
    
        垃圾收集器
        
        MissionControl服务套件

1. J9

    * IBM公司

    * IBM Technology for Java Virtual Machine
    
1. Microsoft JVM

1. TaobaoVM

## 垃圾回收

### 触发条件

* 程序调用System.gc时可以触发

* 系统自身来决定GC触发的时机

    * 根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程

### 如何判定对象为垃圾对象

1. 引用计数法

    * 在对象中添加一个引用计数器, 当有地方引用这个对象的时候, 引用计数器的值+1, 当引用失效的时候, 引用计数器的值-1

    * -verbose:gc(简单打印日志信息)

    * -XX:+PrintGCDetails(详细打印日志信息)

1. 可达性分析法

    * 从GCRoot向下搜索, 如果不在引用链上的对象, 都视为垃圾对象

    * 作为GCRoot对象

        * 虚拟机栈(虚拟机栈中的局部变量表)

        * 方法区的类属性所引用的对象

        * 方法区中常量所引用的对象

        * 本地方法栈中所引用的对象

### 具体回收过程

* 当GC线程启动时，会通过可达性分析法把Eden区和From Space区的存活对象复制到To Space区，然后把Eden Space和From Space区的对象释放掉。当GC轮训扫描To Space区一定次数后，把依然存活的对象复制到老年代，然后释放To Space区的对象。

* 对于用可达性分析法搜索不到的对象，GC并不一定会回收该对象。要完全回收一个对象，至少需要经过两次标记的过程。

    1. 对于一个没有其他引用的对象，筛选该对象是否有必要执行finalize()方法，如果没有执行必要，则意味可直接回收。（筛选依据：是否复写或执行过finalize()方法；因为finalize方法只能被执行一次）。

    1. 如果被筛选判定位有必要执行，则会放入FQueue队列，并自动创建一个低优先级的finalize线程来执行释放操作。如果在一个对象释放前被其他对象引用，则该对象会被移除FQueue队列。

### 回收策略

1. 标记-清除算法

    * 效率比较低, 又要标记, 又要清除

    * 空间问题, 会导致清除的地方内存空间不连续, 如果申请大内存, 查找会浪费时间
        
1. 复制算法(针对新生代)

    * 堆(垃圾回收主要关注的地方)

        * 新生代

            * Eden(伊甸园), 新创建的对象都会放到该区域(80%)

            * Survivor(存活区, 有2块该区域)(10%)(10%)

        * 老年代

            * Tenured Gen

    * 方法区

    * 虚拟机栈, 本地方法栈, 程序计数器

    * 会将内存分为两个区域, 将第一个区域未被标记的内存空间, 复制到另一半区域中并且重新排序, 下一次创建对象再第二块内存区域中创建, 再次清除后, 将第二个区域未被标记的内存空间, 复制到第一块内存区域中, 该算法减少了不连续的空间, 但可使用的空间减少了, 这两块区域就是两块Survivor, 如果内存不够了, 有内存担保, 会将内存放到老年代中
        
1. 标记-整理-清除算法(针对老年代, 回收率较低)

    * 将有用的放一端, 没用的放一端, 直接将没用的清除
         
1. 分代收集算法

    * 针对不同内存, 采用不同算法

### 常见垃圾收集器

1. Serial(针对新生代, 采用复制算法)

    * 最基本, 发展最悠久

    * 单线程垃圾收集器, 会导致其他所有线程停顿一下, 导致用户体验不好

    * 桌面应用

1. Parnew

    * 跟Serial是相同的, 只不过是多线程的

1. Parallel Scavenge收集器, 提高了用户体验, 相比Parnew多了吞吐量

    * 复制算法(新生代收集器)

    * 多线程收集器

    * 达到可控制的吞吐量

        * 吞吐量: CPU用于运行用户代码的时间与CPU消耗的总时间的比值

        * 吞吐量 = (执行用户代码时间) / (执行用户代码时间 + 垃圾回收所占用的时间)

    * -XX:MaxGCPauseMillis垃圾收集器停顿最大时间, 单位是毫秒 1

        这个值设置的小了, 机会增加频率, 所以要设置合理的值

    * -XX:GCTimeRatio 0 < 吞吐量大小 < 100


1. Cms, Concurrent Mark Sweep(针对老年代)

    * 工作过程

        * 初始标记(GCRoot直接关联的对象)

        * 并发标记

        * 重新标记(对并发标记进行修正)

        * 并发清理

    * 优点

        * 并发收集

        * 低停顿

    * 缺点

        * 占用大量的CPU资源

        * 无法处理浮动垃圾

        * 出现Concurrent Mode Failure

        * 空间碎片

1. G1(标记, 整理, 清除)

    * 优势

        * 并行与并发

        * 分代收集

        * 空间整合

        * 可预测的停顿

    * 步骤

        * 初始标记

        * 并发标记

        * 最终标记

        * 筛选回收(维护了一张表)

### Major GC和Full GC

* Minor GC触发条件：当Eden区满时，触发Minor GC。

* Full GC触发条件：

    * 调用System.gc时，系统建议执行Full GC，但是不必然执行

    * 老年代空间不足

    * 方法区空间不足

    * 通过Minor GC后进入老年代的平均大小大于老年代的可用内存

    * 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

## 内存分配

### 内存分配策略

* 优先分配到Eden区域

    * 如果放不下了, 会将内存放到Survivor中, Survivor中也放不下, 会放到老年代中

    * -Xmn10M, 指定新生代内存

    * -XX:SurvivorRatio=8 指定Eden内存大小

* 大对象直接分配到老年代(垃圾回收次数低)

    * -XX:PretenureSizeThreshold=10M 指定多大的内存是大内存

* 长期存活的对象分配到老年代

    * -XX:MaxTenuringThreshold 15

    * Age 1 + 1 + 1 每次GC之后对象的年龄+1

* 空间分配担保

    * -XX:+HandlePromotionFailure 是否开启空间分配担保

* 动态对象年龄

* 逃逸分析与栈上分配

    * 逃逸分析: 分析对象的作用域, 如果没有方法外部引用方法内部的对象, 就认为这个对象没有发生逃逸, 就可以把这个对象放到栈内存中

    * 栈上分配: 根据方法的执行进行分配与释放, 不需要垃圾回收, 性能高


## 虚拟机工具

### jps

* jps(java process status)

* 本地虚拟机唯一id lvmid local virtual machine id

* jps -l 可以查看主类

* jps -m 进程所接受的输入参数

* jps -v 进程锁接受的vm参数

### jstat

* 监控虚拟机运行信息

* 类装载, 内存, 垃圾收集, jit编译的信息

### jinfo

* 实时查看和调整虚拟机参数

### jmap

* jmap -dump:format=b,file=/asf/a.bin pid

### jhat(jvm heap analysis tool)

### jstack

* 生成线程快照

    jstack -l pid

## 可视化虚拟机工具

### jConsole

* 内存监控

* 线程监控

* 死锁监控

### VisualVM

* 首页: https://visualvm.github.io/index.html

* 插件地址: https://visualvm.github.io/pluginscenters.html


## 性能调优

* 知识 + 工具 + 数据 + 经验

* 案例1

    频繁发生Full GC, 堆内存设置的过大, 而且大内存对象非常多, 所以会触发Full GC, 导致每次GC时间过长, 出现卡顿, 通过部署多个web容器, 减少每个web容器的堆内存来解决这个问题

* 案例2

    不定期内存溢出, 把内存加大也无济于事. 导出内存快照信息, 没有任何信息, 内存监控正常. 因为使用了NIO的堆外内存, 所以监控不到内存信息

* 案例3

    连接过度, 中间增加MQ


## Class文件

### Class文件简介和发展历史

* Eclipse编译Java代码, 是使用javac吗?

### Class文件结构

* Class文件是一组以8位字节为基础单位的二进制流, 各个数据项目严格按照顺序紧凑的排列在Class文件之中, 中间没有添加任何分隔符, 整个Class文件中存储的内容几乎全部是程序运行的必要数据, 没有空隙存在

* 当遇到8位自己以上的空间的数据项时, 则会按照高位在前的方式分割成若干个8位字节进行存储

* Class文件有两种数据类型, 分别是无符号数和表

1. Class文件格式

    |类型|名称|数量|
    |-----|-----|-------|
    |u4|magic|1|
    |u2|minor_version|1|
    |u2|major_version|1|
    |u2|`constant_pool_count`|1|
    |cp_info|constant_pool| `constant_pool_count` - 1 |
    |u2|access_flags|1|
    |u2|this_class|1|
    |u2|super_class|1|
    |u2|interfaces_count|1|
    |u2|interfaces|interfaces_count|
    |u2|fields_count|1|
    |field_info|fields|fields_count|
    |u2|methods_count|1|
    |method_info|methods|methods_count|
    |u2|attribute_count|1|
    |attribute_info|attributes|attributes_count|

1. 魔数

    * CAFE BABE就是标识一个文件是class文件

1. Class文件版本

    * JDK1.8 = 52
    * JDK1.7 = 51
    * JDK1.6 = 50
    * JDK1.5 = 49
    * JDK1.4 = 48
    * JDK1.3 = 47
    * JDK1.2 = 46
    * JDK1.1 = 45

1. 常量池

1. 访问标志

1. 类索引, 父类索引, 接口索引集合

1. 字段表集合

1. 方法表集合

1. 属性表集合

## 字节码指令

* Java虚拟机的指令由一个字节长度的, 代表着某种特定操作含义的数字, 称之为操作码, 以及跟随其后的零至多个代表此操作所需参数的操作数而构成

* 操作码的长度为1个字节, 因此最大只有256条

* 基于栈的指令集架构

* javap -verbose HelloWorld.class

### 加载和存储指令

* 加载和存储指令用于将数据在栈桢中的局部变量表和操作数栈之间来回传输

* 将局部变量表加载到操作数栈: iload lload fload dload aload

* 将一个数值从操作数栈存储到局部变量表: istore lfda

* 将一个常量加载到操作数栈: bipush sipush ldc ldc_w ldc2_w aconst_null iconst_m1 iconst

* 扩充局部变量表的访问索引指令: wide

### 运算指令

* 运算或算数指令用于对两个操作数栈上的值进行某种特定的运算, 并把运算结果存储到操作数栈顶

* 加法指令: add

* 减法指令: sub

* 乘法指令: mul

* 除法指令: div

* 取余指令: rem

* 取反指令: neg

### 类型转换指令

* 类型转换指令可以将两种不同的数值类型进行相互转换, 这些转换操作一般用于实现用户代码中的显示类型转换操作以及用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题

* 宽化类型处理和窄化类型处理

* i2b i2c i2s l2i...

### 对象创建于访问指令

* 创建对象实例的指令: new

* 创建数组的指令: newarray anewarray multianewarray

* 访问类字段: getfield putfield getstatic putstatic

* 把数组元素加载到操作数栈的指令: baload c s l l f d a

* 将操作数栈的值存储到数组元素: astore

* 取数组长度的指令: arraylength

* 检查实例类型的指令: instanceof checkcast

### 操作数栈管理指令

* 操作数栈指令用于直接操作操作数栈

* 将操作数栈的一个或两个元素出栈: pop pop2

* 复制栈顶一个或两个数值并将复制或双份复制值重新压入栈顶: dup dup2 dup_x1 dup_x2

* 将栈顶的两个数值替换: swap

### 控制转移指令

* 控制转移指令可以让Java虚拟机有条件或无条件的从指定的位置指令而不是控制转移指令的下一条指令继续执行程序, 可以认为控制转移指令就是在修改pc寄存器的值

* 条件分支: ifeq iflt ifle ifne ifgt ifnull ifcmple...

* 符合条件分支: tableswitch lookupswitch

* 无条件分支: goto goto_w jst jsr_w ret

### 方法调用指令

* invokevirtual指令用于调用对象的实例方法, 根据对象的是实际类型进行分派(虚方法分派), 这也是Java语言中最常见的方法分派方式

* invokeinterface指令用于调用接口方法, 它会在运行时搜索一个实现了这个接口方法的对象, 找出合适的方法进行调用

* invokespecial指令用于调用一些需要特殊处理的实例方法, 包括实例初始化, 私有方法和父类方法

* invokestatic指令用于调用类方法(static方法)

### 方法返回指令

* 方法的调用指令与类型无关, 而方法返回指令则是根据返回值的类型区分的, 包括有ireturn(当返回值是boolean, byte, char, short和int类型时使用), lreturn, freturn, dreturn和areturn, 另外还有一条return指令供声明为void的方法, 实例初始化方法, 类和接口的类初始化方法使用

### 异常处理指令

* 在程序中显示抛出异常的操作会由athrow指令实现, 除了这种情况, 还有别的异常会在其他java虚拟机指令检测到异常状况时由虚拟机自动抛出

### 同步指令


## 类加载

* 虚拟机把描述类的数据从Class文件加载到内存, 并对数据进行校验, 解析和初始化, 最终形成可以被虚拟机直接使用的Java类型, 这就是虚拟机的类加载机制

* 懒加载即用到这个Class文件才去加载

* 生命周期

    加载 -> 连接(验证, 准备, 解析) -> 初始化 -> 使用 -> 卸载

    初始化:

    1. 遇到new, getstatic, putstatic, invokestatic这4条字节码指令, 如果类没进行过初始化, 则需要先触发其初始化. 使用 new 创建对象时, 读取或设置一个类的静态字段(被final修饰, 已在编译器把结果放入常量池的静态字段除外), 以及调用一个类的静态方法

    2. 使用反射对类进行反射调用时

    3. 当初始化一个类的时候, 如果发现父类没初始化, 则需要先触发父类的初始化

    4. 当虚拟机启动时候, 需要一个程序入口, 就是包含Main方法的类


    不被初始化:

    1. 子类引用父类的静态变量, 不会初始化子类

    1. 通过数组定义来引用

    1. 调用类的常量

### 类加载

* 通过一个类的全限定名来获取定义此类的二进制流

* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构

* 在内存中生成一个代表这个类的Class对象, 作为这个类的各种数据的访问入口, 这个对象放在方法区中而不是堆内存中

* 加载源: 文件(Class文件, Jar文件), 网络, 计算生成一个二进制流(Proxy), 由其他文件生成(jsp), 数据库

### 验证(安全性考虑)

* 验证是连接的第一步, 这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求, 并且不会危害虚拟机自身的安全

* 文件格式验证

* 元数据验证

* 字节码验证

* 符合引用验证

### 准备

* 准备阶段正式为类变量(static修饰)分配内存并设置变量的初始值, 这些变量的内存都将在方法区中进行分配

* 这里的初始值并非我们指定的值, 而是其默认值, 如果被final修饰, 常量值会被一同指定为指定的值

### 解析

* 解析阶段是虚拟机将常量池中的符号引用替换为直接引用

* 类或者接口的解析

* 字段解析

* 类方法解析

* 接口方法解析

### 初始化是类加载的最后一步

* 初始化是类加载的最后一步

* 初始化是执行<clinit>方法的过程


## 类加载器

* 虚拟机的设计团队把类加载阶段中的"通过一个类的全限定名来获取描述此类的二进制字节流"这个动作放到Java虚拟机外部去实现, 以便让应用程序自己决定如何去获取所需要的类, 实现这个动作的代码模块称之为类加载器

* 只有被同一个类加载器加载的类才可能会相等, 相同的字节码被不同的类加载器加载的类不相等

### 类加载器分类

* 启动类加载器

    * 由C++实现, 是虚拟机的一部分, 用于加载javahome下的lib目录下的类

* 扩展类加载器

    * 加载javahome下/lib/ext目录中的类

* 应用程序类加载器

    * 加载用户类路径上的所指定的类库

* 自定义类加载器

    1. 定义一个类, 继承ClassLoader

    1. 重写loadClass方法

    1. 实例化Class对象

### 双亲委派模型

* 启动类加载器(Bootstrap ClassLoader)

* 扩展类加载器(Extension ClassLoader)

* 应用程序类加载器(Application ClassLoader)

* 自定义类加载器(User ClassLoader)

## 虚拟机字节码执行引擎

### 运行时栈桢结构

* 局部变量表

* 操作数栈

* 动态连接

* 方法返回地址

    * 方法调用时通过一个指向方法的指针指向方法的地址, 方法返回时将回归到调用处, 那个地方是返回地址

* 附加信息

### 方法调用

* 方法调用并不等同于方法的执行, 方法调用阶段的唯一任务就是确定被调用方法的版本

* 解析调用 

* 静态分派调用

* 动态分派调用


## Happens-before

* Happens-before是用来指定两个操作之间的执行顺序, 提供跨线程的内存可见性

* 在Java内存模型中, 如果一个操作执行的结果需要对另一个操作课件, 那么这两个操作之间必然存在Happens-before关系

* Happens-before规则如下:

    * 程序顺序规则

        * 单个线程中的每个操作, 总是前一个操作happens-before于该线程中的任意后续操作

    * 监视器锁规则

        * 对一个锁的解锁, 总是happens-before于随后对这个锁的加锁

    * volatile变量规则

        * 对一个volatile域的写, happens-before于任意后续对这个volatile域的读

    * 传递性

    * Start规则

    * Join规则

## 重排序问题

* 什么是重排序

    * 编译器和处理器为了提高程序的运行性能, 对指令进行重新排序

* 数据依赖性(as-if-serial)

    * 写后读

    * 读后写

    * 写后写

* 指令重排序分类

    * 编译器重排序

    * 处理器重排序

* 为什么要进行指令重排序

* 指令重排序带来的影响

* 竞争与同步

## 锁的内存语义

* 锁的释放与获取所建立的happens-before关系

* 锁的释放和获取的内存语义


    
    
    
    
    
    
    
    
    
    