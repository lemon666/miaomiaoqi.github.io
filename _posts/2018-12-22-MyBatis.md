---
layout: post
title:  "MyBatis学习"
date:   2018-12-22 13:38:51
categories: Framework
tags: MyBatis
author: miaoqi
---

* content
{:toc}

## MyBatis-简介

* MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架
* MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集
* MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO(Plain Old JavaObjects，普通的Java对象)映射成数据库中的记录.

### MyBatis历史

* 原是Apache的一个开源项目iBatis, 2010年6月这 个项目由Apache Software Foundation 迁移到了 Google Code，随着开发团队转投Google Code 旗下， iBatis3.x正式更名为MyBatis ，代码于 2013年11月迁移到Github([MyBatis下载地址][1]])
* iBatis一词来源于“internet”和“abatis”的组合，是 一个基于Java的持久层框架。 iBatis提供的持久 层框架包括SQL Maps和Data Access Objects (DAO) 

### 为什么要使用MyBatis?

* MyBatis是一个半自动化的持久化层框架。 
* JDBC
	* SQL夹在Java代码块里，耦合度高导致硬编码内伤 
	* 维护不易且实际开发需求中sql是有变化，频繁修改的情况多见 
* Hibernate和JPA
	* 长难复杂SQL，对于Hibernate而言处理也不容易 
	* 内部自动生产的SQL，不容易做特殊优化 
	* 基于全映射的全自动框架，大量字段的POJO进行部分映射时比较困难。 导致数据库性能下降
* 对开发人员而言，核心sql还是需要自己优化 
* s**ql和java编码分开，功能边界清晰，一个专注业务、 一个专注数据** 

## MyBatis-HelloWorld

### HelloWorld简单版

- 创建一张测试表

	```
	CREATE TABLE `tbl_employee` (
	  `id` int(11) NOT NULL AUTO_INCREMENT,
	  `last_name` varchar(255) DEFAULT NULL,
	  `gender` char(1) DEFAULT NULL,
	  `email` varchar(255) DEFAULT NULL,
	  `dept_id` int(11) DEFAULT NULL,
	  PRIMARY KEY (`id`)
	) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8
	```

- 创建对应的javaBean

	```
	public class Employee {
	    private Integer id;
	    private String lastName;
	    private String email;
	    private String gender;
	    // 省略getter, setter
	}
	```

- 创建mybatis配置文件，sql映射文件

	* MyBatis 的全局配置文件包含了影响 MyBatis 行为甚深的设置(settings)和属性(properties)信息、如数据库连接池信息等。指导着MyBatis进行工作。我们可以参照官方文件的配置示例。

		```
		<?xml version="1.0" encoding="UTF-8" ?>
		<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
		<configuration>
		    <environments default="development">
		        <environment id="development">
		            <transactionManager type="JDBC"/>
		            <dataSource type="POOLED">
		                <property name="driver" value="com.mysql.jdbc.Driver"/>
		                <property name="url" value="jdbc:mysql://localhost:3306/mybatis"/>
		                <property name="username" value="root"/>
		                <property name="password" value="miaoqi"/>
		            </dataSource>
		        </environment>
		    </environments>
		    <!--
		    将我们写好的sql映射文件一定要注册到全局配置文件(mybatis-config.xml)中
		    -->
		    <mappers>
		        <mapper resource="EmployeeMapper.xml"/>
		    </mappers>
		</configuration>
		```

	* 映射文件的作用就相当于是定义Dao接口的实现类如何工作。这也是我们使用MyBatis时编写的最多的文件。

		```
		<?xml version="1.0" encoding="UTF-8" ?>
		<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
		        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
		<mapper namespace="com.miaoqi.mybatis.dao.EmployeeMapper">
		    <!--
		    namespace: 名称空间; 指定接口全类名
		    id: 唯一标识
		    resultType: 返回值类型
		    #{id}: 从传递过来的参数中取出id值
		    -->
		    <select id="getEmpById" resultType="com.miaoqi.mybatis.bean.Employee">
		        select id, last_name lastName, gender, email
		        from tbl_employee where id = #{id}
		    </select>
		</mapper>
		```

- 测试

	1. 根据全局配置文件，利用SqlSessionFactoryBuilder创建SqlSessionFactory

		```
		String resource = "mybatis-config.xml";
		InputStream inputStream = Resources.getResourceAsStream(resource);
		SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
		```

	1. 使用SqlSessionFactory获取sqlSession对象。一个SqlSession对象代表和数据库的一次会话。

		```
		SqlSession sqlSession = sqlSessionFactory.openSession();
		```

	3. 使用SqlSession根据方法id进行操作

		```java
		SqlSession sqlSession = sqlSessionFactory.openSession();
		try {
			Employee employee = sqlSession.selectOne("com.miaoqi.mybatis.dao.EmployeeMapper.getEmpById", 1);
			System.out.println(employee);
		} finally {
			sqlSession.close();
		}
		```

### HelloWorld接口式编程

* 创建一个Dao接口

	```
	public interface EmployeeMapper {
	    public Employee getEmpById(Integer id);
	}
	```

* 修改Mapper文件

* 测试

	* 使用SqlSession获取映射器进行操作

		```
		try {
			EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);
			Employee emp = mapper.getEmpById(1);
		    System.out.println(mapper.getClass());
		    System.out.println(emp);
		} finally {
			sqlSession.close();
		}
		```

### SqlSession

* SqlSession 的实例不是线程安全的，因此是不能被共享的。
* SqlSession每次使用完成后需要正确关闭，这个关闭操作是必须的
* SqlSession可以直接调用方法的id进行数据库操作，但是我们一般还是推荐使用SqlSession获取到Dao接口的代理类，执行代理对象的方法，可以更安全的进行类型检查操作

## MyBatis-全局配置文件

* MyBatis的配置文件包含了影响MyBatis行为甚深的设置(settings)和属性(properties)信息。文档的顶层结构如下:

* configuration 配置 

	* properties 属性 

		我们编写一个dbconfig.properties

		```
		driver=com.mysql.jdbc.Driver
		url=jdbc:mysql://localhost:3306/mybatis
		username=root
		password=miaoqi
		```

		使用\<properties\>标签引入配置文件

		```
		<properties resource="dbconfig.properties"/>
		```

		如果属性在不只一个地方进行了配置，那么 MyBatis 将按照下面的顺序来加载:

		1. 在 properties 元素体内指定的属性首先被读取。 
		1. 然后根据 properties 元素中的 resource 属性读取类路径下属性文件或根据 url 属性指定的路径读取属性文件，并**覆盖已读取的同名属性**。 

		3. 最后读取作为方法参数传递的属性，**并覆盖已读取的同名属性**。 

	* settings 设置 

		**这是 MyBatis 中极为重要的调整设置，它们会改变MyBatis 的运行时行为。**

		| 设置参数                 | 描述                                                         | 有效值               | 默认值        |
		| ------------------------ | ------------------------------------------------------------ | -------------------- | ------------- |
		| cacheEnabled             | 该配置影响的所有映射器中配置的**缓存**的全局开关             | true\|false          | true          |
		| lazyLoadingEnabled       | 延迟加载的全局开关. 当开启时, 所有关联的对象都会延迟加载. 特定关联关系中可通过设置fetchType属性来覆盖该项的开关 | true\|false          | false         |
		| useColumnLabel           | 使用列表签代替列名. 不同的驱动在这方面会有不同的表现, 具体可参考相关驱动文档或通过测试这两种不同模式来观察所用驱动的结果 | true\|false          | true          |
		| defaultStatementTimeout  | **设置超时时间**, 它决定驱动等待数据库影响的秒数             | Any positive integer | Not Set(null) |
		| mapUnderscoreToCamelCase | 是否开启自动驼峰命名规则(camel case)映射, 即从经典数据库列名A_COLUMN到经典Java属性aColumn的类似映射 | true\|false          | false         |

		```
		<settings>
			<setting name="mapUnderscoreToCamelCase" value="true"/>
		</settings>
		```

	* typeAliases 类型命名 

		类型别名是为 Java 类型设置一个短的名字，可以方便我们引用某个类

		```
		<typeAliases>
		    <!-- typeAlias: 为某一个类型起别名 
		    	type: 要起别名的类型全类名; 默认别名就是类名小写
		    	alias: 指定新的别名
		    -->
		    <!-- <typeAlias type="com.miaoqi.mybatis.bean.Employee" alias="emp"/> -->
		
		    <!-- package: 为某个包下的所有类批量起别名 
		    	name: 指定包命
		    -->
		    <package name="com.miaoqi.mybatis.bean"/>
		    <!-- 批量起别名的情况下, 使用@Alias注解为某个类型指定新的别名 -->
		</typeAliases>
		```

		值得注意的是，MyBatis已经为许多常见的 Java 类型内建了相应的类型别名。它们都是大小写不敏感的，我们在起别名的时候千万不要占用已有的别名。

		| 别名     | 映射的类型 | 别名    | 映射的类型 | 别名       | 映射的类型 |
		| -------- | ---------- | ------- | ---------- | ---------- | ---------- |
		| _byte    | byte       | string  | String     | date       | Date       |
		| _long    | long       | byte    | Byte       | decimal    | BigDecimal |
		| _short   | short      | long    | Long       | bigdecimal | BigDecimal |
		| _int     | int        | short   | Short      | object     | Object     |
		| _integer | int        | int     | Integer    | map        | Map        |
		| _double  | double     | integer | Integer    | hashmap    | HashMap    |
		| _float   | float      | double  | Double     | list       | List       |
		| _boolean | boolean    | float   | Float      | arraylist  | ArrayList  |
		|          |            | boolean | Boolean    | collection | Collection |
		|          |            |         |            | iterator   | Iterator   |

	* typeHandlers 类型处理器 

		无论是 MyBatis 在预处理语句(PreparedStatement)中设置一个参数时，还是从结果集中取出一个值时， **都会用类型处理器将获取的值以合适的方式转换成 Java 类型**

		| 类型处理器            | Java 类型                  | JDBC 类型                             |
		| --------------------- | -------------------------- | ------------------------------------- |
		| BooleanTypeHandler    | java.lang.Boolean, boolean | 数据库兼容的 BOOLEAN                  |
		| ByteTypeHandler       | java.lang.Byte, byte       | 数据库兼容的 NUMERIC 或 BYTE          |
		| ShortTypeHandler      | java.lang.Short, short     | 数据库兼容的 NUMERIC 或 SHORT INTEGER |
		| IntegerTypeHandler    | java.lang.Integer, int     | 数据库兼容的 NUMERIC 或 INTEGER       |
		| LongTypeHandler       | java.lang.Long, long       | 数据库兼容的 NUMERIC 或 LONG INTEGER  |
		| FloatTypeHandler      | java.lang.Float, float     | 数据库兼容的 NUMERIC 或 FLOAT         |
		| DoubleTypeHandler     | java.lang.Double, double   | 数据库兼容的 NUMERIC 或 DOUBLE        |
		| BigDecimalTypeHandler | java.math.BigDecimal       | 数据库兼容的 NUMERIC 或 DECIMAL       |
		| StringTypeHandler     | java.lang.String           | CHAR, VARCHAR                         |

		日期类型的处理

		* 日期和时间的处理，JDK1.8以前一直是个头疼的 问题。我们通常使用JSR310规范领导者Stephen Colebourne创建的Joda-Time来操作。1.8已经实 现全部的JSR310规范了。 

		* 日期时间处理上，我们可以使用MyBatis基于 JSR310(Date and Time API)编写的各种日期 时间类型处理器。 

		* MyBatis3.4以前的版本需要我们手动注册这些处 理器，以后的版本都是自动注册的 

		自定义类型处理器

		* 我们可以重写类型处理器或创建自己的类型处理 器来处理不支持的或非标准的类型。 
			1. 实现org.apache.ibatis.type.TypeHandler接口或者继承org.apache.ibatis.type.BaseTypeHandler 
			1. 指定其映射某个JDBC类型(可选操作)
			1. 在mybatis全局配置文件中注册

	* objectFactory 对象工厂 

	* plugins 插件 

		**插件是MyBatis提供的一个非常强大的机制，我们 可以通过插件来修改MyBatis的一些核心行为。插件通过动态代理机制，可以介入四大对象的任何 一个方法的执行。后面会有专门的章节我们来介 绍mybatis运行原理以及插件** 

		- Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) 
		- ParameterHandler (getParameterObject, setParameters) 
		- ResultSetHandler (handleResultSets, handleOutputParameters) 
		- StatementHandler (prepare, parameterize, batch, update, query) 

	* environments 环境 
		- environment 环境变量 
			- transactionManager 事务管理器 
			- dataSource 数据源 

	* databaseIdProvider 数据库厂商标识 

	* mappers 映射器 

		mapper逐个注册SQL映射文件

		```
		<mappers>
			<mapper resource="EmployeeMapper.xml"/>
			<mapper class="com.miaoqi.dao.PersonMapper">
			<mapper url="/Users/miaoqi/EmployeeMapper.xml">
		</mappers>
		```

		或者使用批量注册, **这种方式要求SQL映射文件名必须和接口名相同并且在同一目录下**

		```
		<mappers>
			<package name="com.miaoqi.mapper" />
		</mappers>
		```


## MyBatis-映射文件

* 映射文件指导着MyBatis如何进行数据库增删改查，有着非常重要的意义;

	cache –命名空间的二级缓存配置

	cache-ref – 其他命名空间缓存配置的引用。

	resultMap – 自定义结果集映射

	parameterMap – 已废弃!老式风格的参数映射

	sql –抽取可重用语句块。

	insert – 映射插入语句

	update – 映射更新语句

	delete – 映射删除语句

	select – 映射查询语句

### insert, update, delete元素

| id               | 命名空间中的唯一标识符                                       |
| ---------------- | ------------------------------------------------------------ |
| parameterType    | 将要传入语句的参数的完全限定类名或别名. 这个属性是可选的, 因为MyBatis可以通过TypeHandler推断出具体传入语句的参数类型, 默认值为unset |
| flushCache       | 将其设置为true, 任何时候只要语句被调用, 都会导致本地缓存和二级缓存都会被清空, 默认值: true(对应插入, 更新和删除语句) |
| timeout          | 这个设置是在抛出异常之前, 程序驱动等待数据库返回请求结果的秒数. 默认为unset(依赖驱动) |
| statementType    | STATEMENT, PREPARED或CALLABLE的一个. 这会让MyBatis分别使用Statement, PreparedStatement或CallableStatement, 默认值: PREPARED |
| useGeneratedKeys | (仅对insert和update有用)这会令MyBatis使用JDBC的getGeneratedKeys的返回值或者通过insert语句的selectKey子元素设置它的键值, 默认值: false |
| keyProperty      | (仅对insert和update有用)唯一标记一个属性, MyBatis会通过getGeneratedKeys的返回值或者通过insert语句的selectKey子元素设置它的键值, 默认值: unset |
| keyColumn        | (仅对insert和update有用)通过生成的键值设置表中的列名, 这个设置仅在某些数据库(像PostgreSQL)是必须的, 当主键列不是表中的第一列的时候需要设置. 如果希望得到多个生成的列, 也可以是逗号分割的属性名称列表 |
| databaseId       | 如果配置了databaseIdProvider, MyBatis会加载所有的不带databaseId或匹配当前databaseId的语句; 如果带或者不带的语句都有, 则不带的会被忽略 |

### 主键生成方式

* 若数据库支持自动生成主键的字段(比如MySQL和 SQL Server)，则可以设置useGeneratedKeys=”true”，然后再把keyProperty 设置到目标属性上。

  ```
  <insert id="addEmp" parameterType="com.miaoqi.mybatis.bean.Employee" useGeneratedKeys="true" keyProperty="id">
  	insert into tbl_employee(last_name, email, gender) values(#{lastName }, #{email }, #{gender })
  </insert>
  ```

* 而对于不支持自增型主键的数据库(例如Oracle)，则可以使用 selectKey 子元素:selectKey 元素将会首先运行，id 会被设置，然后插入语句会被调用

### 参数(Parameters)传递

• 单个参数

​	可以接受基本类型，对象类型，集合类型的值。这种情况 

​	MyBatis可直接使用这个参数，不需要经过任何处理。 

• 多个参数

​	任意多个参数，都会被MyBatis重新包装成一个Map传入。 

​	Map的key是param1，param2，0，1...，值就是参数的值。 

• 命名参数

​	为参数使用@Param起一个名字，MyBatis就会将这些参数封 

​	装进map中，key就是我们自己指定的名字 

• POJO

​	当这些参数属于我们业务POJO时，我们直接传递POJO 

• Map

​	我们也可以封装多个参数为map，直接传递 

### 参数处理

* 参数也可以指定一个特殊的数据类型

	```
	#{property, javaType=int, jdbcType=NUMERIC}
	#{height, javaType=double, jdbcType=NUMERIC, numericScale=2}
	```

	

## MyBatis-动态SQL

## MyBatis-缓存机制

## MyBatis-Spring整合

## MyBatis-逆向工程

## MyBatis-工作原理

## MyBatis-插件开发

## MyBatis-细节问题

### 同一条更新语句执行多次, 返回的int值

* 我们在数据库中执行同一条update语句时, 实际上只有第一次会改变记录的值, 重复执行同一条upate并不会产生其他影响, 多次执行影响的行数为0

* 在MyBatis中, update语句的返回值是int类型时, 可以返回受影响的行数, 在业务中我们可以根据返回值判断是否有更新

* 基于以上两点, 那么当我们用MyBatis多次执行同一条update语句时, 返回值是多少呢?

	经过测试, 使用MyBtis执行同一条update语句多次, 后续的返回值是一样的, 即使数据库中的值并没有发生变化

* 那么上述的原因是为什么呢?

	**默认情况下，mybatis 的 update 操作返回值是记录的 matched 的条数，并不是影响的记录条数。** 

	**严格意义上来将，这并不是 mybatis 的返回值，mybatis 仅仅只是返回的数据库连接驱动（通常是 JDBC ）的返回值，也就是说，如果驱动告知更新 2 条记录受影响，那么我们将得到 mybatis 的返回值就会是 2 和 mybatis 本身是没有关系的。** 

	**如果我们非得要 mybatis 的 update 操作明确的返回受影响的记录条数，有没有什么办法呢？**

	* **通过对 JDBC URL 显式的指定 useAffectedRows 选项，我们将可以得到受影响的记录的条数**

		```
		jdbc:mysql://jdbc.host/{jdbc.db}?useAffectedRows=true
		```

	* **通过更改数据库连接的参数, 就可以返回受影响(affected)的行数, 而不是匹配到(matched)的行数**









[1]: https://github.com/mybatis/mybatis-3/