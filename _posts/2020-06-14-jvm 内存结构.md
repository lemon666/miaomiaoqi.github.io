---
layout: post
title: jvm 内存结构
categories: [Java]
description: 
keywords: 
---

* content
{:toc}


## 什么是 JVM

Java Virtual Machine - Java 程序的运行环境(java 二进制字节码的运行环境)

### 好处

一次编写, 到处运行

自动内存管理, 垃圾回收功能

![http://www.milky.show/images/java/jvm/jvm_1.png](http://www.milky.show/images/java/jvm/jvm_1.png)



## JVM 内存结构

### 程序计数器

![http://www.milky.show/images/java/jvm/jvm_2.png](http://www.milky.show/images/java/jvm/jvm_2.png)

#### 定义

Program Counter Register 程序计数器（寄存器）

*   作用，是记住下一条jvm指令的执行地址, 底层硬件是使用寄存器, 因为读取地址是一个非常频繁的操作

*   特点

    *   是线程私有的, 因为 CPU 可以在多个线程之间切换执行, 所以程序计数器只记录当前线程的指令地址

    *   不会存在内存溢出

#### 作用

![http://www.milky.show/images/java/jvm/jvm_3.png](http://www.milky.show/images/java/jvm/jvm_3.png)

java 源代码翻译成二进制字节码, 解释器解析字节码翻译成机器码, CPU 读取机器码执行指令, 当执行完这一条指令后, 解释器会从程序计数器中读取下一条指令的地址执行



### 虚拟机栈

![http://www.milky.show/images/java/jvm/jvm_4.png](http://www.milky.show/images/java/jvm/jvm_4.png)

Java Virtual Machine Stacks （Java 虚拟机栈）

每个线程运行时所需的内存, 称为虚拟机栈

每个栈由多个栈桢(Frame)组成, 对应着每次方法调用时所占用的内存

每个线程只能有一个活动栈桢, 对应着当前正在执行的那个方法

#### 栈桢

每个方法运行时需要的内存, 一个栈对应多个栈桢, 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

![http://www.milky.show/images/java/jvm/jvm_5.png](http://www.milky.show/images/java/jvm/jvm_5.png)



#### 问题辨析

1.  垃圾回收是否涉及栈内存？

    不涉及

2.  栈内存分配越大越好吗？

    -Xss1024 参数, Linux 默认 1024K, 栈内存不是越大越好, 栈内存是属于线程的, 物理内存是固定的, 栈内存越大, 可用线程越少, 效率反而低, 一般采用系统默认就可以

3.  方法内的局部变量是否线程安全？

    如果方法内**局部变量**没有逃离方法的作用访问，它是线程安全的

    如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全

#### 栈内存溢出

栈帧过多导致栈内存溢出, 例如无限的递归

栈帧过大导致栈内存溢出, 一般不会出现

#### 线程运行诊断

**案例 1: CPU 使用率过高**

*   使用 top 定位哪个进程对 cpu 的占用过高
*   ps H -eo pid,tid,%cpu | grep 进程id （用ps命令进一步定位是哪个线程引起的cpu占用过高）
*   jstack 进程id
    *   可以根据线程id 找到有问题的线程，进一步定位到问题代码的源码行号, 此处需要将第 2 步的线程 id 转为 16 进制

**案例 2: 程序运行很长时间没结果**

*   有可能发生了死锁, 使用 jstack 命令定位

### 本地方法栈

![http://www.milky.show/images/java/jvm/jvm_6.png](http://www.milky.show/images/java/jvm/jvm_6.png)

不是由 java 代码编写的程序, 底层由 c 语言运行的代码, 比如 Object 的 clone() 方法

### 堆

![http://www.milky.show/images/java/jvm/jvm_7.png](http://www.milky.show/images/java/jvm/jvm_7.png)

Heap 堆

*   通过 new 关键字，创建对象都会使用堆内存

特点

*   它是线程共享的，堆中对象都需要考虑线程安全的问题

*   有垃圾回收机制

#### 堆内存诊断

jps 工具: 查看当前系统中有哪些 java 进程

jmap 工具: 查看堆内存占用情况 jmap - heap 进程id

jconsole 工具: 图形界面的，多功能的监测工具，可以连续监测

jvisualvm 工具: 可视化展示虚拟机内容, 可以生成堆内存的快照



### 方法区

![http://www.milky.show/images/java/jvm/jvm_8.png](http://www.milky.show/images/java/jvm/jvm_8.png)

[JVM规范-方法区定义](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html)

#### 组成

方法区是一个规范, 在 1.8 之前是通过堆内存中的永久代实现方法区, 1.8 之后是通过元空间实现方法区

![http://www.milky.show/images/java/jvm/jvm_9.png](http://www.milky.show/images/java/jvm/jvm_9.png)

#### 方法区内存溢出

1.8 以前会导致永久代内存溢出

```java
* 演示永久代内存溢出 java.lang.OutOfMemoryError: PermGen space
* -XX:MaxPermSize=8m
```

1.8 之后会导致元空间内存溢出

```java
* 演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace
* -XX:MaxMetaspaceSize=8m
```



#### 常量池

常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息



#### 运行时常量池

运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址



#### StringTable

StringTable 是运行时常量池的组成部分, 俗称"串池"

javap -v Demo1.class 可以反编译查看字节码文件内容

#### StringTable 特性

常量池中的字符串仅是符号，第一次用到时才变为对象

利用串池的机制，来避免重复创建字符串对象

字符串变量拼接的原理是 StringBuilder （1.8）

字符串常量拼接的原理是编译期优化

字符串常量可以被直接放入到串池中, 但通过变量拼接出来的是不会放到串池中的, 可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池

*   1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串池中的对象返回

*   1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串池， 会把串池中的对象返回



#### StringTable 面试题

```java
String s1 = "a"; // 用到时会放入到串池中
String s2 = "b"; // 串池
String s3 = "ab"; // 串池
String s4 = s1 + s2; // new StringBuilder().toString() 放入到堆中 new String("ab")
String s5 = "a" + "b"; // javac 在编译期间的优化, s5 的结果已经在编译时确定为 ab, 所以 s5 会从串池中查找 "ab", 因为 s3 已经将 "ab" 放入到串池中, 所以 s5 直接引用串池中的 "ab"
String s6 = s4.intern(); // s4.intern() 方法会尝试将 s4 引用的对象放入常量池中, 但此时串池中已经有了 "ab", 所以 s4 依旧指向堆中对象, 会将 s6 指向串池中的 "ab"

// 问
System.out.println(s3 == s4); // s3 在串池中, s4 在堆中, 所以 false
System.out.println(s3 == s5); // s3 和 s5 均引用串池中的 "ab" 所以 true
System.out.println(s3 == s6); // s4.intern() 会尝试将 "ab" 放入常量池中并返回, s3 直接引用常量池, 所以 true

String x2 = new String("c") + new String("d"); // x2 指向堆中 new String("cd")
String x1 = "cd"; // x1 指向串池中 "cd"
x2.intern(); // 尝试将 x2 的对象放入串池中, 但串池中已经有了 "cd", 所以 x2 依旧指向堆中 new String("cd")

// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢
System.out.println(x1 == x2); // false
```



#### StringTable 位置

1.6 跟随方法区在永久代中

1.7 以后放在堆内存中



#### StringTable 垃圾回收

StringTable 虽然是在常量池中, 但依然可以被垃圾回收

```java
/**
 * 演示 StringTable 垃圾回收
 * -Xmx10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc
 * PrintStringTableStatistics: 打印字符串表信息
 * PrintGCDetails: 打印垃圾回收信息
 */
public class Demo1_7 {

    public static void main(String[] args) throws InterruptedException {
        int i = 0;
        try {
            for (int j = 0; j < 100000; j++) { // j=100, j=10000
                String.valueOf(j).intern();
                i++;
            }
        } catch (Throwable e) {
            e.printStackTrace();
        } finally {
            System.out.println(i);
        }

    }
}
```



#### StringTable 调优

StringTable 底层可以理解为 HashTable, 如果桶个数大, 那么哈希冲突就会减少, 提高查询效率, 如果桶个数小, 那么哈希冲突几率变大, 链表过长, 就会影响查询性能

**如果系统中涉及大量的字符串操作, 建议调整 -XX:StringTableSize=桶个数, 减少哈希冲突, 提高 StringTable 的访问效率**

读取外部文件字符串, 会放入到常量池中, 这个过程会先查找常量池是否存在, 通过改变虚拟机参数改变桶个数, 提高 StringTable 效率

```java
/**
 * 演示串池大小对性能的影响
 * -Xms500m -Xmx500m -XX:+PrintStringTableStatistics -XX:StringTableSize=1009
 */
public class Demo1_24 {

    public static void main(String[] args) throws IOException {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream("linux.words"), "utf-8"))) {
            String line = null;
            long start = System.nanoTime();
            while (true) {
                line = reader.readLine();
                if (line == null) {
                    break;
                }
                line.intern();
            }
            System.out.println("cost:" + (System.nanoTime() - start) / 1000000);
        }
    }

}
```



### 直接内存

Direct Memory

*   常见于 NIO 操作时，用于数据缓冲区

*   分配回收成本较高，但读写性能高

*   不受 JVM 内存回收管理
*   可以被 Java 和 CPU 直接访问, 减少了 CPU 缓存向 Java 内存拷贝的过程

#### 分配和回收原理

使用了 Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法

ByteBuffer 的实现类内部，使用了 Cleaner （虚引用）来监测 ByteBuffer 对象，一旦ByteBuffer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调用 freeMemory 来释放直接内存