---
layout: post
title:  "JVM类加载"
date:   2018-05-17 21:12:38
categories: Java
tags: JVM
author: miaoqi
---

* content
{:toc}

## Class文件结构

Class文件是一组以8位字节为基础单位的二进制流, 各个数据项目严格按照顺序紧凑的排列在Class文件之中, 中间没有添加任何分隔符, 整个Class文件中存储的内容几乎全部是程序运行的必要数据, 没有空隙存在

当遇到8位自己以上的空间的数据项时, 则会按照高位在前的方式分割成若干个8位字节进行存储

Class文件有两种数据类型, 分别是无符号数和表

1. Class文件格式

    |类型|名称|数量|
    |-----|-----|-------|
    |u4|magic|1|
    |u2|minor_version|1|
    |u2|major_version|1|
    |u2|`constant_pool_count`|1|
    |cp_info|constant_pool| `constant_pool_count` - 1 |
    |u2|access_flags|1|
    |u2|this_class|1|
    |u2|super_class|1|
    |u2|interfaces_count|1|
    |u2|interfaces|interfaces_count|
    |u2|fields_count|1|
    |field_info|fields|fields_count|
    |u2|methods_count|1|
    |method_info|methods|methods_count|
    |u2|attribute_count|1|
    |attribute_info|attributes|attributes_count|

1. 魔数

    * CAFE BABE就是标识一个文件是class文件

1. Class文件版本

    * JDK1.8 = 52
    * JDK1.7 = 51
    * JDK1.6 = 50
    * JDK1.5 = 49
    * JDK1.4 = 48
    * JDK1.3 = 47
    * JDK1.2 = 46
    * JDK1.1 = 45

1. 常量池

1. 访问标志

1. 类索引, 父类索引, 接口索引集合

1. 字段表集合

1. 方法表集合

1. 属性表集合

## 类加载

* 虚拟机把描述类的数据从Class文件加载到内存, 并对数据进行校验, 解析和初始化, 最终形成可以被虚拟机直接使用的Java类型, 这就是虚拟机的类加载机制

* 懒加载即用到这个Class文件才去加载

* 生命周期

    加载 -> 连接(验证, 准备, 解析) -> 初始化 -> 使用 -> 卸载

    初始化:

    1. 遇到new, getstatic, putstatic, invokestatic这4条字节码指令, 如果类没进行过初始化, 则需要先触发其初始化. 使用 new 创建对象时, 读取或设置一个类的静态字段(被final修饰, 已在编译器把结果放入常量池的静态字段除外), 以及调用一个类的静态方法

    2. 使用反射对类进行反射调用时

    3. 当初始化一个类的时候, 如果发现父类没初始化, 则需要先触发父类的初始化

    4. 当虚拟机启动时候, 需要一个程序入口, 就是包含Main方法的类


    不被初始化:

    1. 子类引用父类的静态变量, 不会初始化子类

    1. 通过数组定义来引用

    1. 调用类的常量

### 加载

* 通过一个类的全限定名来获取定义此类的二进制流

* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构

* 在内存中生成一个代表这个类的Class对象, 作为这个类的各种数据的访问入口, 这个对象放在方法区中而不是堆内存中

* 加载源: 文件(Class文件, Jar文件), 网络, 计算生成一个二进制流(Proxy), 由其他文件生成(jsp), 数据库

### 验证(安全性考虑)

* 验证是连接的第一步, 这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求, 并且不会危害虚拟机自身的安全

* 文件格式验证

* 元数据验证

* 字节码验证

* 符合引用验证

### 准备

* 准备阶段正式为类变量(static修饰)分配内存并设置变量的初始值, 这些变量的内存都将在方法区中进行分配

* 这里的初始值并非我们指定的值, 而是其默认值, 如果被final修饰, 常量值会被一同指定为指定的值

### 解析

* 解析阶段是虚拟机将常量池中的符号引用替换为直接引用

    * 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在Java中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。

    * 直接引用可以是

        * 直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）
        
        * 相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）
        
        * 一个能间接定位到目标的句柄

* 类或者接口的解析

* 字段解析

* 类方法解析

* 接口方法解析

### 初始化是类加载的最后一步

* 初始化是类加载的最后一步

* 初始化是执行<clinit>方法的过程


## 类加载器

* 虚拟机的设计团队把类加载阶段中的"通过一个类的全限定名来获取描述此类的二进制字节流"这个动作放到Java虚拟机外部去实现, 以便让应用程序自己决定如何去获取所需要的类, 实现这个动作的代码模块称之为类加载器

* 只有被同一个类加载器加载的类才可能会相等, 相同的字节码被不同的类加载器加载的类不相等

### 类加载器分类

* 启动类加载器

    * 由C++实现, 是虚拟机的一部分, 用于加载javahome下的lib目录下的类

* 扩展类加载器

    * 加载javahome下/lib/ext目录中的类

* 应用程序类加载器

    * 加载用户类路径上的所指定的类库

* 自定义类加载器

    1. 定义一个类, 继承ClassLoader

    1. 重写loadClass方法

    1. 实例化Class对象

### 双亲委派模型

* 启动类加载器(Bootstrap ClassLoader)

* 扩展类加载器(Extension ClassLoader)

* 应用程序类加载器(Application ClassLoader)

* 自定义类加载器(User ClassLoader)

## 虚拟机字节码执行引擎

### 运行时栈桢结构

* 局部变量表

* 操作数栈

* 动态连接

* 方法返回地址

    * 方法调用时通过一个指向方法的指针指向方法的地址, 方法返回时将回归到调用处, 那个地方是返回地址

* 附加信息

### 方法调用

* 方法调用并不等同于方法的执行, 方法调用阶段的唯一任务就是确定被调用方法的版本

* 解析调用 

* 静态分派调用

* 动态分派调用
    
    