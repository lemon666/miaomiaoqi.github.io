---
layout: post
title:  "JVM类加载"
date:   2018-05-17 21:12:38
categories: Java
tags: JVM
author: miaoqi
---

* content
{:toc}

## Class文件结构

Class文件是一组以8位字节为基础单位的二进制流, 各个数据项目严格按照顺序紧凑的排列在Class文件之中, 中间没有添加任何分隔符, 整个Class文件中存储的内容几乎全部是程序运行的必要数据, 没有空隙存在

当遇到8位自己以上的空间的数据项时, 则会按照高位在前的方式分割成若干个8位字节进行存储

Class文件有两种数据类型, 分别是无符号数和表

1. Class文件格式

    |类型|名称|数量|
    |-----|-----|-------|
    |u4|magic|1|
    |u2|minor_version|1|
    |u2|major_version|1|
    |u2|`constant_pool_count`|1|
    |cp_info|constant_pool| `constant_pool_count` - 1 |
    |u2|access_flags|1|
    |u2|this_class|1|
    |u2|super_class|1|
    |u2|interfaces_count|1|
    |u2|interfaces|interfaces_count|
    |u2|fields_count|1|
    |field_info|fields|fields_count|
    |u2|methods_count|1|
    |method_info|methods|methods_count|
    |u2|attribute_count|1|
    |attribute_info|attributes|attributes_count|

1. 魔数

    * CAFE BABE就是标识一个文件是class文件

1. Class文件版本

    * JDK1.8 = 52
    * JDK1.7 = 51
    * JDK1.6 = 50
    * JDK1.5 = 49
    * JDK1.4 = 48
    * JDK1.3 = 47
    * JDK1.2 = 46
    * JDK1.1 = 45

1. 常量池

1. 访问标志

1. 类索引, 父类索引, 接口索引集合

1. 字段表集合

1. 方法表集合

1. 属性表集合

## 字节码指令

* Java虚拟机的指令由一个字节长度的, 代表着某种特定操作含义的数字, 称之为操作码, 以及跟随其后的零至多个代表此操作所需参数的操作数而构成

* 操作码的长度为1个字节, 因此最大只有256条

* 基于栈的指令集架构

* javap -verbose HelloWorld.class

### 加载和存储指令

* 加载和存储指令用于将数据在栈桢中的局部变量表和操作数栈之间来回传输

* 将局部变量表加载到操作数栈: iload lload fload dload aload

* 将一个数值从操作数栈存储到局部变量表: istore lfda

* 将一个常量加载到操作数栈: bipush sipush ldc ldc_w ldc2_w aconst_null iconst_m1 iconst

* 扩充局部变量表的访问索引指令: wide

### 运算指令

* 运算或算数指令用于对两个操作数栈上的值进行某种特定的运算, 并把运算结果存储到操作数栈顶

* 加法指令: add

* 减法指令: sub

* 乘法指令: mul

* 除法指令: div

* 取余指令: rem

* 取反指令: neg

### 类型转换指令

* 类型转换指令可以将两种不同的数值类型进行相互转换, 这些转换操作一般用于实现用户代码中的显示类型转换操作以及用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题

* 宽化类型处理和窄化类型处理

* i2b i2c i2s l2i...

### 对象创建于访问指令

* 创建对象实例的指令: new

* 创建数组的指令: newarray anewarray multianewarray

* 访问类字段: getfield putfield getstatic putstatic

* 把数组元素加载到操作数栈的指令: baload c s l l f d a

* 将操作数栈的值存储到数组元素: astore

* 取数组长度的指令: arraylength

* 检查实例类型的指令: instanceof checkcast

### 操作数栈管理指令

* 操作数栈指令用于直接操作操作数栈

* 将操作数栈的一个或两个元素出栈: pop pop2

* 复制栈顶一个或两个数值并将复制或双份复制值重新压入栈顶: dup dup2 dup_x1 dup_x2

* 将栈顶的两个数值替换: swap

### 控制转移指令

* 控制转移指令可以让Java虚拟机有条件或无条件的从指定的位置指令而不是控制转移指令的下一条指令继续执行程序, 可以认为控制转移指令就是在修改pc寄存器的值

* 条件分支: ifeq iflt ifle ifne ifgt ifnull ifcmple...

* 符合条件分支: tableswitch lookupswitch

* 无条件分支: goto goto_w jst jsr_w ret

### 方法调用指令

* invokevirtual指令用于调用对象的实例方法, 根据对象的是实际类型进行分派(虚方法分派), 这也是Java语言中最常见的方法分派方式

* invokeinterface指令用于调用接口方法, 它会在运行时搜索一个实现了这个接口方法的对象, 找出合适的方法进行调用

* invokespecial指令用于调用一些需要特殊处理的实例方法, 包括实例初始化, 私有方法和父类方法

* invokestatic指令用于调用类方法(static方法)

### 方法返回指令

* 方法的调用指令与类型无关, 而方法返回指令则是根据返回值的类型区分的, 包括有ireturn(当返回值是boolean, byte, char, short和int类型时使用), lreturn, freturn, dreturn和areturn, 另外还有一条return指令供声明为void的方法, 实例初始化方法, 类和接口的类初始化方法使用

### 异常处理指令

* 在程序中显示抛出异常的操作会由athrow指令实现, 除了这种情况, 还有别的异常会在其他java虚拟机指令检测到异常状况时由虚拟机自动抛出

### 同步指令


## 类加载

* 虚拟机把描述类的数据从Class文件加载到内存, 并对数据进行校验, 解析和初始化, 最终形成可以被虚拟机直接使用的Java类型, 这就是虚拟机的类加载机制

* 懒加载即用到这个Class文件才去加载

* 生命周期

    加载 -> 连接(验证, 准备, 解析) -> 初始化 -> 使用 -> 卸载

    初始化:

    1. 遇到new, getstatic, putstatic, invokestatic这4条字节码指令, 如果类没进行过初始化, 则需要先触发其初始化. 使用 new 创建对象时, 读取或设置一个类的静态字段(被final修饰, 已在编译器把结果放入常量池的静态字段除外), 以及调用一个类的静态方法

    2. 使用反射对类进行反射调用时

    3. 当初始化一个类的时候, 如果发现父类没初始化, 则需要先触发父类的初始化

    4. 当虚拟机启动时候, 需要一个程序入口, 就是包含Main方法的类


    不被初始化:

    1. 子类引用父类的静态变量, 不会初始化子类

    1. 通过数组定义来引用

    1. 调用类的常量

### 加载

* 通过一个类的全限定名来获取定义此类的二进制流

* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构

* 在内存中生成一个代表这个类的Class对象, 作为这个类的各种数据的访问入口, 这个对象放在方法区中而不是堆内存中

* 加载源: 文件(Class文件, Jar文件), 网络, 计算生成一个二进制流(Proxy), 由其他文件生成(jsp), 数据库

### 验证(安全性考虑)

* 验证是连接的第一步, 这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求, 并且不会危害虚拟机自身的安全

* 文件格式验证

* 元数据验证

* 字节码验证

* 符合引用验证

### 准备

* 准备阶段正式为类变量(static修饰)分配内存并设置变量的初始值, 这些变量的内存都将在方法区中进行分配

* 这里的初始值并非我们指定的值, 而是其默认值, 如果被final修饰, 常量值会被一同指定为指定的值

### 解析

* 解析阶段是虚拟机将常量池中的符号引用替换为直接引用

* 类或者接口的解析

* 字段解析

* 类方法解析

* 接口方法解析

### 初始化是类加载的最后一步

* 初始化是类加载的最后一步

* 初始化是执行<clinit>方法的过程


## 类加载器

* 虚拟机的设计团队把类加载阶段中的"通过一个类的全限定名来获取描述此类的二进制字节流"这个动作放到Java虚拟机外部去实现, 以便让应用程序自己决定如何去获取所需要的类, 实现这个动作的代码模块称之为类加载器

* 只有被同一个类加载器加载的类才可能会相等, 相同的字节码被不同的类加载器加载的类不相等

### 类加载器分类

* 启动类加载器

    * 由C++实现, 是虚拟机的一部分, 用于加载javahome下的lib目录下的类

* 扩展类加载器

    * 加载javahome下/lib/ext目录中的类

* 应用程序类加载器

    * 加载用户类路径上的所指定的类库

* 自定义类加载器

    1. 定义一个类, 继承ClassLoader

    1. 重写loadClass方法

    1. 实例化Class对象

### 双亲委派模型

* 启动类加载器(Bootstrap ClassLoader)

* 扩展类加载器(Extension ClassLoader)

* 应用程序类加载器(Application ClassLoader)

* 自定义类加载器(User ClassLoader)

## 虚拟机字节码执行引擎

### 运行时栈桢结构

* 局部变量表

* 操作数栈

* 动态连接

* 方法返回地址

    * 方法调用时通过一个指向方法的指针指向方法的地址, 方法返回时将回归到调用处, 那个地方是返回地址

* 附加信息

### 方法调用

* 方法调用并不等同于方法的执行, 方法调用阶段的唯一任务就是确定被调用方法的版本

* 解析调用 

* 静态分派调用

* 动态分派调用
    
    