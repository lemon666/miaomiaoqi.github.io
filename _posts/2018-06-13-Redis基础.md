---
layout: post
title:  "Redis基础"
date:   2018-06-13 15:12:38
categories: NoSql
tags: Redis
author: miaoqi
---

* content
{:toc}

# 简介

Redis是非关系型数据库, 即NoSql数据库, 存储的数据模型是key-value, 特点是访问速度快

# 为什么使用Redis

**性能:** 我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。

**并发:** 在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。

# 单线程Redis为什么这么快?

纯内存操作

单线程操作，避免了频繁的上下文切换

基本对象使用多种底层数据结构，且灵活变化是redis高性能的另一个原因

**采用了非阻塞I/O多路复用机制**

我们现在要仔细的说一说I/O多路复用机制，因为这个说法实在是太通俗了，通俗到一般人都不懂是什么意思。博主打一个比方：小曲在S城开了一家快递店，负责同城快送服务。小曲因为资金限制，雇佣了一批快递员，然后小曲发现资金不够了，只够买一辆车送快递。

* 经营方式一

    客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。慢慢的小曲就发现了这种经营方式存在下述问题
    
    几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递
    
    随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了
    
    快递员之间的协调很花时间
    
    综合上述缺点，小曲痛定思痛，提出了下面的经营方式
    
* 经营方式二

    小曲只雇佣一个快递员。然后呢，客户送来的快递，小曲按送达地点标注好，然后依次放在一个地方。最后，那个快递员依次的去取快递，一次拿一个，然后开着车去送快递，送好了就回来拿下一个快递。

    对比上述两种经营方式对比，是不是明显觉得第二种，效率更高，更好呢。在上述比喻中:

每个快递员------------------>每个线程

每个快递-------------------->每个socket(I/O流)

快递的送达地点-------------->socket的不同状态

客户送快递请求-------------->来自客户端的请求

小曲的经营方式-------------->服务端运行的代码

一辆车---------------------->CPU的核数

1. 于是我们有如下结论:
   
    * 经营方式一就是传统的并发模型，每个I/O流(快递)都有一个新的线程(快递员)管理。

    * 经营方式二就是I/O多路复用。只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流。

    下面类比到真实的redis线程模型，如图所示

    ![](http://miaomiaoqi.github.io/images/redis/redis的io多路复用.png) 

# 数据结构

## String类型

这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做一些**复杂的计数功能的缓存**。

| **命令** | **描述**                                                     | **用法**                                              |
| -------- | ------------------------------------------------------------ | ----------------------------------------------------- |
| SET      | （1）将字符串值Value关联到Key<br/>（2）Key已关联则覆盖，无视类型<br/>（3）原本Key带有生存时间TTL，那么TTL被清除 | SET key value [EX seconds] [PX milliseconds] [NX\|XX] |
| GET      | （1）返回key关联的字符串值<br/>（2）Key不存在返回nil<br/>（3）Key存储的不是字符串，返回错误，因为GET只用于处理字符串 | GET key                                               |
| MSET     | （1）同时设置一个或多个Key-Value键值对<br/>（2）某个给定Key已经存在，那么MSET新值会覆盖旧值<br/>（3）如果上面的覆盖不是希望的，那么使用MSETNX命令，**所有Key都不存在才会进行覆盖**<br/>（4）**MSET是一个原子性操作**，所有Key都会在同一时间被设置，不会存在有些更新有些没更新的情况 | MSET key value [key value ...]                        |
| MGET     | （1）返回一个或多个给定Key对应的Value<br/>（2）某个Key不存在那么这个Key返回nil | MGET key [key ...]                                    |
| SETEX    | （1）将Value关联到Key<br/>（2）设置Key生存时间为seconds，单位为秒<br/>（3）如果Key对应的Value已经存在，则覆盖旧值<br/>（4）SET也可以设置失效时间，但是不同在于SETNX是一个原子操作，即关联值与设置生存时间同一时间完成 | SETEX key seconds value                               |
| SETNX    | （1）将Key的值设置为Value，当且仅当Key不存在<br/>（2）若给定的Key已经存在，SEXNX不做任何动作 | SETNX key value                                       |
| INCR     | （1）Key中存储的数字值+1，返回增加之后的值<br/>（2）Key不存在，那么Key的值被初始化为0再执行INCR<br/>（3）如果值包含错误类型或者字符串不能被表示为数字，那么返回错误<br/>（4）值限制在64位有符号数字表示之内，即-9223372036854775808~9223372036854775807 | INCR key                                              |
| DECR     | （1）Key中存储的数字值-1<br/>（2）其余同INCR                 | DECR key                                              |
| INCRBY   | （1）将key所存储的值加上增量返回增加之后的值<br/>（2）其余同INCR | INCRBY key increment                                  |
| DECRBY   | （1）将key所存储的值减去减量decrement<br/>（2）其余同INCR    | DECRBY key decrement                                  |
| APPEND   | (1)给指定key的value追加字符串，并返回新字符串的长度          |                                                       |
| GETSET   | （1）设置key的值，并返回key旧的值                            |                                                       |
| STRLEN   | （1）取指定key的value的长度                                  |                                                       |

实际上type=string代表value存储的是一个普通字符串，那么对应的encoding可以是raw或者是int，如果是int则代表实际redis内部是按数值型类存储和表示这个字符串的，当然前提是这个字符串本身可以用数值表示，**比如"20"这样的字符串，当遇到incr、decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int**。如果你试图对name进行incr操作则报错。



## Hash类型, 可以对key进行分类

Hash是一个String类型的field和value之间的映射表，即redis的Hash数据类型的key（hash表名称）对应的value实际的内部存储结构为一个HashMap，因此Hash特别适合存储对象。相对于把一个对象的每个属性存储为String类型，将整个对象存储在Hash类型中会占用更少内存。

当前HashMap的实现有两种方式：当HashMap的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，这时对应的value的redisObject的encoding为zipmap，当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。

用一个对象来存储用户信息，商品信息，订单信息等等。

![http://www.miaomiaoqi.cn/images/redis/hashstructure.png](http://www.miaomiaoqi.cn/images/redis/hashstructure.png)



| **命令** | **描述**                                                     | **用法**                                |
| -------- | ------------------------------------------------------------ | --------------------------------------- |
| HSET     | （1）将哈希表Key中的域field的值设为value<br/>（2）key不存在，一个新的Hash表被创建<br/>（3）field已经存在，旧的值被覆盖 | HSET key field value                    |
| HSETNX   | (1)置key对应的HashMap中的field的value，如果不存在则先创建    |                                         |
| HGET     | （1）返回哈希表key中给定域field的值                          | HGET key field                          |
| HDEL     | （1）删除哈希表key中的一个或多个指定域<br/>（2）不存在的域将被忽略 | HDEL key filed [field ...]              |
| HEXISTS  | （1）查看哈希表key中，给定域field是否存在，存在返回1，不存在返回0 | HEXISTS key field                       |
| HGETALL  | （1）返回哈希表key中，所有的域和值                           | HGETALL key                             |
| HINCRBY  | （1）为哈希表key中的域field加上增量increment<br/>（2）其余同INCR命令 | HINCRYBY key filed increment            |
| HLEN     | （1）返回哈希表key中域的数量                                 | HLEN key                                |
| HMGET    | （1）返回哈希表key中，一个或多个给定域的值<br/>（2）如果给定的域不存在于哈希表，那么返回一个nil值 | HMGET key field [field ...]             |
| HMSET    | （1）同时将多个field-value对设置到哈希表key中<br/>（2）会覆盖哈希表中已存在的域<br/>（3）key不存在，那么一个空哈希表会被创建并执行HMSET操作 | HMSET key field value [field value ...] |
| HKEYS    | （1）返回哈希表key中的所有域                                 | HKEYS key                               |
| HVALS    | （1）返回哈希表key中所有的域和值                             | HVALS key                               |



## List类型, 所有元素是有序的

Redis的List类型其实就是每一个元素都是String类型的双向链表。我们可以从链表的头部和尾部添加或者删除元素。这样的List既可以作为栈，也可以作为队列使用。

如好友列表，粉丝列表，消息队列，最新消息排行等。另外还有一个就是，可以利用lrange命令，做**基于redis的分页功能**，性能极佳，用户体验好。

![http://www.miaomiaoqi.cn/images/redis/liststructure.png](http://www.miaomiaoqi.cn/images/redis/liststructure.png)



| **命令**  | **描述**                                                     | **用法**                              |
| --------- | ------------------------------------------------------------ | ------------------------------------- |
| LPUSH     | （1）将一个或多个值value插入到列表key的表头<br/>（2）如果有多个value值，那么各个value值按从左到右的顺序依次插入表头<br/>（3）key不存在，一个空列表会被创建并执行LPUSH操作<br/>（4）key存在但不是列表类型，返回错误 | LPUSH key value [value ...]           |
| LPUSHX    | （1）将值value插入到列表key的表头，当且晋档key存在且为一个列表<br/>（2）key不存在时，LPUSHX命令什么都不做 | LPUSHX key value                      |
| LPOP      | （1）移除并返回列表key的头元素                               | LPOP key                              |
| LRANGE    | （1）返回列表key中指定区间内的元素，区间以偏移量start和stop指定<br/>（2）start和stop都以0位底<br/>（3）可使用负数下标，-1表示列表最后一个元素，-2表示列表倒数第二个元素，以此类推<br/>（4）start大于列表最大下标，返回空列表<br/>（5）stop大于列表最大下标，stop=列表最大下标 | LRANGE key start stop                 |
| LREM      | （1）根据count的值，移除列表中与value相等的元素<br/>（2）count>0表示从头到尾搜索，移除与value相等的元素，数量为count<br/>（3）count<0表示从从尾到头搜索，移除与value相等的元素，数量为count<br/>（4）count=0表示移除表中所有与value相等的元素 | LREM key count value                  |
| LSET      | （1）将列表key下标为index的元素值设为value<br/>（2）index参数超出范围，或对一个空列表进行LSET时，返回错误 | LSET key index value                  |
| LINDEX    | （1）返回列表key中，下标为index的元素                        | LINDEX key index                      |
| LINSERT   | （1）将值value插入列表key中，位于pivot前面或者后面<br/>（2）pivot不存在于列表key时，不执行任何操作<br/>（3）key不存在，不执行任何操作 | LINSERT key BEFORE\|AFTER pivot value |
| LLEN      | （1）返回列表key的长度<br/>（2）key不存在，返回0             | LLEN key                              |
| LTRIM     | （1）对一个列表进行修剪，让列表只返回指定区间内的元素，不存在指定区间内的都将被移除 | LTRIM key start stop                  |
| RPOP      | （1）移除并返回列表key的尾元素                               | RPOP key                              |
| RPOPLPUSH | 在一个原子时间内，执行两个动作：<br/>（1）将列表source中最后一个元素弹出并返回给客户端<br/>（2）将source弹出的元素插入到列表desination，作为destination列表的头元素 | RPOPLPUSH source destination          |
| RPUSH     | （1）将一个或多个值value插入到列表key的表尾                  | RPUSH key value [value ...]           |
| RPUSHX    | （1）将value插入到列表key的表尾，当且仅当key存在并且是一个列表<br/>（2）key不存在，RPUSHX什么都不做 | RPUSHX key value                      |





## Set类型, 元素是无序的, 元素不能重复. 并集, 交集, 差集

因为set堆放的是一堆不重复值的集合。所以可以做**全局去重**的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。
另外，就是利用交集、并集、差集等操作，可以计算**共同喜好，全部的喜好，自己独有的喜好等功能**

Redis 集合（Set类型）是一个无序的String类型数据的集合，类似List的一个列表，与List不同的是Set不能有重复的数据。实际上，Set的内部是用HashMap实现的，Set只用了HashMap的key列来存储对象

**集合有取交集、并集、差集等操作，因此可以求共同好友、共同兴趣、分类标签等**

| **命令**    | **描述**                                                     | **用法**                              |
| ----------- | ------------------------------------------------------------ | ------------------------------------- |
| SADD        | （1）将一个或多个member元素加入到key中，已存在在集合的member将被忽略<br/>（2）假如key不存在，则只创建一个只包含member元素做成员的集合<br/>（3）当key不是集合类型时，将返回一个错误 | SADD key number [member ...]          |
| SCARD       | （1）返回key对应的集合中的元素数量                           | SCARD key                             |
| SDIFF       | （1）返回一个集合的全部成员，该集合是第一个Key对应的集合和后面key对应的集合的差集 | SDIFF key [key ...]                   |
| SDIFFSTORE  | （1）和SDIFF类似，但结果保存到destination集合而不是简单返回结果集<br/>（2） destination如果已存在，则覆盖 | SDIFFSTORE destionation key [key ...] |
| SINTER      | （1）返回一个集合的全部成员，该集合是所有给定集合的交集<br/>（2）不存在的key被视为空集 | SINTER key [key ...]                  |
| SINTERSTORE | （1）和SINTER类似，但结果保存早destination集合而不是简单返回结果集<br/>（2）如果destination已存在，则覆盖<br/>（3）destination可以是key本身 | SINTERSTORE destination key [key ...] |
| SUNION      | （1）返回一个集合的全部成员，该集合是所有给定集合的并集<br/>（2）不存在的key被视为空集 | SUNION key [key ...]                  |
| SUNIONSTORE | （1）类似SUNION，但结果保存到destination集合而不是简单返回结果集<br/>（2）destination已存在，覆盖旧值<br/>（3）destination可以是key本身 | SUNION destination key [key ...]      |
| SISMEMBER   | （1）判断member元素是否key的成员，0表示不是，1表示是         | SISMEMBER key member                  |
| SMEMBERS    | （1）返回集合key中的所有成员<br/>（2）不存在的key被视为空集  | SMEMBERS key                          |
| SMOVE       | （1）原子性地将member元素从source集合移动到destination集合<br/>（2）source集合中不包含member元素，SMOVE命令不执行任何操作，仅返回0<br/>（3）destination中已包含member元素，SMOVE命令只是简单做source集合的member元素移除 | SMOVE source desination member        |
| SPOP        | （1）移除并返回集合中的一个随机元素，如果count不指定那么随机返回一个随机元素<br/>（2）count为正数且小于集合元素数量，那么返回一个count个元素的数组且数组中的**元素各不相同**<br/>（3）count为正数且大于等于集合元素数量，那么返回整个集合<br/>（4）count为负数那么命令返回一个数组，数组中的**元素可能重复多次**，数量为count的绝对值 | SPOP key [count]                      |
| SRANDMEMBER | （1）如果count不指定，那么返回集合中的一个随机元素<br/>（2）count同上 | SRANDMEMBER key [count]               |
| SREM        | （1）移除集合key中的一个或多个member元素，不存在的member将被忽略 | SREM key member [member ...]          |



## SortedSet, 有序的set, 元素不能重复且有序

SortSet顾名思义，是一个排好序的Set，它在Set的基础上增加了一个顺序属性score，这个属性在添加修改元素时可以指定，每次指定后，SortSet会自动重新按新的值排序。

sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score。 

**可以做排行榜应用，取TOP N操作。可以用来做延时任务。最后一个应用就是可以做范围查找。**

| **命令**         | **描述**                                                     | **用法**                                                  |
| ---------------- | ------------------------------------------------------------ | --------------------------------------------------------- |
| ZADD             | （1）将一个或多个member元素及其score值加入有序集key中<br/>（2）如果member已经是有序集的成员，那么更新member对应的score并重新插入member保证member在正确的位置上<br/>（3）score可以是整数值或双精度浮点数 | ZADD key score member [[score member] [score member] ...] |
| ZCARD            | （1）返回有序集key的元素个数                                 | ZCARD key                                                 |
| ZCOUNT           | （1） 返回有序集key中，score值>=min且<=max的成员的数量       | ZCOUNT key min max                                        |
| ZRANGE           | （1）返回有序集key中指定区间内的成员，成员位置按score从小到大排序<br/>（2）具有相同score值的成员按字典序排列<br/>（3）需要成员按score从大到小排列，使用ZREVRANGE命令<br/>（4）下标参数start和stop都以0为底，也可以用负数，-1表示最后一个成员，-2表示倒数第二个成员<br/>（5）可通过WITHSCORES选项让成员和它的score值一并返回 | ZRANGE key start stop [WITHSCORES]                        |
| ZREVRANGE        | (1)返回有序集key中，指定区间内的成员。其中成员的位置按score值递减(从大到小)来排列 |                                                           |
| ZRANGBYSCORE     | (1)返回有序集key中，指定分数范围的元素列表                   |                                                           |
| ZRANK            | （1）返回有序集key中成员member的排名，有序集成员按score值从小到大排列<br/>（2）排名以0为底，即score最小的成员排名为0<br/>（3）ZREVRANK命令可将成员按score值从大到小排名 | ZRANK key number                                          |
| ZREVRANK         | (1)得成员按score值递减(从大到小)排列的排名                   |                                                           |
| ZREM             | （1）移除有序集key中的一个或多个成员，不存在的成员将被忽略<br/>（2）当key存在但不是有序集时，返回错误 | ZREM key member [member ...]                              |
| ZREMRANGEBYRANK  | （1）移除有序集key中指定排名区间内的所有成员                 | ZREMRANGEBYRANK key start stop                            |
| ZREMRANGEBYSCORE | （1）移除有序集key中，所有score值>=min且<=max之间的成员      | ZREMRANGEBYSCORE key min max                              |
| ZINCRBY          | (1)如果key对应的zset中已经存在元素member，则对member的score属性加指定的值 |                                                           |

## Key命令

| **命令**        | **描述**                                                     | **用法**                                                     |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| DEL             | （1）删除给定的一个或多个key<br/>（2）不存在的Key将被忽略    | DEL key [key ...]                                            |
| EXISTS          | （1）检查给定key是否存在                                     | EXISTS key                                                   |
| EXPIRE          | （1）为给定key设置生存时间，key过期时它会被自动删除<br/>（2）对一个已经指定生存时间的Key设置执行EXPIRE，新的值会代替旧的值 | EXPIRE key seconds                                           |
| EXPIREAT        | （1）同EXPIRE，但此命令指定的是UNIX时间戳，单位为秒          | EXPIRE key timestamp                                         |
| KEYS            | （1）查找所有符合给定模式pattern的key，下面举一下例子<br/>（2）KEYS *匹配所有key<br/>（3）KEYS h?llo匹配hello、hallo、hxllo等<br/>（4）KEYS h*llo匹配hllo、heeeeello等<br/>（5）KEYS h[ae]llo匹配hello和hallo<br/>（6）特殊符号想当做查找内容经的使用\ <br />**(7)线上禁用该命令** | KEYS pattern                                                 |
| MIGRATE         | （1）原子性地将key从当前实例传送到目标实例指定的数据库上<br/>（2）原数据库Key删除，新数据库Key增加<br/>（3）阻塞进行迁移的两个实例，直到迁移成功、迁移失败、等待超时三个之一发生 | MIGRATE host port key destination-db timeout [COPY] [REPLACE] |
| MOVE            | （1）将当前数据库的key移动到给定数据库的db中<br/>（2）执行成功的条件为当前数据库有key，给定数据库没有key | MOVE key db                                                  |
| PERSIST         | （1）移除给定key的生存时间，将key变为持久的                  | PERSIST key                                                  |
| RANDOMKEY       | （1）从当前数据库随机返回且不删除一个key，                   | RANDOMKEY                                                    |
| RENAME          | （1）将key改名为newkey<br/>（2）当key和newkey相同或key不存在，报错<br/>（3）newkey已存在，RENAME将覆盖旧值 | RENAME key newkey                                            |
| TTL             | （1）以秒为单位，返回给定的key剩余生存时间                   | TTL key                                                      |
| PTTL            | （1）以毫秒为单位，返回给定的key剩余生存时间                 | PTTL key                                                     |
| TYPE            | （1）返回key锁存储的值的类型                                 | TYPE key                                                     |
| OBJECT ENCODING | (1)显示数据类型的底层数据结构                                | OBJECT ENCODING key                                          |

## 系统相关命令

| **命令**         | **描述**                                                     | **用法**                   |
| ---------------- | ------------------------------------------------------------ | -------------------------- |
| BGREWRITEAOF     | （1）手动触发AOF重写操作，用于减小AOF文件体积                | BGREWRITEAOF               |
| BGSAVE           | （1）后台异步保存当前数据库的数据到磁盘                      | BGSAVE                     |
| CLIENT KILL      | （1）关闭地址为ip:port的客户端<br/>（2）由于Redis为单线程设计，因此当当前命令执行完之后才会关闭客户端 | CLIENT KILL ip:port        |
| CLIENT LIST      | （1）以可读的格式，返回所有连接到服务器的客户端信息和统计数据 | CLIENT LIST                |
| CONFIG GET       | （1）取得运行中的Redis服务器配置参数<br/>（2）支持*          | CONFIG GET parameter       |
| CONFIG RESETSTAT | （1）重置INFO命令中的某些统计数据，例如Keyspace hits、Keyspace misses等 | CONFIG RESETSTAT           |
| CONFIG REWRITE   | （1）对**启动Redis时指定的redis.conf文件进行改写**           | CONFIG REWRITE             |
| CONFIG SET       | （1）动态调整Redis服务器的配置而无需重启<br/>（2）修改后的配置**立即生效** | CONFIG SET parameter value |
| SELECT           | （1）切换到指定数据库，数据库索引index用数字指定，以0作为起始索引值<br/>（2）默认使用0号数据库 | SELECT index               |
| DBSIZE           | （1）返回当前数据库的Key的数量                               | DBSIZE                     |
| DEBUG OBJECT     | （1）这是一个调试命令，不应当被客户端使用<br/>（2）key存在时返回有关信息，key不存在时返回错误 | DEBUG OBJECT key           |
| FLUSHALL         | （1）清空整个Redis服务器的数据<br />(2)线上禁用              | FLUSHALL                   |
| FLUSHDB          | （1）清空当前数据库中的所有数据                              | FLUSHDB                    |
| INFO             | （1）以一种易于解释且易于阅读的格式，返回Redis服务器的各种信息和统计数值（2）通过给定可选参数section，可以让命令只返回某一部分信息 | INFO [section]             |
| LASTSAVE         | （1）返回最近一次Redis成功将数据保存到磁盘上的时间，以UNIX时间戳格式表示 | LASTSAVE                   |
| MONITOR          | （1）实时打印出Redis服务器接收到的命令，调试用               | MONITOR                    |
| SHUTDOWN         | （1）停止所有客户端<br/>（2）如果至少有一个保存点在等待，执行SAVE命令<br/>（3）如果AOF选项被打开，更新AOF文件<br/>（4）关闭Redis服务器 | SHUTDOWN [SAVE\|NOSAVE]    |

# 底层结构

Redis 一共有 5 大种数据类型, 但是在 Redis 中，这几种数据类型底层是由什么数据结构构造的呢？我们可以使用`OBJECT ENCODING key`查看 5 大数据类型的**底层数据结构**

## RedisObject

**Redis内部使用一个redisObject对象来表示所有的key和value**

redisObject主要的信息包括数据类型（type）、编码方式(encoding)、数据指针（ptr）、虚拟内存（vm）等。type代表一个value对象具体是何种数据类型(应用结构)，encoding是不同数据类型在redis内部式(底层结构)。

```
typedef struct redisObject {  
  
    // 类型  
    unsigned type: 4;          

    // 编码方式  
    unsigned encoding: 4;  
  
    // 引用计数  
    int refcount;  
  
    // 指向底层实现数据结构的指针
    void *ptr
    
    // 虚拟内存和其他信息等.....
  
} robj; 
```



![http://www.miaomiaoqi.cn/images/redis/redisobject.png](http://www.miaomiaoqi.cn/images/redis/redisobject.png)

5 大种数据结构对应的 type 值

| 类型常量     | 对象的名称   | type值 |
| ------------ | ------------ | ------ |
| REDIS_STRING | 字符串对象   | string |
| REDIS_LIST   | 列表对象     | list   |
| REDIS_HASH   | 哈希对象     | hash   |
| REDIS_SET    | 集合对象     | set    |
| REDIS_ZSET   | 有序集合对象 | zset   |



## Redis 底层数据结构

**Redis 一共有 8 种底层数据结构对应 redisObject 的 encoding:**

| 编码常量                  | 编码所对应的底层数据结构              |
| :------------------------ | :------------------------------------ |
| REDIS_ENCODING_INT        | long 类型的整数                       |
| REDIS_ENCODING_EMBSTR     | embstr编码的SDS（简单动态字符串对象） |
| REDIS_ENCODING_RAW        | row编码的SDS                          |
| REDIS_ENCODING_LINKEDLIST | 双端链表                              |
| REDIS_ENCODING_HT         | 字典                                  |
| REDIS_ENCODING_SKIPLIST   | 跳跃表和字典                          |
| REDIS_ENCODING_INTSET     | 整数集合                              |
| REDIS_ENCODING_ZIPLIST    | 压缩列表                              |

### 简单动态字符串(embstr, raw)

Redis 是用 C 语言写的，但是对于Redis的字符串，却不是 C 语言中的字符串（即以空字符’\0’结尾的字符数组），它是自己构建了一种名为 简单动态字符串（simple dynamic string,SDS）的抽象类型，并将 SDS 作为 Redis的默认字符串表示。

```
struct sdshdr{

     //记录buf数组中已使用字节的数量
     //等于 SDS 保存字符串的长度
     int len;

     //记录 buf 数组中未使用字节的数量
     int free;

     //字节数组，用于保存字符串
     char buf[];
}
```

![http://www.miaomiaoqi.cn/images/redis/redis_5.png](http://www.miaomiaoqi.cn/images/redis/redis_5.png)

我们看上面对于 SDS 数据类型的定义：

1. len 保存了SDS保存字符串的长度

2. buf[] 数组用来保存字符串的每个元素

3. free j记录了 buf 数组中未使用的字节数量

上面的定义相对于 C 语言对于字符串的定义，多出了 len 属性以及 free 属性。为什么不使用C语言字符串实现，而是使用 SDS呢？这样实现有什么好处？

1. **常数复杂度获取字符串长度**

    由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。通过 strlen key 命令可以获取 key 的字符串长度。

2. **杜绝缓冲区溢出**

    我们知道在 C 语言中使用 strcat  函数来进行两个字符串的拼接，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。而对于 SDS 数据类型，在进行字符修改的时候，会首先根据记录的 len 属性检查内存空间是否满足需求，如果不满足，会进行相应的空间扩展，然后在进行修改操作，所以不会出现缓冲区溢出。

3. **减少修改字符串的内存重新分配次数**

    C语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（先释放再申请），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。

    而对于SDS，由于len属性和free属性的存在，对于修改字符串SDS实现了空间预分配和惰性空间释放两种策略：

    1. 空间预分配：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。

    2. 惰性空间释放：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 free 属性将这些字节的数量记录下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）

4. **二进制安全**

    因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。

5. **兼容部分 C 字符串函数**

    虽然 SDS 是二进制安全的，但是一样遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库<string.h> 中的一部分函数。



| C 字符串                                     | SDS                                          |
| -------------------------------------------- | -------------------------------------------- |
| 获取字符串长度的复杂度为 O(N)                | 获取字符串长度的复杂度为O(1)                 |
| API 是不安全的, 可能会造成缓冲区溢出         | API 是安全的, 不会造成溢出                   |
| 修改字符串 N 次**必然**需要执行 N 次内存分配 | 修改字符串 N 次**最多**需要执行 N 次内存分配 |
| 只能保存文本数据                             | 可以保存文本或者二进制数据                   |
| 可以使用所有<string.h>库中的函数             | 可以使用一部分<string.h>库中的函数           |

一般来说，SDS 除了保存数据库中的字符串值以外，SDS 还可以作为缓冲区（buffer）：包括 AOF 模块中的AOF缓冲区以及客户端状态中的输入缓冲区。后面在介绍Redis的持久化时会进行介绍。



### 双端链表(linkedlist)

链表是一种常用的数据结构，C 语言内部是没有内置这种数据结构的实现，所以Redis自己构建了链表的实现

**链表节点定义**

```
typedef  struct listNode{

       //前置节点
       struct listNode *prev;

       //后置节点
       struct listNode *next;

       //节点的值
       void *value;  

}listNode
```

**通过多个 listNode 结构就可以组成链表，这是一个双端链表，Redis还提供了操作链表的数据结构：**

```
typedef struct list{

     //表头节点
     listNode *head;

     //表尾节点
     listNode *tail;

     //链表所包含的节点数量
     unsigned long len;

     //节点值复制函数
     void (*free) (void *ptr);

     //节点值释放函数
     void (*free) (void *ptr);

     //节点值对比函数
     int (*match) (void *ptr,void *key);

}list;
```

Redis链表特性：

1. 双端：链表具有前置节点和后置节点的引用，获取这两个节点时间复杂度都为O(1)。

2. 无环：表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL,对链表的访问都是以 NULL 结束。　　

3. 带链表长度计数器：通过 len 属性获取链表长度的时间复杂度为 O(1)。

4. 多态：链表节点使用 void* 指针来保存节点值，可以保存各种不同类型的值。



### 字典

字典又称为符号表或者关联数组、或映射（map），是一种用于保存键值对的抽象数据结构。字典中的每一个键 key 都是唯一的，通过 key 可以对值来进行查找或修改。C 语言中没有内置这种数据结构的实现，所以字典依然是 Redis自己构建的。Redis 的字典使用哈希表作为底层实现

**哈希表结构定义:**

```
typedef struct dictht{

     //哈希表数组
     dictEntry **table;

     //哈希表大小
     unsigned long size;

     //哈希表大小掩码，用于计算索引值
     //总是等于 size-1
     unsigned long sizemask;

     //该哈希表已有节点的数量
     unsigned long used;

}dictht
```

**哈希表是由数组 table 组成，table 中每个元素都是指向 dict.h/dictEntry 结构，dictEntry 结构定义如下**

```
typedef struct dictEntry{

     //键
     void *key;

     //值
     union{
          void *val;
          uint64_tu64;
          int64_ts64;
     }v;

     //指向下一个哈希表节点，形成链表
     struct dictEntry *next;

}dictEntry
```

key 用来保存键，val 属性用来保存值，值可以是一个指针，也可以是uint64_t整数，也可以是int64_t整数。

注意这里还有一个指向下一个哈希表节点的指针，我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。这里采用的便是链地址法，通过next这个指针可以将多个哈希值相同的键值对连接在一起，用来解决**哈希冲突**。

![http://www.miaomiaoqi.cn/images/redis/redis_6.png](http://www.miaomiaoqi.cn/images/redis/redis_6.png)

1. **哈希算法：**Redis计算哈希值和索引值方法如下：

    ```
    #1、使用字典设置的哈希函数，计算键 key 的哈希值
    hash = dict->type->hashFunction(key);
    
    #2、使用哈希表的sizemask属性和第一步得到的哈希值，计算索引值
    index = hash & dict->ht[x].sizemask;
    ```

2. **解决哈希冲突：**这个问题上面我们介绍了，方法是链地址法。通过字典里面的 *next 指针指向下一个具有相同索引值的哈希表节点。

3. **扩容和收缩：**当哈希表保存的键值对太多或者太少时，就要通过 rerehash(重新散列）来对哈希表进行相应的扩展或者收缩。具体步骤：

    1. 如果执行扩展操作，会基于原哈希表创建一个大小等于 ht[0].used*2n 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。

    2. 重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。

    3. 所有键值对都迁徙完毕后，释放原哈希表的内存空间。

4. **触发扩容的条件：**

    1. 服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。

    2. 服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。

    3. 负载因子 = 哈希表已保存节点数量 / 哈希表大小。

5. **渐近式 rehash**

    什么叫渐进式 rehash？也就是说扩容和收缩操作不是一次性、集中式完成的，而是分多次、渐进式完成的。如果保存在Redis中的键值对只有几个几十个，那么 rehash 操作可以瞬间完成，但是如果键值对有几百万，几千万甚至几亿，那么要一次性的进行 rehash，势必会造成Redis一段时间内不能进行别的操作。所以Redis采用渐进式 rehash,这样在进行渐进式rehash期间，字典的删除查找更新等操作可能会在两个哈希表上进行，第一个哈希表没有找到，就会去第二个哈希表上进行查找。但是进行 增加操作，一定是在新的哈希表上进行的。



### 跳跃表

跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。具有如下性质：

1. 由很多层结构组成；

2. 每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点；

3. 最底层的链表包含了所有的元素；

4. 如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）；

5. 链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点；

![http://www.miaomiaoqi.cn/images/redis/redis_7.png](http://www.miaomiaoqi.cn/images/redis/redis_7.png)

**Redis中跳跃表节点定义如下：**

```
typedef struct zskiplistNode {

     //层
     struct zskiplistLevel{

           //前进指针
           struct zskiplistNode *forward;

           //跨度
           unsigned int span;

     }level[];

     //后退指针
     struct zskiplistNode *backward;

     //分值
     double score;

     //成员对象
     robj *obj;

} zskiplistNode
```

**多个跳跃表节点构成一个跳跃表：**

```
typedef struct zskiplist{

     //表头节点和表尾节点
     structz skiplistNode *header, *tail;

     //表中节点的数量
     unsigned long length;

     //表中层数最大的节点的层数
     int level;

}zskiplist;
```

![http://www.miaomiaoqi.cn/images/redis/redis_8.png](http://www.miaomiaoqi.cn/images/redis/redis_8.png)

* **搜索：**从最高层的链表节点开始，如果比当前节点要大和比当前层的下一个节点要小，那么则往下找，也就是和当前层的下一层的节点的下一个节点进行比较，以此类推，一直找到最底层的最后一个节点，如果找到则返回，反之则返回空。

* **插入：**首先确定插入的层数，有一种方法是假设抛一枚硬币，如果是正面就累加，直到遇见反面为止，最后记录正面的次数作为插入的层数。当确定插入的层数k后，则需要将新元素插入到从底层到k层。

* **删除：**在各个层中找到包含指定值的节点，然后将节点从链表中删除即可，如果删除以后只剩下头尾两个节点，则删除这一层。



### 整数集合

整数集合（intset）是Redis用于保存整数值的集合抽象数据类型，它可以保存类型为int16_t、int32_t 或者int64_t 的整数值，并且保证集合中不会出现重复元素。

**整数集合定义如下:**

```
typedef struct intset{

     //编码方式
     uint32_t encoding;

     //集合包含的元素数量
     uint32_t length;

     //保存元素的数组
     int8_t contents[];

}intset;
```

整数集合的每个元素都是 contents 数组的一个数据项，它们按照从小到大的顺序排列，并且不包含任何重复项。

length 属性记录了 contents 数组的大小。

需要注意的是虽然 contents 数组声明为 int8_t 类型，但是实际上contents 数组并不保存任何 int8_t 类型的值，其真正类型有 encoding 来决定。

* 升级

    当我们新增的元素类型比原集合元素类型的长度要大时，需要对整数集合进行升级，才能将新元素放入整数集合中。

    1. 根据新元素类型，扩展整数集合底层数组的大小，并为新元素分配空间。

    2. 将底层数组现有的所有元素都转成与新元素相同类型的元素，并将转换后的元素放到正确的位置，放置过程中，维持整个元素顺序都是有序的。
    3. 将新元素添加到整数集合中（保证有序）。

　　升级能极大地节省内存。

* 降级

    整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。



### 压缩列表(ziplist)

压缩列表（ziplist）是Redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。

**压缩列表的原理：压缩列表并不是对数据利用某种算法进行压缩，而是将数据按照一定规则编码在一块连续的内存区域，目的是节省内存。**

![http://www.miaomiaoqi.cn/images/redis/redis_9.png](http://www.miaomiaoqi.cn/images/redis/redis_9.png)

| 属性    | 类型     | 长度   | 用途                                                         |
| ------- | -------- | ------ | ------------------------------------------------------------ |
| zlbytes | uint32_t | 4字节  | 记录整个压缩列表占用的内存字节数: 再对压缩列表进行内存重分配,或者计算zlend的位置时使用 |
| zltail  | uint32_t | 4 字节 | 记录压缩列表表尾节点距离压缩列表的起始地址有多少字节: 通过这个偏移量, 程序无需遍历整个压缩列表就可以确定表尾节点的地址 |
| zllen   | uint16_t | 2 字节 | 记录了压缩列表包含的节点数据: 当这个属性的值小于uint16_max(65535)时, 这个属性的值就是压缩列表包含节点的数量;当这个值等于uint16_max 时, 节点的真实数量需要遍历整个压缩列表才能计算得出 |
| entryX  | 列表节点 | 不定   | 压缩列表包含的各个节点, 节点的长度由节点保存的内容决定       |
| zlend   | uint8_t  | 1 字节 | 特殊值0xFF(十进制 255), 用于标记压缩列表的末端               |

**压缩列表的每个节点构成如下：**

![http://www.miaomiaoqi.cn/images/redis/redis_10.png](http://www.miaomiaoqi.cn/images/redis/redis_10.png)

* previous_entry_ength：记录压缩列表前一个字节的长度。previous_entry_ength的长度可能是1个字节或者是5个字节，如果上一个节点的长度小于254，则该节点只需要一个字节就可以表示前一个节点的长度了，如果前一个节点的长度大于等于254，则previous length的第一个字节为254，后面用四个字节表示当前节点前一个节点的长度。利用此原理即当前节点位置减去上一个节点的长度即得到上一个节点的起始位置，压缩列表可以从尾部向头部遍历。这么做很有效地减少了内存的浪费。

* encoding：节点的encoding保存的是节点的content的内容类型以及长度，encoding类型一共有两种，一种字节数组一种是整数，encoding区域长度为1字节、2字节或者5字节长。

* content：content区域用于保存节点的内容，节点内容类型和长度由encoding决定。

### 总结

大多数情况下，Redis使用简单字符串SDS作为字符串的表示，相对于C语言字符串，SDS具有常数复杂度获取字符串长度，杜绝了缓存区的溢出，减少了修改字符串长度时所需的内存重分配次数，以及二进制安全能存储各种类型的文件，并且还兼容部分C函数。

通过为链表设置不同类型的特定函数，Redis链表可以保存各种不同类型的值，除了用作列表键，还在发布与订阅、慢查询、监视器等方面发挥作用（后面会介绍）。

Redis的字典底层使用哈希表实现，每个字典通常有两个哈希表，一个平时使用，另一个用于rehash时使用，使用链地址法解决哈希冲突。

跳跃表通常是有序集合的底层实现之一，表中的节点按照分值大小进行排序。

整数集合是集合键的底层实现之一，底层由数组构成，升级特性能尽可能的节省内存。

压缩列表是Redis为节省内存而开发的顺序型数据结构，通常作为列表键和哈希键的底层实现之一。

以上介绍的简单字符串、链表、字典、跳跃表、整数集合、压缩列表等数据结构就是Redis底层的一些数据结构，用来实现上一篇博客介绍的Redis五大数据类型，那么每种数据类型是由哪些数据结构实现的呢？下一篇博客进行介绍。

## Redis五大类型与底层结构的关系

### 字符串对象(String)

**字符串对象的编码可以是int、raw或者embstr**
如果一个字符串的内容可以转换为long，那么该字符串就会被转换成为long类型，对象的ptr就会指向该long，并且对象类型也用int类型表示。
普通的字符串有两种，embstr和raw。embstr应该是Redis 3.0新增的数据结构,在2.8中是没有的。**如果字符串对象的长度小于39字节，就用embstr对象。否则用传统的raw对象。**

```
#define REDIS_ENCODING_EMBSTR_SIZE_LIMIT 44  
robj *createStringObject(char *ptr, size_t len) {  
    if (len <= REDIS_ENCODING_EMBSTR_SIZE_LIMIT)  
        return createEmbeddedStringObject(ptr,len);  
    else  
        return createRawStringObject(ptr,len);  
}  
```

embstr的好处有如下几点：

1. embstr的创建只需分配一次内存，而raw为两次（一次为[`sds`](https://github.com/antirez/redis/blob/unstable/src/sds.h)分配对象，另一次为objet分配对象，embstr省去了第一次）。
2. 相对地，释放内存的次数也由两次变为一次。
3. embstr的objet和sds放在一起，更好地利用缓存带来的优势。
4. 但redis不集成对embstr的操作，因此执行命令时，会自动将embstr转换为row编码

raw 和 embstr 的区别可以用下面两幅图所示：

**raw 编码的字符串对象:**

![http://www.miaomiaoqi.cn/images/redis/redis_11.png](http://www.miaomiaoqi.cn/images/redis/redis_11.png)

**embstr 编码的字符串对象:**

![http://www.miaomiaoqi.cn/images/redis/redis_12.png](http://www.miaomiaoqi.cn/images/redis/redis_12.png)



**当字符串对象是由整数构成时，采用整数值作为底层结构；当对象有字符串构成，且值小于32字节，此时用embstr编码的SDS，否则采用row编码的SDS。**



### 列表对象(List)

**列表对象的编码可以是ziplist或者linkedlist**

ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。当列表对象元素不大，每个元素也不大的时候，就采用ziplist存储但当数据量过大时就ziplist就不是那么好用了。因为为了保证他存储内容在内存中的连续性，插入的复杂度是O(N)，即每次插入都会重新进行realloc。如下图所示，对象结构中ptr所指向的就是一个ziplist整个ziplist只需要malloc一次，它们在内存中是一块连续的区域。

![http://www.miaomiaoqi.cn/images/redis/redis_13.png](http://www.miaomiaoqi.cn/images/redis/redis_13.png)

linkedlist是一种双向链表。它的结构比较简单，节点中存放pre和next两个指针，还有节点相关的信息。当每增加一个node的时候，就需要重新malloc一块内存。

![http://www.miaomiaoqi.cn/images/redis/redis_14.png](http://www.miaomiaoqi.cn/images/redis/redis_14.png)



**当列表对象所有值小于64字节，且长度小于512个，采用压缩列表作为底层结构。否则自动采用双端链表的结构**

### 哈希(Map)

**哈希对象的底层实现可以是ziplist或者hashtable。**
ziplist中的哈希对象是按照key1,value1,key2,value2这样的顺序存放来存储的。当对象数目不多且内容不大时，这种方式效率是很高的。

hashtable的是由dict这个结构来实现的, dict是一个字典，其中的指针dicht ht[2] 指向了两个哈希表

```
typedef struct dict {  
    dictType *type;  
    void *privdata;  
    dictht ht[2];  
    long rehashidx; /* rehashing not in progress if rehashidx == -1 */  
    int iterators; /* number of iterators currently running */  
} dict;  
typedef struct dictht {  
    dictEntry **table;  
    unsigned long size;  
    unsigned long sizemask;  
    unsigned long used;  
} dictht;  
```

dicht[0] 是用于真正存放数据，dicht[1]一般在哈希表元素过多进行rehash的时候用于中转数据。
dictht中的table用语真正存放元素了，每个key/value对用一个dictEntry表示，放在dictEntry数组中。

![http://www.miaomiaoqi.cn/images/redis/redis_15.png](http://www.miaomiaoqi.cn/images/redis/redis_15.png)

**当哈希对象每个值小于64字节，且大小小于512个时，采用压缩列表作为底层结构。否则自动采用字典的结构**

### 集合对象(Set)

集合对象的编码可以是intset或者hashtable
intset是一个整数集合，里面存的为某种同一类型的整数，支持如下三种长度的整数：

```
#define INTSET_ENC_INT16 (sizeof(int16_t))  
#define INTSET_ENC_INT32 (sizeof(int32_t))  
#define INTSET_ENC_INT64 (sizeof(int64_t))
```

intset是一个有序集合，查找元素的复杂度为O(logN)，但插入时不一定为O(logN)，因为有可能涉及到升级操作。比如当集合里全是int16_t型的整数，这时要插入一个int32_t，那么为了维持集合中数据类型的一致，那么所有的数据都会被转换成int32_t类型，涉及到内存的重新分配，这时插入的复杂度就为O(N)了。
intset不支持降级操作。

**当集合对象每个值时整数，且集合大小小于512个时，采用整数作为底层结构。否则自动采用字典的结构**

### 有序集合对象(ZSet)

有序集合的编码可能两种，一种是ziplist，另一种是skiplist与dict的结合。
ziplist作为集合和作为哈希对象是一样的，member和score顺序存放。按照score从小到大顺序排列
skiplist是一种跳跃表，它实现了有序集合中的快速查找，在大多数情况下它的速度都可以和平衡树差不多。但它的实现比较简单，可以作为平衡树的替代品。它的结构比较特殊。下面分别是跳跃表skiplist和它内部的节点skiplistNode的结构体：

```
/* 
 * 跳跃表 
 */  
typedef struct zskiplist {  
    // 头节点，尾节点  
    struct zskiplistNode *header, *tail;  
    // 节点数量  
    unsigned long length;  
    // 目前表内节点的最大层数  
    int level;  
} zskiplist;  
/* ZSETs use a specialized version of Skiplists */  
/* 
 * 跳跃表节点 
 */  
typedef struct zskiplistNode {  
    // member 对象  
    robj *obj;  
    // 分值  
    double score;  
    // 后退指针  
    struct zskiplistNode *backward;  
    // 层  
    struct zskiplistLevel {  
        // 前进指针  
        struct zskiplistNode *forward;  
        // 这个层跨越的节点数量  
        unsigned int span;  
    } level[];  
} zskiplistNode;  
```

head和tail分别指向头节点和尾节点，然后每个skiplistNode里面的结构又是分层的(即level数组)
用图表示，大概是下面这个样子：

![http://www.miaomiaoqi.cn/images/redis/redis_16.png](http://www.miaomiaoqi.cn/images/redis/redis_16.png)



**当集合的长度小于64字节，且集合大小小于128时，采用压缩列表作为底层结构。否则自动采用跳跃表和字典的结构**

**有序集合是比较特殊的结构，采用跳跃表和字典双重结构：**

**当单独采用跳跃表时，虽然保留跳跃表的优点，但是获取集合的值时，无法像字典那样效率达到O（1）**

**当单独采用字典结构时，虽然获取值时效率较高，但由于字典时无序的，进行有序遍历或者排序时，效率较差。**