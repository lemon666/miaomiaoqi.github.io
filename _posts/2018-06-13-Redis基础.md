---
layout: post
title:  "Redis基础"
date:   2018-06-13 15:12:38
categories: NoSql
tags: Redis
author: miaoqi
---

* content
{:toc}

# 简介

Redis是非关系型数据库, 即NoSql数据库, 存储的数据模型是key-value, 特点是访问速度快

# 为什么使用Redis

**性能:** 我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。

**并发:** 在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。

# 单线程Redis为什么这么快?

纯内存操作

单线程操作，避免了频繁的上下文切换

基本对象使用多种底层数据结构，且灵活变化是redis高性能的另一个原因

**采用了非阻塞I/O多路复用机制**

我们现在要仔细的说一说I/O多路复用机制，因为这个说法实在是太通俗了，通俗到一般人都不懂是什么意思。博主打一个比方：小曲在S城开了一家快递店，负责同城快送服务。小曲因为资金限制，雇佣了一批快递员，然后小曲发现资金不够了，只够买一辆车送快递。

* 经营方式一

    客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。慢慢的小曲就发现了这种经营方式存在下述问题
    
    几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递
    
    随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了
    
    快递员之间的协调很花时间
    
    综合上述缺点，小曲痛定思痛，提出了下面的经营方式
    
* 经营方式二

    小曲只雇佣一个快递员。然后呢，客户送来的快递，小曲按送达地点标注好，然后依次放在一个地方。最后，那个快递员依次的去取快递，一次拿一个，然后开着车去送快递，送好了就回来拿下一个快递。

    对比上述两种经营方式对比，是不是明显觉得第二种，效率更高，更好呢。在上述比喻中:

每个快递员------------------>每个线程

每个快递-------------------->每个socket(I/O流)

快递的送达地点-------------->socket的不同状态

客户送快递请求-------------->来自客户端的请求

小曲的经营方式-------------->服务端运行的代码

一辆车---------------------->CPU的核数

1. 于是我们有如下结论:
   
    * 经营方式一就是传统的并发模型，每个I/O流(快递)都有一个新的线程(快递员)管理。

    * 经营方式二就是I/O多路复用。只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流。

    下面类比到真实的redis线程模型，如图所示

    ![](http://miaomiaoqi.github.io/images/redis/redis的io多路复用.png) 

# 数据结构

## String类型

这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做一些**复杂的计数功能的缓存**。

| **命令** | **描述**                                                     | **用法**                                              |
| -------- | ------------------------------------------------------------ | ----------------------------------------------------- |
| SET      | （1）将字符串值Value关联到Key<br/>（2）Key已关联则覆盖，无视类型<br/>（3）原本Key带有生存时间TTL，那么TTL被清除 | SET key value [EX seconds] [PX milliseconds] [NX\|XX] |
| GET      | （1）返回key关联的字符串值<br/>（2）Key不存在返回nil<br/>（3）Key存储的不是字符串，返回错误，因为GET只用于处理字符串 | GET key                                               |
| MSET     | （1）同时设置一个或多个Key-Value键值对<br/>（2）某个给定Key已经存在，那么MSET新值会覆盖旧值<br/>（3）如果上面的覆盖不是希望的，那么使用MSETNX命令，**所有Key都不存在才会进行覆盖**<br/>（4）**MSET是一个原子性操作**，所有Key都会在同一时间被设置，不会存在有些更新有些没更新的情况 | MSET key value [key value ...]                        |
| MGET     | （1）返回一个或多个给定Key对应的Value<br/>（2）某个Key不存在那么这个Key返回nil | MGET key [key ...]                                    |
| SETEX    | （1）将Value关联到Key<br/>（2）设置Key生存时间为seconds，单位为秒<br/>（3）如果Key对应的Value已经存在，则覆盖旧值<br/>（4）SET也可以设置失效时间，但是不同在于SETNX是一个原子操作，即关联值与设置生存时间同一时间完成 | SETEX key seconds value                               |
| SETNX    | （1）将Key的值设置为Value，当且仅当Key不存在<br/>（2）若给定的Key已经存在，SEXNX不做任何动作 | SETNX key value                                       |
| INCR     | （1）Key中存储的数字值+1，返回增加之后的值<br/>（2）Key不存在，那么Key的值被初始化为0再执行INCR<br/>（3）如果值包含错误类型或者字符串不能被表示为数字，那么返回错误<br/>（4）值限制在64位有符号数字表示之内，即-9223372036854775808~9223372036854775807 | INCR key                                              |
| DECR     | （1）Key中存储的数字值-1<br/>（2）其余同INCR                 | DECR key                                              |
| INCRBY   | （1）将key所存储的值加上增量返回增加之后的值<br/>（2）其余同INCR | INCRBY key increment                                  |
| DECRBY   | （1）将key所存储的值减去减量decrement<br/>（2）其余同INCR    | DECRBY key decrement                                  |
| APPEND   | (1)给指定key的value追加字符串，并返回新字符串的长度          |                                                       |
| GETSET   | （1）设置key的值，并返回key旧的值                            |                                                       |
| STRLEN   | （1）取指定key的value的长度                                  |                                                       |

实际上type=string代表value存储的是一个普通字符串，那么对应的encoding可以是raw或者是int，如果是int则代表实际redis内部是按数值型类存储和表示这个字符串的，当然前提是这个字符串本身可以用数值表示，**比如"20"这样的字符串，当遇到incr、decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int**。如果你试图对name进行incr操作则报错。



## Hash类型, 可以对key进行分类

Hash是一个String类型的field和value之间的映射表，即redis的Hash数据类型的key（hash表名称）对应的value实际的内部存储结构为一个HashMap，因此Hash特别适合存储对象。相对于把一个对象的每个属性存储为String类型，将整个对象存储在Hash类型中会占用更少内存。

当前HashMap的实现有两种方式：当HashMap的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，这时对应的value的redisObject的encoding为zipmap，当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。

用一个对象来存储用户信息，商品信息，订单信息等等。

![http://www.miaomiaoqi.cn/images/redis/hashstructure.png](http://www.miaomiaoqi.cn/images/redis/hashstructure.png)



| **命令** | **描述**                                                     | **用法**                                |
| -------- | ------------------------------------------------------------ | --------------------------------------- |
| HSET     | （1）将哈希表Key中的域field的值设为value<br/>（2）key不存在，一个新的Hash表被创建<br/>（3）field已经存在，旧的值被覆盖 | HSET key field value                    |
| HSETNX   | (1)置key对应的HashMap中的field的value，如果不存在则先创建    |                                         |
| HGET     | （1）返回哈希表key中给定域field的值                          | HGET key field                          |
| HDEL     | （1）删除哈希表key中的一个或多个指定域<br/>（2）不存在的域将被忽略 | HDEL key filed [field ...]              |
| HEXISTS  | （1）查看哈希表key中，给定域field是否存在，存在返回1，不存在返回0 | HEXISTS key field                       |
| HGETALL  | （1）返回哈希表key中，所有的域和值                           | HGETALL key                             |
| HINCRBY  | （1）为哈希表key中的域field加上增量increment<br/>（2）其余同INCR命令 | HINCRYBY key filed increment            |
| HLEN     | （1）返回哈希表key中域的数量                                 | HLEN key                                |
| HMGET    | （1）返回哈希表key中，一个或多个给定域的值<br/>（2）如果给定的域不存在于哈希表，那么返回一个nil值 | HMGET key field [field ...]             |
| HMSET    | （1）同时将多个field-value对设置到哈希表key中<br/>（2）会覆盖哈希表中已存在的域<br/>（3）key不存在，那么一个空哈希表会被创建并执行HMSET操作 | HMSET key field value [field value ...] |
| HKEYS    | （1）返回哈希表key中的所有域                                 | HKEYS key                               |
| HVALS    | （1）返回哈希表key中所有的域和值                             | HVALS key                               |



## List类型, 所有元素是有序的

Redis的List类型其实就是每一个元素都是String类型的双向链表。我们可以从链表的头部和尾部添加或者删除元素。这样的List既可以作为栈，也可以作为队列使用。

如好友列表，粉丝列表，消息队列，最新消息排行等。另外还有一个就是，可以利用lrange命令，做**基于redis的分页功能**，性能极佳，用户体验好。

![http://www.miaomiaoqi.cn/images/redis/liststructure.png](http://www.miaomiaoqi.cn/images/redis/liststructure.png)



| **命令**  | **描述**                                                     | **用法**                              |
| --------- | ------------------------------------------------------------ | ------------------------------------- |
| LPUSH     | （1）将一个或多个值value插入到列表key的表头<br/>（2）如果有多个value值，那么各个value值按从左到右的顺序依次插入表头<br/>（3）key不存在，一个空列表会被创建并执行LPUSH操作<br/>（4）key存在但不是列表类型，返回错误 | LPUSH key value [value ...]           |
| LPUSHX    | （1）将值value插入到列表key的表头，当且晋档key存在且为一个列表<br/>（2）key不存在时，LPUSHX命令什么都不做 | LPUSHX key value                      |
| LPOP      | （1）移除并返回列表key的头元素                               | LPOP key                              |
| LRANGE    | （1）返回列表key中指定区间内的元素，区间以偏移量start和stop指定<br/>（2）start和stop都以0位底<br/>（3）可使用负数下标，-1表示列表最后一个元素，-2表示列表倒数第二个元素，以此类推<br/>（4）start大于列表最大下标，返回空列表<br/>（5）stop大于列表最大下标，stop=列表最大下标 | LRANGE key start stop                 |
| LREM      | （1）根据count的值，移除列表中与value相等的元素<br/>（2）count>0表示从头到尾搜索，移除与value相等的元素，数量为count<br/>（3）count<0表示从从尾到头搜索，移除与value相等的元素，数量为count<br/>（4）count=0表示移除表中所有与value相等的元素 | LREM key count value                  |
| LSET      | （1）将列表key下标为index的元素值设为value<br/>（2）index参数超出范围，或对一个空列表进行LSET时，返回错误 | LSET key index value                  |
| LINDEX    | （1）返回列表key中，下标为index的元素                        | LINDEX key index                      |
| LINSERT   | （1）将值value插入列表key中，位于pivot前面或者后面<br/>（2）pivot不存在于列表key时，不执行任何操作<br/>（3）key不存在，不执行任何操作 | LINSERT key BEFORE\|AFTER pivot value |
| LLEN      | （1）返回列表key的长度<br/>（2）key不存在，返回0             | LLEN key                              |
| LTRIM     | （1）对一个列表进行修剪，让列表只返回指定区间内的元素，不存在指定区间内的都将被移除 | LTRIM key start stop                  |
| RPOP      | （1）移除并返回列表key的尾元素                               | RPOP key                              |
| RPOPLPUSH | 在一个原子时间内，执行两个动作：<br/>（1）将列表source中最后一个元素弹出并返回给客户端<br/>（2）将source弹出的元素插入到列表desination，作为destination列表的头元素 | RPOPLPUSH source destination          |
| RPUSH     | （1）将一个或多个值value插入到列表key的表尾                  | RPUSH key value [value ...]           |
| RPUSHX    | （1）将value插入到列表key的表尾，当且仅当key存在并且是一个列表<br/>（2）key不存在，RPUSHX什么都不做 | RPUSHX key value                      |





## Set类型, 元素是无序的, 元素不能重复. 并集, 交集, 差集

因为set堆放的是一堆不重复值的集合。所以可以做**全局去重**的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。
另外，就是利用交集、并集、差集等操作，可以计算**共同喜好，全部的喜好，自己独有的喜好等功能**

Redis 集合（Set类型）是一个无序的String类型数据的集合，类似List的一个列表，与List不同的是Set不能有重复的数据。实际上，Set的内部是用HashMap实现的，Set只用了HashMap的key列来存储对象

**集合有取交集、并集、差集等操作，因此可以求共同好友、共同兴趣、分类标签等**

| **命令**    | **描述**                                                     | **用法**                              |
| ----------- | ------------------------------------------------------------ | ------------------------------------- |
| SADD        | （1）将一个或多个member元素加入到key中，已存在在集合的member将被忽略<br/>（2）假如key不存在，则只创建一个只包含member元素做成员的集合<br/>（3）当key不是集合类型时，将返回一个错误 | SADD key number [member ...]          |
| SCARD       | （1）返回key对应的集合中的元素数量                           | SCARD key                             |
| SDIFF       | （1）返回一个集合的全部成员，该集合是第一个Key对应的集合和后面key对应的集合的差集 | SDIFF key [key ...]                   |
| SDIFFSTORE  | （1）和SDIFF类似，但结果保存到destination集合而不是简单返回结果集<br/>（2） destination如果已存在，则覆盖 | SDIFFSTORE destionation key [key ...] |
| SINTER      | （1）返回一个集合的全部成员，该集合是所有给定集合的交集<br/>（2）不存在的key被视为空集 | SINTER key [key ...]                  |
| SINTERSTORE | （1）和SINTER类似，但结果保存早destination集合而不是简单返回结果集<br/>（2）如果destination已存在，则覆盖<br/>（3）destination可以是key本身 | SINTERSTORE destination key [key ...] |
| SUNION      | （1）返回一个集合的全部成员，该集合是所有给定集合的并集<br/>（2）不存在的key被视为空集 | SUNION key [key ...]                  |
| SUNIONSTORE | （1）类似SUNION，但结果保存到destination集合而不是简单返回结果集<br/>（2）destination已存在，覆盖旧值<br/>（3）destination可以是key本身 | SUNION destination key [key ...]      |
| SISMEMBER   | （1）判断member元素是否key的成员，0表示不是，1表示是         | SISMEMBER key member                  |
| SMEMBERS    | （1）返回集合key中的所有成员<br/>（2）不存在的key被视为空集  | SMEMBERS key                          |
| SMOVE       | （1）原子性地将member元素从source集合移动到destination集合<br/>（2）source集合中不包含member元素，SMOVE命令不执行任何操作，仅返回0<br/>（3）destination中已包含member元素，SMOVE命令只是简单做source集合的member元素移除 | SMOVE source desination member        |
| SPOP        | （1）移除并返回集合中的一个随机元素，如果count不指定那么随机返回一个随机元素<br/>（2）count为正数且小于集合元素数量，那么返回一个count个元素的数组且数组中的**元素各不相同**<br/>（3）count为正数且大于等于集合元素数量，那么返回整个集合<br/>（4）count为负数那么命令返回一个数组，数组中的**元素可能重复多次**，数量为count的绝对值 | SPOP key [count]                      |
| SRANDMEMBER | （1）如果count不指定，那么返回集合中的一个随机元素<br/>（2）count同上 | SRANDMEMBER key [count]               |
| SREM        | （1）移除集合key中的一个或多个member元素，不存在的member将被忽略 | SREM key member [member ...]          |



## SortedSet, 有序的set, 元素不能重复且有序

SortSet顾名思义，是一个排好序的Set，它在Set的基础上增加了一个顺序属性score，这个属性在添加修改元素时可以指定，每次指定后，SortSet会自动重新按新的值排序。

sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score。 

**可以做排行榜应用，取TOP N操作。可以用来做延时任务。最后一个应用就是可以做范围查找。**

| **命令**         | **描述**                                                     | **用法**                                                  |
| ---------------- | ------------------------------------------------------------ | --------------------------------------------------------- |
| ZADD             | （1）将一个或多个member元素及其score值加入有序集key中<br/>（2）如果member已经是有序集的成员，那么更新member对应的score并重新插入member保证member在正确的位置上<br/>（3）score可以是整数值或双精度浮点数 | ZADD key score member [[score member] [score member] ...] |
| ZCARD            | （1）返回有序集key的元素个数                                 | ZCARD key                                                 |
| ZCOUNT           | （1） 返回有序集key中，score值>=min且<=max的成员的数量       | ZCOUNT key min max                                        |
| ZRANGE           | （1）返回有序集key中指定区间内的成员，成员位置按score从小到大排序<br/>（2）具有相同score值的成员按字典序排列<br/>（3）需要成员按score从大到小排列，使用ZREVRANGE命令<br/>（4）下标参数start和stop都以0为底，也可以用负数，-1表示最后一个成员，-2表示倒数第二个成员<br/>（5）可通过WITHSCORES选项让成员和它的score值一并返回 | ZRANGE key start stop [WITHSCORES]                        |
| ZREVRANGE        | (1)返回有序集key中，指定区间内的成员。其中成员的位置按score值递减(从大到小)来排列 |                                                           |
| ZRANGBYSCORE     | (1)返回有序集key中，指定分数范围的元素列表                   |                                                           |
| ZRANK            | （1）返回有序集key中成员member的排名，有序集成员按score值从小到大排列<br/>（2）排名以0为底，即score最小的成员排名为0<br/>（3）ZREVRANK命令可将成员按score值从大到小排名 | ZRANK key number                                          |
| ZREVRANK         | (1)得成员按score值递减(从大到小)排列的排名                   |                                                           |
| ZREM             | （1）移除有序集key中的一个或多个成员，不存在的成员将被忽略<br/>（2）当key存在但不是有序集时，返回错误 | ZREM key member [member ...]                              |
| ZREMRANGEBYRANK  | （1）移除有序集key中指定排名区间内的所有成员                 | ZREMRANGEBYRANK key start stop                            |
| ZREMRANGEBYSCORE | （1）移除有序集key中，所有score值>=min且<=max之间的成员      | ZREMRANGEBYSCORE key min max                              |
| ZINCRBY          | (1)如果key对应的zset中已经存在元素member，则对member的score属性加指定的值 |                                                           |

## Key命令

| **命令**        | **描述**                                                     | **用法**                                                     |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| DEL             | （1）删除给定的一个或多个key<br/>（2）不存在的Key将被忽略    | DEL key [key ...]                                            |
| EXISTS          | （1）检查给定key是否存在                                     | EXISTS key                                                   |
| EXPIRE          | （1）为给定key设置生存时间，key过期时它会被自动删除<br/>（2）对一个已经指定生存时间的Key设置执行EXPIRE，新的值会代替旧的值 | EXPIRE key seconds                                           |
| EXPIREAT        | （1）同EXPIRE，但此命令指定的是UNIX时间戳，单位为秒          | EXPIRE key timestamp                                         |
| KEYS            | （1）查找所有符合给定模式pattern的key，下面举一下例子<br/>（2）KEYS *匹配所有key<br/>（3）KEYS h?llo匹配hello、hallo、hxllo等<br/>（4）KEYS h*llo匹配hllo、heeeeello等<br/>（5）KEYS h[ae]llo匹配hello和hallo<br/>（6）特殊符号想当做查找内容经的使用\ <br />**(7)线上禁用该命令** | KEYS pattern                                                 |
| MIGRATE         | （1）原子性地将key从当前实例传送到目标实例指定的数据库上<br/>（2）原数据库Key删除，新数据库Key增加<br/>（3）阻塞进行迁移的两个实例，直到迁移成功、迁移失败、等待超时三个之一发生 | MIGRATE host port key destination-db timeout [COPY] [REPLACE] |
| MOVE            | （1）将当前数据库的key移动到给定数据库的db中<br/>（2）执行成功的条件为当前数据库有key，给定数据库没有key | MOVE key db                                                  |
| PERSIST         | （1）移除给定key的生存时间，将key变为持久的                  | PERSIST key                                                  |
| RANDOMKEY       | （1）从当前数据库随机返回且不删除一个key，                   | RANDOMKEY                                                    |
| RENAME          | （1）将key改名为newkey<br/>（2）当key和newkey相同或key不存在，报错<br/>（3）newkey已存在，RENAME将覆盖旧值 | RENAME key newkey                                            |
| TTL             | （1）以秒为单位，返回给定的key剩余生存时间                   | TTL key                                                      |
| PTTL            | （1）以毫秒为单位，返回给定的key剩余生存时间                 | PTTL key                                                     |
| TYPE            | （1）返回key锁存储的值的类型                                 | TYPE key                                                     |
| OBJECT ENCODING | (1)显示数据类型的底层数据结构                                | OBJECT ENCODING key                                          |

## 系统相关命令

| **命令**         | **描述**                                                     | **用法**                   |
| ---------------- | ------------------------------------------------------------ | -------------------------- |
| BGREWRITEAOF     | （1）手动触发AOF重写操作，用于减小AOF文件体积                | BGREWRITEAOF               |
| BGSAVE           | （1）后台异步保存当前数据库的数据到磁盘                      | BGSAVE                     |
| CLIENT KILL      | （1）关闭地址为ip:port的客户端<br/>（2）由于Redis为单线程设计，因此当当前命令执行完之后才会关闭客户端 | CLIENT KILL ip:port        |
| CLIENT LIST      | （1）以可读的格式，返回所有连接到服务器的客户端信息和统计数据 | CLIENT LIST                |
| CONFIG GET       | （1）取得运行中的Redis服务器配置参数<br/>（2）支持*          | CONFIG GET parameter       |
| CONFIG RESETSTAT | （1）重置INFO命令中的某些统计数据，例如Keyspace hits、Keyspace misses等 | CONFIG RESETSTAT           |
| CONFIG REWRITE   | （1）对**启动Redis时指定的redis.conf文件进行改写**           | CONFIG REWRITE             |
| CONFIG SET       | （1）动态调整Redis服务器的配置而无需重启<br/>（2）修改后的配置**立即生效** | CONFIG SET parameter value |
| SELECT           | （1）切换到指定数据库，数据库索引index用数字指定，以0作为起始索引值<br/>（2）默认使用0号数据库 | SELECT index               |
| DBSIZE           | （1）返回当前数据库的Key的数量                               | DBSIZE                     |
| DEBUG OBJECT     | （1）这是一个调试命令，不应当被客户端使用<br/>（2）key存在时返回有关信息，key不存在时返回错误 | DEBUG OBJECT key           |
| FLUSHALL         | （1）清空整个Redis服务器的数据<br />(2)线上禁用              | FLUSHALL                   |
| FLUSHDB          | （1）清空当前数据库中的所有数据                              | FLUSHDB                    |
| INFO             | （1）以一种易于解释且易于阅读的格式，返回Redis服务器的各种信息和统计数值（2）通过给定可选参数section，可以让命令只返回某一部分信息 | INFO [section]             |
| LASTSAVE         | （1）返回最近一次Redis成功将数据保存到磁盘上的时间，以UNIX时间戳格式表示 | LASTSAVE                   |
| MONITOR          | （1）实时打印出Redis服务器接收到的命令，调试用               | MONITOR                    |
| SHUTDOWN         | （1）停止所有客户端<br/>（2）如果至少有一个保存点在等待，执行SAVE命令<br/>（3）如果AOF选项被打开，更新AOF文件<br/>（4）关闭Redis服务器 | SHUTDOWN [SAVE\|NOSAVE]    |

# 底层结构

Redis 一共有 5 大种数据类型, 但是在 Redis 中，这几种数据类型底层是由什么数据结构构造的呢？我们可以使用`OBJECT ENCODING key`查看 5 大数据类型的**底层数据结构**

## RedisObject

**Redis内部使用一个redisObject对象来表示所有的key和value**

redisObject主要的信息包括数据类型（type）、编码方式(encoding)、数据指针（ptr）、虚拟内存（vm）等。type代表一个value对象具体是何种数据类型(应用结构)，encoding是不同数据类型在redis内部式(底层结构)。

```
typedef struct redisObject {  
  
    // 类型  
    unsigned type: 4;          

    // 编码方式  
    unsigned encoding: 4;  
  
    // 引用计数  
    int refcount;  
  
    // 指向底层实现数据结构的指针
    void *ptr
    
    // 虚拟内存和其他信息等.....
  
} robj; 
```



![http://www.miaomiaoqi.cn/images/redis/redisobject.png](http://www.miaomiaoqi.cn/images/redis/redisobject.png)

5 大种数据结构对应的 type 值

| 类型常量     | 对象的名称   | type值 |
| ------------ | ------------ | ------ |
| REDIS_STRING | 字符串对象   | string |
| REDIS_LIST   | 列表对象     | list   |
| REDIS_HASH   | 哈希对象     | hash   |
| REDIS_SET    | 集合对象     | set    |
| REDIS_ZSET   | 有序集合对象 | zset   |



## Redis 底层数据结构

**Redis 一共有 8 种底层数据结构对应 redisObject 的 encoding:**

| 编码常量                  | 编码所对应的底层数据结构              |
| :------------------------ | :------------------------------------ |
| REDIS_ENCODING_INT        | long 类型的整数                       |
| REDIS_ENCODING_EMBSTR     | embstr编码的SDS（简单动态字符串对象） |
| REDIS_ENCODING_RAW        | row编码的SDS                          |
| REDIS_ENCODING_LINKEDLIST | 双端链表                              |
| REDIS_ENCODING_HT         | 字典                                  |
| REDIS_ENCODING_SKIPLIST   | 跳跃表和字典                          |
| REDIS_ENCODING_INTSET     | 整数集合                              |
| REDIS_ENCODING_ZIPLIST    | 压缩列表                              |

### 简单动态字符串(embstr, raw)

Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串）， 而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。

在 Redis 里面， C 字符串只会作为字符串字面量（string literal）， 用在一些无须对字符串值进行修改的地方， 比如打印日志：

```
redisLog(REDIS_WARNING,"Redis is now ready to exit, bye bye...");
```

当 Redis 需要的不仅仅是一个字符串字面量， 而是一个可以被修改的字符串值时， Redis 就会使用 SDS 来表示字符串值： 比如在 Redis 的数据库里面， 包含字符串值的键值对在底层都是由 SDS 实现的。

举个例子， 如果客户端执行命令：

```
redis> SET msg "hello world"
OK
```

那么 Redis 将在数据库中创建了一个新的键值对， 其中：

键值对的键是一个字符串对象， 对象的底层实现是一个保存着字符串 "msg" 的 SDS 。
键值对的值也是一个字符串对象， 对象的底层实现是一个保存着字符串 "hello world" 的 SDS 。
又比如说， 如果客户端执行命令：

```
redis> RPUSH fruits "apple" "banana" "cherry"
(integer) 3
```

那么 Redis 将在数据库中创建一个新的键值对， 其中：

键值对的键是一个字符串对象， 对象的底层实现是一个保存了字符串 "fruits" 的 SDS 。
 键值对的值是一个列表对象， 列表对象包含了三个字符串对象， 这三个字符串对象分别由三个 SDS 实现： 第一个 SDS 保存着字符串 "apple" ， 第二个 SDS 保存着字符串 "banana" ， 第三个 SDS 保存着字符串 "cherry" 。
 除了用来保存数据库中的字符串值之外， SDS 还被用作缓冲区（buffer）： AOF 模块中的 AOF 缓冲区， 以及客户端状态中的输入缓冲区， 都是由 SDS 实现的， 在之后介绍 AOF 持久化和客户端状态的时候， 我们会看到 SDS 在这两个模块中的应用。

**SDS 的定义:**

```c
struct sdshdr{

     //记录buf数组中已使用字节的数量
     //等于 SDS 保存字符串的长度
     int len;

     //记录 buf 数组中未使用字节的数量
     int free;

     //字节数组，用于保存字符串
     char buf[];
}
```

![http://www.miaomiaoqi.cn/images/redis/redis_5.png](http://www.miaomiaoqi.cn/images/redis/redis_5.png)

我们看上面对于 SDS 数据类型的定义：

* free 属性的值为 0, 表示这个 SDS 没有分配任何未使用空间。

* len 属性的值为 5, 表示这个 SDS 保存了一个五字节长的字符串。

* buf 属性是一个 char 类型的数组， 数组的前五个字节分别保存了 'R', 'e', 'd', 'i', 's' 五个字符， 而最后一个字节则保存了空字符 '\0' 。

上面的定义相对于 C 语言对于字符串的定义，多出了 len 属性以及 free 属性。为什么不使用C语言字符串实现，而是使用 SDS呢？这样实现有什么好处？

1. **常数复杂度获取字符串长度**

    由于 len 属性的存在，我们获取 SDS 字符串的长度只需要读取 len 属性，时间复杂度为 O(1)。而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。**通过 strlen key 命令可以获取 key 的字符串长度。**

    设置和更新 SDS 长度的工作是由 SDS 的 API 在执行时自动完成的， 使用 SDS 无须进行任何手动修改长度的工作。 

    通过使用 SDS 而不是 C 字符串， Redis 将获取字符串长度所需的复杂度从 O(N) 降低到了 O(1) ， 这确保了获取字符串长度的工作不会成为 Redis 的性能瓶颈。

    比如说， 因为字符串键在底层使用 SDS 来实现， 所以即使我们对一个非常长的字符串键反复执行 STRLEN 命令， 也不会对系统性能造成任何影响， 因为 STRLEN 命令的复杂度仅为 O(1) 。

2. **杜绝缓冲区溢出**

    除了获取字符串长度的复杂度高之外， C 字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出（buffer overflow）。

    举个例子， <string.h>/strcat 函数可以将 src 字符串中的内容拼接到 dest 字符串的末尾：

    ```c
    char *strcat(char *dest, const char *src);
    ```

    因为 C 字符串不记录自身的长度， 所以 strcat 假定用户在执行这个函数时， 已经为 dest 分配了足够多的内存， 可以容纳 src 字符串中的所有内容， 而一旦这个假定不成立时， 就会产生缓冲区溢出。

    举个例子， 假设程序里有两个在内存中紧邻着的 C 字符串 s1 和 s2 ， 其中 s1 保存了字符串 "Redis" ， 而 s2 则保存了字符串 "MongoDB"

    ![http://www.miaomiaoqi.cn/images/redis/redis_19.png](http://www.miaomiaoqi.cn/images/redis/redis_19.png)

    如果一个程序员决定通过执行：

    ```C
    strcat(s1, " Cluster");
    ```

    将 s1 的内容修改为 "Redis Cluster" ， 但粗心的他却忘了在执行 strcat 之前为 s1 分配足够的空间， 那么在 strcat 函数执行之后， s1 的数据将溢出到 s2 所在的空间中， 导致 s2 保存的内容被意外地修改， 如图 2-8 所示。

    ![http://www.miaomiaoqi.cn/images/redis/redis_20.png](http://www.miaomiaoqi.cn/images/redis/redis_20.png)

    与 C 字符串不同， SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性： 当 SDS API 需要对 SDS 进行修改时， API 会先检查 SDS 的空间是否满足修改所需的要求， 如果不满足的话， API 会自动将 SDS 的空间扩展至执行修改所需的大小， 然后才执行实际的修改操作， 所以使用 SDS 既不需要手动修改 SDS 的空间大小， 也不会出现前面所说的缓冲区溢出问题。

    举个例子， SDS 的 API 里面也有一个用于执行拼接操作的 sdscat 函数， 它可以将一个 C 字符串拼接到给定 SDS 所保存的字符串的后面， 但是在执行拼接操作之前， sdscat 会先检查给定 SDS 的空间是否足够， 如果不够的话， sdscat 就会先扩展 SDS 的空间， 然后才执行拼接操作。

    比如说， 如果我们执行：

    ```c
    sdscat(s, " Cluster");
    ```

    其中 SDS 值 s 如图 2-9 所示， 那么 sdscat 将在执行拼接操作之前检查 s 的长度是否足够， 在发现 s 目前的空间不足以拼接 " Cluster" 之后， sdscat 就会先扩展 s 的空间， 然后才执行拼接 " Cluster" 的操作， 如图所示。

    ![http://www.miaomiaoqi.cn/images/redis/redis_17.png](http://www.miaomiaoqi.cn/images/redis/redis_17.png)

    ![http://www.miaomiaoqi.cn/images/redis/redis_18.png](http://www.miaomiaoqi.cn/images/redis/redis_18.png)

    **sdscat 不仅对这个 SDS 进行了拼接操作， 它还为 SDS 分配了 13 字节的未使用空间， 并且拼接之后的字符串也正好是 13 字节长， 这种现象既不是 bug 也不是巧合， 它和 SDS 的空间分配策略有关.**

3. **减少修改字符串的内存重新分配次数**

    因为 C 字符串并不记录自身的长度， 所以对于一个包含了 N 个字符的 C 字符串来说， 这个 C 字符串的底层实现总是一个 N+1 个字符长的数组（额外的一个字符空间用于保存空字符）。

    因为 C 字符串的长度和底层数组的长度之间存在着这种关联性， 所以每次增长或者缩短一个 C 字符串， 程序都总要对保存这个 C 字符串的数组进行一次内存重分配操作：

    - 如果程序执行的是增长字符串的操作， 比如拼接操作（append）， 那么在执行这个操作之前， 程序需要先通过内存重分配来扩展底层数组的空间大小 —— 如果忘了这一步就会产生缓冲区溢出。
    - 如果程序执行的是缩短字符串的操作， 比如截断操作（trim）， 那么在执行这个操作之后， 程序需要通过内存重分配来释放字符串不再使用的那部分空间 —— 如果忘了这一步就会产生内存泄漏。

    因为内存重分配涉及复杂的算法， 并且可能需要执行系统调用， 所以它通常是一个比较耗时的操作：

    - 在一般程序中， 如果修改字符串长度的情况不太常出现， 那么每次修改都执行一次内存重分配是可以接受的。
    - 但是 Redis 作为数据库， 经常被用于速度要求严苛、数据被频繁修改的场合， 如果每次修改字符串的长度都需要执行一次内存重分配的话， 那么光是执行内存重分配的时间就会占去修改字符串所用时间的一大部分， 如果这种修改频繁地发生的话， 可能还会对性能造成影响。

    **而对于SDS，由于len属性和free属性的存在，对于修改字符串SDS实现了空间预分配和惰性空间释放两种策略：**

    * **空间预分配：**空间预分配用于优化 SDS 的字符串增长操作： 当 SDS 的 API 对一个 SDS 进行修改， 并且需要对 SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS 分配额外的未使用空间。其中， 额外分配的未使用空间数量由以下公式决定：

        * 如果对 SDS 进行修改之后， SDS 的长度（也即是 len 属性的值）将小于 1 MB ， 那么程序分配和 len 属性同样大小的未使用空间， 这时 SDS len 属性的值将和 free 属性的值相同。 举个例子， 如果进行修改之后， SDS 的 len 将变成 13 字节， 那么程序也会分配 13 字节的未使用空间， SDS 的 buf 数组的实际长度将变成 13 + 13 + 1 = 27 字节（额外的一字节用于保存空字符）。
        * 如果对 SDS 进行修改之后， SDS 的长度将大于等于 1 MB ， 那么程序会分配 1 MB 的未使用空间。 举个例子， 如果进行修改之后， SDS 的 len 将变成 30 MB ， 那么程序会分配 1 MB 的未使用空间， SDS 的 buf 数组的实际长度将为 30 MB + 1 MB + 1 byte.

        通过空间预分配策略， Redis 可以减少连续执行字符串增长操作所需的内存重分配次数。

    * **惰性空间释放：**对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 free 属性将这些字节的数量记录下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）

4. **二进制安全**

    C 字符串中的字符必须符合某种编码（比如 ASCII）， 并且除了字符串的末尾之外， 字符串里面不能包含空字符， 否则最先被程序读入的空字符将被误认为是字符串结尾 —— 这些限制使得 C 字符串只能保存文本数据， 而不能保存像图片、音频、视频、压缩文件这样的二进制数据。

    虽然数据库一般用于保存文本数据， 但使用数据库来保存二进制数据的场景也不少见， 因此， 为了确保 Redis 可以适用于各种不同的使用场景， SDS 的 API 都是二进制安全的（binary-safe）： 所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据， 程序不会对其中的数据做任何限制、过滤、或者假设 —— 数据在写入时是什么样的， 它被读取时就是什么样。 SDS 是以 len 属性表示的长度来判断字符串是否结束

    这也是我们将 SDS 的 buf 属性称为字节数组的原因 —— Redis 不是用这个数组来保存字符， 而是用它来保存一系列二进制数据。

5. **兼容部分 C 字符串函数**

    虽然 SDS 的 API 都是二进制安全的， 但它们一样遵循 C 字符串以空字符结尾的惯例： 这些 API 总会将 SDS 保存的数据的末尾设置为空字符， 并且总会在为 buf 数组分配空间时多分配一个字节来容纳这个空字符， 这是为了让那些保存文本数据的 SDS 可以重用一部分 <string.h> 库定义的函数。

| C 字符串                                     | SDS                                          |
| -------------------------------------------- | -------------------------------------------- |
| 获取字符串长度的复杂度为 O(N)                | 获取字符串长度的复杂度为O(1)                 |
| API 是不安全的, 可能会造成缓冲区溢出         | API 是安全的, 不会造成溢出                   |
| 修改字符串 N 次**必然**需要执行 N 次内存分配 | 修改字符串 N 次**最多**需要执行 N 次内存分配 |
| 只能保存文本数据                             | 可以保存文本或者二进制数据                   |
| 可以使用所有<string.h>库中的函数             | 可以使用一部分<string.h>库中的函数           |

**重点回顾**

- Redis 只会使用 C 字符串作为字面量， 在大多数情况下， Redis 使用 SDS （Simple Dynamic String，简单动态字符串）作为字符串表示。
- 比起 C 字符串， SDS 具有以下优点： 
    1. 常数复杂度获取字符串长度。
    2. 杜绝缓冲区溢出。
    3. 减少修改字符串长度时所需的内存重分配次数。
    4. 二进制安全。
    5. 兼容部分 C 字符串函数。

### 双端链表(linkedlist)

链表提供了高效的节点重排能力， 以及顺序性的节点访问方式， 并且可以通过增删节点来灵活地调整链表的长度。

作为一种常用数据结构， 链表内置在很多高级的编程语言里面， 因为 Redis 使用的 C 语言并没有内置这种数据结构， 所以 Redis 构建了自己的链表实现。

链表在 Redis 中的应用非常广泛， 比如列表键的底层实现之一就是链表： 当一个列表键包含了数量比较多的元素， 又或者列表中包含的元素都是比较长的字符串时， Redis 就会使用链表作为列表键的底层实现。

**链表节点定义**

```c
typedef struct listNode {

    // 前置节点
    struct listNode *prev;

    // 后置节点
    struct listNode *next;

    // 节点的值
    void *value;

} listNode;
```

**通过多个 listNode 结构就可以组成链表，这是一个双端链表，Redis还提供了操作链表的数据结构：**

```c
typedef struct list {

    // 表头节点
    listNode *head;

    // 表尾节点
    listNode *tail;

    // 链表所包含的节点数量
    unsigned long len;

    // 节点值复制函数
    void *(*dup)(void *ptr);

    // 节点值释放函数
    void (*free)(void *ptr);

    // 节点值对比函数
    int (*match)(void *ptr, void *key);

} list;
```

list 结构为链表提供了表头指针 head 、表尾指针 tail ， 以及链表长度计数器 len ， 而 dup 、 free 和 match 成员则是用于实现多态链表所需的类型特定函数：

- dup 函数用于复制链表节点所保存的值；
- free 函数用于释放链表节点所保存的值；
- match 函数则用于对比链表节点所保存的值和另一个输入值是否相等。

![http://www.miaomiaoqi.cn/images/redis/redis_21.png](http://www.miaomiaoqi.cn/images/redis/redis_21.png)

Redis 的链表实现的特性可以总结如下：

- 双端： 链表节点带有 prev 和 next 指针， 获取某个节点的前置节点和后置节点的复杂度都是 O(1) 。
- 无环： 表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL ， 对链表的访问以 NULL 为终点。
- 带表头指针和表尾指针： 通过 list 结构的 head 指针和 tail 指针， 程序获取链表的表头节点和表尾节点的复杂度为 O(1) 。
- 带链表长度计数器： 程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数， 程序获取链表中节点数量的复杂度为 O(1) 。
- 多态： 链表节点使用 void* 指针来保存节点值， 并且可以通过 list 结构的 dup 、 free 、 match 三个属性为节点值设置类型特定函数， 所以链表可以用于保存各种不同类型的值。

**重点回顾**

- 链表被广泛用于实现 Redis 的各种功能， 比如列表键， 发布与订阅， 慢查询， 监视器， 等等。
- 每个链表节点由一个 listNode 结构来表示， 每个节点都有一个指向前置节点和后置节点的指针， 所以 Redis 的链表实现是双端链表。
- 每个链表使用一个 list 结构来表示， 这个结构带有表头节点指针、表尾节点指针、以及链表长度等信息。
- 因为链表表头节点的前置节点和表尾节点的后置节点都指向 NULL ， 所以 Redis 的链表实现是无环链表。
- 通过为链表设置不同的类型特定函数， Redis 的链表可以用于保存各种不同类型的值。

### 字典(ht)

字典， 又称符号表（symbol table）、关联数组（associative array）或者映射（map）， 是一种用于保存键值对（key-value pair）的抽象数据结构。

在字典中， 一个键（key）可以和一个值（value）进行关联（或者说将键映射为值）， 这些关联的键和值就被称为键值对。

字典中的每个键都是独一无二的， 程序可以在字典中根据键查找与之关联的值， 或者通过键来更新值， 又或者根据键来删除整个键值对， 等等。

字典经常作为一种数据结构内置在很多高级编程语言里面， 但 Redis 所使用的 C 语言并没有内置这种数据结构， 因此 Redis 构建了自己的字典实现。

字典在 Redis 中的应用相当广泛， 比如 Redis 的数据库就是使用字典来作为底层实现的， 对数据库的增、删、查、改操作也是构建在对字典的操作之上的。

举个例子， 当我们执行命令

```
redis> SET msg "hello world"
OK
```

在数据库中创建一个键为 "msg" ， 值为 "hello world" 的键值对时， 这个键值对就是保存在代表数据库的字典里面的。

除了用来表示数据库之外， 字典还是哈希键的底层实现之一： 当一个哈希键包含的键值对比较多， 又或者键值对中的元素都是比较长的字符串时， Redis 就会使用字典作为哈希键的底层实现。

**哈希表结构定义:**

```c
typedef struct dictht{

     // 哈希表数组
     dictEntry **table;

     // 哈希表大小
     unsigned long size;

     // 哈希表大小掩码，用于计算索引值
     // 总是等于 size-1
     unsigned long sizemask;

     // 该哈希表已有节点的数量
     unsigned long used;

} dictht
```

**table** 属性是一个数组， 数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。

**size** 属性记录了哈希表的大小， 也即是 table 数组的大小， 而 used 属性则记录了哈希表目前已有节点（键值对）的数量。

**sizemask** 属性的值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。

![http://www.miaomiaoqi.cn/images/redis/redis_22.png](http://www.miaomiaoqi.cn/images/redis/redis_22.png)

**哈希表是由数组 table 组成，table 中每个元素都是指向 dict.h/dictEntry 结构，dictEntry 结构定义如下**

```c
typedef struct dictEntry{

     // 键
     void *key;

     // 值
     union{
          void *val;
          uint64_tu64;
          int64_ts64;
     } v;

     // 指向下一个哈希表节点，形成链表
     struct dictEntry *next;

} dictEntry;
```

**key** 属性保存着键值对中的键

**v** 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数。

**next** 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。

举个例子， 图 4-2 就展示了如何通过 next 指针， 将两个索引值相同的键 k1 和 k0 连接在一起。

注意这里还有一个指向下一个哈希表节点的指针，我们知道哈希表最大的问题是存在哈希冲突，如何解决哈希冲突，有开放地址法和链地址法。**这里采用的便是链地址法**，通过next这个指针可以将多个哈希值相同的键值对连接在一起，用来解决**哈希冲突**。

![http://www.miaomiaoqi.cn/images/redis/redis_6.png](http://www.miaomiaoqi.cn/images/redis/redis_6.png)

**字典定义: Redis 中的字典由 dict.h/dict 结构表示：**

```c
typedef struct dict {

    // 类型特定函数
    dictType *type;

    // 私有数据
    void *privdata;

    // 哈希表
    dictht ht[2];

    // rehash 索引
    // 当 rehash 不在进行时，值为 -1
    int rehashidx; /* rehashing not in progress if rehashidx == -1 */

} dict;
```

type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的：

**type** 属性是一个指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。

**privdata** 属性则保存了需要传给那些类型特定函数的可选参数。

```c
typedef struct dictType {

    // 计算哈希值的函数
    unsigned int (*hashFunction)(const void *key);

    // 复制键的函数
    void *(*keyDup)(void *privdata, const void *key);

    // 复制值的函数
    void *(*valDup)(void *privdata, const void *obj);

    // 对比键的函数
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);

    // 销毁键的函数
    void (*keyDestructor)(void *privdata, void *key);

    // 销毁值的函数
    void (*valDestructor)(void *privdata, void *obj);

} dictType;
```

ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。

除了 ht[1] 之外， 另一个和 rehash 有关的属性就是 rehashidx ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 -1 。

**一个普通状态下（没有进行 rehash）的字典：**

![http://www.miaomiaoqi/images/redis/redis_23.png](http://www.miaomiaoqi/images/redis/redis_23.png)



**哈希算法：**

当要将一个新的键值对添加到字典里面时， 程序需要先根据键值对的键计算出哈希值和索引值， 然后再根据索引值， 将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。

Redis 计算哈希值和索引值的方法如下：

```
# 使用字典设置的哈希函数，计算键 key 的哈希值
hash = dict->type->hashFunction(key);

# 使用哈希表的 sizemask 属性和哈希值，计算出索引值
# 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]
index = hash & dict->ht[x].sizemask;
```

如果我们要将一个键值对 k0 和 v0 添加到字典里面， 那么程序会先使用语句：

```
hash = dict->type->hashFunction(k0);
```

计算键 k0 的哈希值。

假设计算得出的哈希值为 8 ， 那么程序会继续使用语句：

```
index = hash & dict->ht[0].sizemask = 8 & 3 = 0;
```

计算出键 k0 的索引值 0 ， 这表示包含键值对 k0 和 v0 的节点应该被放置到哈希表数组的索引 0 位置上



![http://www.miaomiaoqi.cn/images/redis_24.png](http://www.miaomiaoqi.cn/images/redis_24.png)

当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。

MurmurHash 算法最初由 Austin Appleby 于 2008 年发明， 这种算法的优点在于， 即使输入的键是有规律的， 算法仍能给出一个很好的随机分布性， 并且算法的计算速度也非常快。



**解决哈希冲突：**

当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时， 我们称这些键发生了冲突（collision）。

Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 next 指针， 多个哈希表节点可以用 next 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。

举个例子， 假设程序要将键值对 k2 和 v2 添加到图 4-6 所示的哈希表里面， 并且计算得出 k2 的索引值为 2 ， 那么键 k1 和 k2 将产生冲突， 而解决冲突的办法就是使用 next 指针将键 k2 和 k1 所在的节点连接起来

![http://www.miaomiaoqi.cn/images/redis/redis_25.png](http://www.miaomiaoqi.cn/images/redis/redis_25.png)

因为 dictEntry 节点组成的链表没有指向链表表尾的指针， 所以为了速度考虑， 程序总是将新节点添加到链表的表头位置（复杂度为 O(1)）， 排在其他已有节点的前面。



**rehash:**

随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。

扩展和收缩哈希表的工作可以通过执行 rehash （重新散列）操作来完成， Redis 对字典的哈希表执行 rehash 的步骤如下：

1. 为字典的 ht[1] 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 ht[0] 当前包含的键值对数量 （也即是 ht[0].used 属性的值）： 
    - 如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）；
    - 如果执行的是收缩操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。
2. 将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上。
3. 当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备。

举个例子， 假设程序要对图 4-8 所示字典的 ht[0] 进行扩展操作， 那么程序将执行以下步骤：

1. ht[0].used 当前的值为 4 ， 4 * 2 = 8 ， 而 8 （2^3）恰好是第一个大于等于 4 的 2 的 n 次方， 所以程序会将 ht[1] 哈希表的大小设置为 8 。 图 4-9 展示了 ht[1] 在分配空间之后， 字典的样子。
2. 将 ht[0] 包含的四个键值对都 rehash 到 ht[1] ， 如图 4-10 所示。
3. 释放 ht[0] ，并将 ht[1] 设置为 ht[0] ，然后为 ht[1] 分配一个空白哈希表，如图 4-11 所示。

至此， 对哈希表的扩展操作执行完毕， 程序成功将哈希表的大小从原来的 4 改为了现在的 8 。

1. 执行 rehash 之前的字典

    ![http://www.miaomiaoqi.cn/images/redis/redis_32.png](http://www.miaomiaoqi.cn/images/redis/redis_32.png)

2. 为字典的 ht[1] 哈希表分配空间

    ![http://www.miaomiaoqi.cn/images/redis/redis_33.png](http://www.miaomiaoqi.cn/images/redis/redis_33.png)

3. ht[0] 的所有键值对都已经被迁移到 ht[1]

    ![http://www.miaomiaoqi.cn/images/redis/redis_34.png](http://www.miaomiaoqi.cn/images/redis/redis_34.png)

4. 完成 rehash 之后的字典

    ![http://www.miaomiaoqi.cn/images/redis/redis_35.png](http://www.miaomiaoqi.cn/images/redis/redis_35.png)

**扩容和收缩：**

当哈希表保存的键值对太多或者太少时，就要通过 rerehash(重新散列）来对哈希表进行相应的扩展或者收缩。具体步骤：

1. 如果执行扩展操作，会基于原哈希表创建一个大小等于 ht[0].used*2n 的哈希表（也就是每次扩展都是根据原哈希表已使用的空间扩大一倍创建另一个哈希表）。相反如果执行的是收缩操作，每次收缩是根据已使用空间缩小一倍创建一个新的哈希表。

2. 重新利用上面的哈希算法，计算索引值，然后将键值对放到新的哈希表位置上。

3. 所有键值对都迁徙完毕后，释放原哈希表的内存空间。

**触发扩容的条件：**

当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：

* 服务器目前没有执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于1。

* 服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且负载因子大于等于5。

* 负载因子 = 哈希表已保存节点数量 / 哈希表大小。

    ```
    # 负载因子 = 哈希表已保存节点数量 / 哈希表大小
    load_factor = ht[0].used / ht[0].size
    ```

    比如说， 对于一个大小为 `4` ， 包含 `4` 个键值对的哈希表来说， 这个哈希表的负载因子为：

    ```
    load_factor = 4 / 4 = 1
    ```

    又比如说， 对于一个大小为 `512` ， 包含 `256` 个键值对的哈希表来说， 这个哈希表的负载因子为：

    ```
    load_factor = 256 / 512 = 0.5
    ```

    根据 BGSAVE 命令或 BGREWRITEAOF 命令是否正在执行， 服务器执行扩展操作所需的负载因子并不相同， 这是因为在执行 BGSAVE命令或 BGREWRITEAOF 命令的过程中， Redis 需要创建当前服务器进程的子进程， 而大多数操作系统都采用写时复制（[copy-on-write](http://en.wikipedia.org/wiki/Copy-on-write)）技术来优化子进程的使用效率， 所以在子进程存在期间， 服务器会提高执行扩展操作所需的负载因子， 从而尽可能地避免在子进程存在期间进行哈希表扩展操作， 这可以避免不必要的内存写入操作， 最大限度地节约内存。

    另一方面， 当哈希表的负载因子小于 `0.1` 时， 程序自动开始对哈希表执行收缩操作。



**渐近式 rehash**

扩展或收缩哈希表需要将 ht[0] 里面的所有键值对 rehash 到 ht[1] 里面， 但是， 这个 rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。

这样做的原因在于， 如果 ht[0] 里只保存着四个键值对， 那么服务器可以在瞬间就将这些键值对全部 rehash 到 ht[1] ； 但是， 如果哈希表里保存的键值对数量不是四个， 而是四百万、四千万甚至四亿个键值对， 那么要一次性将这些键值对全部 rehash 到 ht[1] 的话， 庞大的计算量可能会导致服务器在一段时间内停止服务。

因此， 为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 ht[0] 里面的所有键值对全部 rehash 到 ht[1] ， 而是分多次、渐进式地将 ht[0] 里面的键值对慢慢地 rehash 到 ht[1] 。

以下是哈希表渐进式 rehash 的详细步骤：

1. 为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。
2. 在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。
3. 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。
4. 随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。

渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。

一次完整的渐进式 rehash 过程， 注意观察在整个 rehash 过程中， 字典的 rehashidx 属性是如何变化的



1. 准备开始rehash

    ![http://www.miaomiaoqi.cn/images/redis/redis_26.png](http://www.miaomiaoqi.cn/images/redis/redis_26.png)

2. rehash 索引 0 上的键值对

    ![http://www.miaomiaoqi.cn/images/redis/redis_27.png](http://www.miaomiaoqi.cn/images/redis/redis_27.png)

3. rehash 索引 1 上的键值对

    ![http://www.miaomiaoqi.cn/images/redis/redis_28.png](http://www.miaomiaoqi.cn/images/redis/redis_28.png)

4. rehash 索引 2 上的键值对

    ![http://www.miaomiaoqi.cn/images/redis/redis_29.png](http://www.miaomiaoqi.cn/images/redis/redis_29.png)

5. rehash 索引 3 上的键值对

    ![http://www.miaomiaoqi.cn/images/redis/redis_30.png](http://www.miaomiaoqi.cn/images/redis/redis_30.png)

6. rehash 完毕

    ![http://www.miaomiaoqi.cn/images/redis/redis_31.png](http://www.miaomiaoqi.cn/images/redis/redis_31.png)



**因为在进行渐进式 rehash 的过程中， 字典会同时使用 ht[0] 和 ht[1] 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 ht[0] 里面进行查找， 如果没找到的话， 就会继续到 ht[1] 里面进行查找， 诸如此类。**

**另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 ht[1] 里面， 而 ht[0] 则不再进行任何添加操作： 这一措施保证了 ht[0] 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。**

**重点回顾**

- 字典被广泛用于实现 Redis 的各种功能， 其中包括数据库和哈希键。
- Redis 中的字典使用哈希表作为底层实现， 每个字典带有两个哈希表， 一个用于平时使用， 另一个仅在进行 rehash 时使用。
- 当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。
- 哈希表使用链地址法来解决键冲突， 被分配到同一个索引上的多个键值对会连接成一个单向链表。
- 在对哈希表进行扩展或者收缩操作时， 程序需要将现有哈希表包含的所有键值对 rehash 到新哈希表里面， 并且这个 rehash 过程并不是一次性地完成的， 而是渐进式地完成的。



### 跳跃表(skiplist)

跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其它节点的指针，从而达到快速访问节点的目的。具有如下性质：

1. 由很多层结构组成；

2. 每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点；

3. 最底层的链表包含了所有的元素；

4. 如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）；

5. 链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点；

![http://www.miaomiaoqi.cn/images/redis/redis_7.png](http://www.miaomiaoqi.cn/images/redis/redis_7.png)

**Redis中跳跃表节点定义如下：**

```
typedef struct zskiplistNode {

     //层
     struct zskiplistLevel{

           //前进指针
           struct zskiplistNode *forward;

           //跨度
           unsigned int span;

     }level[];

     //后退指针
     struct zskiplistNode *backward;

     //分值
     double score;

     //成员对象
     robj *obj;

} zskiplistNode
```

**多个跳跃表节点构成一个跳跃表：**

```
typedef struct zskiplist{

     //表头节点和表尾节点
     structz skiplistNode *header, *tail;

     //表中节点的数量
     unsigned long length;

     //表中层数最大的节点的层数
     int level;

}zskiplist;
```

![http://www.miaomiaoqi.cn/images/redis/redis_8.png](http://www.miaomiaoqi.cn/images/redis/redis_8.png)

* **搜索：**从最高层的链表节点开始，如果比当前节点要大和比当前层的下一个节点要小，那么则往下找，也就是和当前层的下一层的节点的下一个节点进行比较，以此类推，一直找到最底层的最后一个节点，如果找到则返回，反之则返回空。

* **插入：**首先确定插入的层数，有一种方法是假设抛一枚硬币，如果是正面就累加，直到遇见反面为止，最后记录正面的次数作为插入的层数。当确定插入的层数k后，则需要将新元素插入到从底层到k层。

* **删除：**在各个层中找到包含指定值的节点，然后将节点从链表中删除即可，如果删除以后只剩下头尾两个节点，则删除这一层。



### 整数集合(intset)

整数集合（intset）是Redis用于保存整数值的集合抽象数据类型，它可以保存类型为int16_t、int32_t 或者int64_t 的整数值，并且保证集合中不会出现重复元素。

**整数集合定义如下:**

```
typedef struct intset{

     //编码方式
     uint32_t encoding;

     //集合包含的元素数量
     uint32_t length;

     //保存元素的数组
     int8_t contents[];

}intset;
```

整数集合的每个元素都是 contents 数组的一个数据项，它们按照从小到大的顺序排列，并且不包含任何重复项。

length 属性记录了 contents 数组的大小。

需要注意的是虽然 contents 数组声明为 int8_t 类型，但是实际上contents 数组并不保存任何 int8_t 类型的值，其真正类型有 encoding 来决定。

* 升级

    当我们新增的元素类型比原集合元素类型的长度要大时，需要对整数集合进行升级，才能将新元素放入整数集合中。

    1. 根据新元素类型，扩展整数集合底层数组的大小，并为新元素分配空间。

    2. 将底层数组现有的所有元素都转成与新元素相同类型的元素，并将转换后的元素放到正确的位置，放置过程中，维持整个元素顺序都是有序的。
    3. 将新元素添加到整数集合中（保证有序）。

　　升级能极大地节省内存。

* 降级

    整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。



### 压缩列表(ziplist)

压缩列表（ziplist）是Redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。

**压缩列表的原理：压缩列表并不是对数据利用某种算法进行压缩，而是将数据按照一定规则编码在一块连续的内存区域，目的是节省内存。**

![http://www.miaomiaoqi.cn/images/redis/redis_9.png](http://www.miaomiaoqi.cn/images/redis/redis_9.png)

| 属性    | 类型     | 长度   | 用途                                                         |
| ------- | -------- | ------ | ------------------------------------------------------------ |
| zlbytes | uint32_t | 4字节  | 记录整个压缩列表占用的内存字节数: 再对压缩列表进行内存重分配,或者计算zlend的位置时使用 |
| zltail  | uint32_t | 4 字节 | 记录压缩列表表尾节点距离压缩列表的起始地址有多少字节: 通过这个偏移量, 程序无需遍历整个压缩列表就可以确定表尾节点的地址 |
| zllen   | uint16_t | 2 字节 | 记录了压缩列表包含的节点数据: 当这个属性的值小于uint16_max(65535)时, 这个属性的值就是压缩列表包含节点的数量;当这个值等于uint16_max 时, 节点的真实数量需要遍历整个压缩列表才能计算得出 |
| entryX  | 列表节点 | 不定   | 压缩列表包含的各个节点, 节点的长度由节点保存的内容决定       |
| zlend   | uint8_t  | 1 字节 | 特殊值0xFF(十进制 255), 用于标记压缩列表的末端               |

**压缩列表的每个节点构成如下：**

![http://www.miaomiaoqi.cn/images/redis/redis_10.png](http://www.miaomiaoqi.cn/images/redis/redis_10.png)

* previous_entry_ength：记录压缩列表前一个字节的长度。previous_entry_ength的长度可能是1个字节或者是5个字节，如果上一个节点的长度小于254，则该节点只需要一个字节就可以表示前一个节点的长度了，如果前一个节点的长度大于等于254，则previous length的第一个字节为254，后面用四个字节表示当前节点前一个节点的长度。利用此原理即当前节点位置减去上一个节点的长度即得到上一个节点的起始位置，压缩列表可以从尾部向头部遍历。这么做很有效地减少了内存的浪费。

* encoding：节点的encoding保存的是节点的content的内容类型以及长度，encoding类型一共有两种，一种字节数组一种是整数，encoding区域长度为1字节、2字节或者5字节长。

* content：content区域用于保存节点的内容，节点内容类型和长度由encoding决定。

### 总结

大多数情况下，Redis使用简单字符串SDS作为字符串的表示，相对于C语言字符串，SDS具有常数复杂度获取字符串长度，杜绝了缓存区的溢出，减少了修改字符串长度时所需的内存重分配次数，以及二进制安全能存储各种类型的文件，并且还兼容部分C函数。

通过为链表设置不同类型的特定函数，Redis链表可以保存各种不同类型的值，除了用作列表键，还在发布与订阅、慢查询、监视器等方面发挥作用（后面会介绍）。

Redis的字典底层使用哈希表实现，每个字典通常有两个哈希表，一个平时使用，另一个用于rehash时使用，使用链地址法解决哈希冲突。

跳跃表通常是有序集合的底层实现之一，表中的节点按照分值大小进行排序。

整数集合是集合键的底层实现之一，底层由数组构成，升级特性能尽可能的节省内存。

压缩列表是Redis为节省内存而开发的顺序型数据结构，通常作为列表键和哈希键的底层实现之一。

以上介绍的简单字符串、链表、字典、跳跃表、整数集合、压缩列表等数据结构就是Redis底层的一些数据结构，用来实现上一篇博客介绍的Redis五大数据类型，那么每种数据类型是由哪些数据结构实现的呢？下一篇博客进行介绍。

## Redis五大类型与底层结构的关系

### 字符串对象(String)

**字符串对象的编码可以是int、raw或者embstr**
如果一个字符串的内容可以转换为long，那么该字符串就会被转换成为long类型，对象的ptr就会指向该long，并且对象类型也用int类型表示。
普通的字符串有两种，embstr和raw。embstr应该是Redis 3.0新增的数据结构,在2.8中是没有的。**如果字符串对象的长度小于39字节，就用embstr对象。否则用传统的raw对象。**

```
#define REDIS_ENCODING_EMBSTR_SIZE_LIMIT 44  
robj *createStringObject(char *ptr, size_t len) {  
    if (len <= REDIS_ENCODING_EMBSTR_SIZE_LIMIT)  
        return createEmbeddedStringObject(ptr,len);  
    else  
        return createRawStringObject(ptr,len);  
}  
```

embstr的好处有如下几点：

1. embstr的创建只需分配一次内存，而raw为两次（一次为[`sds`](https://github.com/antirez/redis/blob/unstable/src/sds.h)分配对象，另一次为objet分配对象，embstr省去了第一次）。
2. 相对地，释放内存的次数也由两次变为一次。
3. embstr的objet和sds放在一起，更好地利用缓存带来的优势。
4. 但redis不集成对embstr的操作，因此执行命令时，会自动将embstr转换为row编码

raw 和 embstr 的区别可以用下面两幅图所示：

**raw 编码的字符串对象:**

![http://www.miaomiaoqi.cn/images/redis/redis_11.png](http://www.miaomiaoqi.cn/images/redis/redis_11.png)

**embstr 编码的字符串对象:**

![http://www.miaomiaoqi.cn/images/redis/redis_12.png](http://www.miaomiaoqi.cn/images/redis/redis_12.png)



**当字符串对象是由整数构成时，采用整数值作为底层结构；当对象有字符串构成，且值小于32字节，此时用embstr编码的SDS，否则采用row编码的SDS。**



### 列表对象(List)

**列表对象的编码可以是ziplist或者linkedlist**

ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。当列表对象元素不大，每个元素也不大的时候，就采用ziplist存储但当数据量过大时就ziplist就不是那么好用了。因为为了保证他存储内容在内存中的连续性，插入的复杂度是O(N)，即每次插入都会重新进行realloc。如下图所示，对象结构中ptr所指向的就是一个ziplist整个ziplist只需要malloc一次，它们在内存中是一块连续的区域。

![http://www.miaomiaoqi.cn/images/redis/redis_13.png](http://www.miaomiaoqi.cn/images/redis/redis_13.png)

linkedlist是一种双向链表。它的结构比较简单，节点中存放pre和next两个指针，还有节点相关的信息。当每增加一个node的时候，就需要重新malloc一块内存。

![http://www.miaomiaoqi.cn/images/redis/redis_14.png](http://www.miaomiaoqi.cn/images/redis/redis_14.png)



**当列表对象所有值小于64字节，且长度小于512个，采用压缩列表作为底层结构。否则自动采用双端链表的结构**

### 哈希(Map)

**哈希对象的底层实现可以是ziplist或者hashtable。**
ziplist中的哈希对象是按照key1,value1,key2,value2这样的顺序存放来存储的。当对象数目不多且内容不大时，这种方式效率是很高的。

hashtable的是由dict这个结构来实现的, dict是一个字典，其中的指针dicht ht[2] 指向了两个哈希表

```
typedef struct dict {  
    dictType *type;  
    void *privdata;  
    dictht ht[2];  
    long rehashidx; /* rehashing not in progress if rehashidx == -1 */  
    int iterators; /* number of iterators currently running */  
} dict;  
typedef struct dictht {  
    dictEntry **table;  
    unsigned long size;  
    unsigned long sizemask;  
    unsigned long used;  
} dictht;  
```

dicht[0] 是用于真正存放数据，dicht[1]一般在哈希表元素过多进行rehash的时候用于中转数据。
dictht中的table用语真正存放元素了，每个key/value对用一个dictEntry表示，放在dictEntry数组中。

![http://www.miaomiaoqi.cn/images/redis/redis_15.png](http://www.miaomiaoqi.cn/images/redis/redis_15.png)

**当哈希对象每个值小于64字节，且大小小于512个时，采用压缩列表作为底层结构。否则自动采用字典的结构**

### 集合对象(Set)

**集合对象的编码可以是intset或者hashtable**
intset是一个整数集合，里面存的为某种同一类型的整数，支持如下三种长度的整数：

```
#define INTSET_ENC_INT16 (sizeof(int16_t))  
#define INTSET_ENC_INT32 (sizeof(int32_t))  
#define INTSET_ENC_INT64 (sizeof(int64_t))
```

intset是一个有序集合，查找元素的复杂度为O(logN)，但插入时不一定为O(logN)，因为有可能涉及到升级操作。比如当集合里全是int16_t型的整数，这时要插入一个int32_t，那么为了维持集合中数据类型的一致，那么所有的数据都会被转换成int32_t类型，涉及到内存的重新分配，这时插入的复杂度就为O(N)了。
intset不支持降级操作。

**当集合对象每个值是整数，且集合大小小于512个时，采用整数作为底层结构。否则自动采用字典的结构**

### 有序集合对象(ZSet)

**有序集合的编码可能两种，一种是ziplist，另一种是skiplist与dict的结合。**
ziplist作为集合和作为哈希对象是一样的，member和score顺序存放。按照score从小到大顺序排列
skiplist是一种跳跃表，它实现了有序集合中的快速查找，在大多数情况下它的速度都可以和平衡树差不多。但它的实现比较简单，可以作为平衡树的替代品。它的结构比较特殊。下面分别是跳跃表skiplist和它内部的节点skiplistNode的结构体：

```
/* 
 * 跳跃表 
 */  
typedef struct zskiplist {  
    // 头节点，尾节点  
    struct zskiplistNode *header, *tail;  
    // 节点数量  
    unsigned long length;  
    // 目前表内节点的最大层数  
    int level;  
} zskiplist;  
/* ZSETs use a specialized version of Skiplists */  
/* 
 * 跳跃表节点 
 */  
typedef struct zskiplistNode {  
    // member 对象  
    robj *obj;  
    // 分值  
    double score;  
    // 后退指针  
    struct zskiplistNode *backward;  
    // 层  
    struct zskiplistLevel {  
        // 前进指针  
        struct zskiplistNode *forward;  
        // 这个层跨越的节点数量  
        unsigned int span;  
    } level[];  
} zskiplistNode;  
```

head和tail分别指向头节点和尾节点，然后每个skiplistNode里面的结构又是分层的(即level数组)
用图表示，大概是下面这个样子：

![http://www.miaomiaoqi.cn/images/redis/redis_16.png](http://www.miaomiaoqi.cn/images/redis/redis_16.png)

**当集合的长度小于64字节，且集合大小小于128时，采用压缩列表作为底层结构。否则自动采用跳跃表和字典的结构**

**有序集合是比较特殊的结构，采用跳跃表和字典双重结构：**

**当单独采用跳跃表时，虽然保留跳跃表的优点，但是获取集合的值时，无法像字典那样效率达到O（1）**

**当单独采用字典结构时，虽然获取值时效率较高，但由于字典时无序的，进行有序遍历或者排序时，效率较差。**