---
layout: post
title:  "JVM垃圾收集策略与算法"
date:   2018-05-17 21:12:38
categories: Java
tags: JVM
author: miaoqi
---

* content
{:toc}

## 触发条件

* 程序调用System.gc时可以触发

* 系统自身来决定GC触发的时机

    * 根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程

## 如何判定对象为垃圾对象

1. 引用计数法

    * 在对象头中添加一个引用计数器, 当有地方引用这个对象的时候, 引用计数器的值+1, 当引用失效的时候, 引用计数器的值-1

    * 引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法。但是主流的 Java 虚拟机里没有选用引用计数算法来管理内存，主要是因为它很难解决对象之间循环引用的问题。

    * -verbose:gc(简单打印日志信息)

    * -XX:+PrintGCDetails(详细打印日志信息)

1. 可达性分析法

    * 所有和 GC Roots 直接或间接关联的对象都是有效对象，和 GC Roots 没有关联的对象就是无效对象。

    * 作为GCRoot对象

        * Java 虚拟机栈（栈帧中的本地变量表）中引用的对象

        * 方法区中类静态属性引用的对象

        * 方法区中常量引用的对象

        * 本地方法栈中所引用的对象

        GC Roots 并不包括堆中对象所引用的对象，这样就不会有循环引用的问题。

## 引用的种类

判定对象是否存活与“引用”有关。在 JDK 1.2 以前，Java 中的引用定义很传统，一个对象只有被引用或者没有被引用两种状态，我们希望能描述这一类对象：当内存空间还足够时，则保留在内存中；如果内存空间在进行垃圾手收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。

在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为了以下四种：

* 强引用（Strong Reference）

    类似 "Object obj = new Object()" 这类的引用，就是强引用，只要强引用存在，垃圾收集器永远不会回收被引用的对象。

* 软引用（Soft Reference）

    软引用是用来描述一些有用但并非必需的对象，j就是说，内存足够时留着它们，内存即将发生溢出时把这些对象列入回收范围进行回收。若回收过后还没有足够的内存，才抛出内存溢出异常。

* 弱引用（Weak Reference）

    弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些。当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被软引用关联的对象。

* 虚引用（Phantom Reference）

    虚引用也称幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

## 回收堆中无效对象

对于可达性分析中不可达的对象，也并不是没有存活的可能。

* 判定 finalize() 是否有必要执行

    JVM 会判断此对象是否有必要执行 finalize() 方法，如果对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，那么视为“没有必要执行”。那么对象基本上就真的被回收了。

    如果对象被判定为有必要执行 finalize() 方法，那么对象会被放入一个 F-Queue 队列中，虚拟机会以较低的优先级执行这些 finalize()方法，但不会确保所有的 finalize() 方法都会执行结束。如果 finalize() 方法出现耗时操作，虚拟机就直接停止指向该方法，将对象清除。

* 对象重生或死亡

    如果在执行 finalize() 方法时，将 this 赋给了某一个引用，那么该对象就重生了。如果没有，那么就会被垃圾收集器清除。

    任何一个对象的 finalize() 方法只会被系统自动调用一次，如果对象面临下一次回收，它的 finalize() 方法不会被再次执行，想继续在 finalize() 中自救就失效了。

### 具体回收过程

* 当GC线程启动时，会通过可达性分析法把Eden区和From Space区的存活对象复制到To Space区，然后把Eden Space和From Space区的对象释放掉。当GC轮训扫描To Space区一定次数后，把依然存活的对象复制到老年代，然后释放To Space区的对象。

* 对于用可达性分析法搜索不到的对象，GC并不一定会回收该对象。要完全回收一个对象，至少需要经过两次标记的过程。

    1. 对于一个没有其他引用的对象，筛选该对象是否有必要执行finalize()方法，如果没有执行必要，则意味可直接回收。（筛选依据：是否复写或执行过finalize()方法；因为finalize方法只能被执行一次）。

    1. 如果被筛选判定位有必要执行，则会放入FQueue队列，并自动创建一个低优先级的finalize线程来执行释放操作。如果在一个对象释放前被其他对象引用，则该对象会被移除FQueue队列。

## 回收方法区内存

方法区中存放生命周期较长的类信息、常量、静态变量，每次垃圾收集只有少量的垃圾被清除。方法区中主要清除两种垃圾：

* 废弃常量

    只要常量池中的常量不被任何变量或对象引用，那么这些常量就会被清除掉。比如，一个字符串 "bingo" 进入了常量池，但是当前系统没有任何一个 String 对象引用常量池中的 "bingo" 常量，也没有其它地方引用这个字面量，必要的话，"bingo"常量会被清理出常量池。

* 无用的类

    判定一个类是否是“无用的类”，条件较为苛刻：

    * 该类的所有对象都已经被清除
    
    * 加载该类的 ClassLoader 已经被回收
        
    * 该类的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

    * 一个类被虚拟机加载进方法区，那么在堆中就会有一个代表该类的对象：java.lang.Class。这个对象在类被加载进方法区时创建，在方法区该类被删除时清除。

## 垃圾收集算法

1. 标记-清除算法

    判断哪些数据需要清除，并对它们进行标记，然后清除被标记的数据。

    * 效率问题：标记和清除两个过程的效率都不高。

    * 空间问题：标记清除之后会产生大量不连续的内存碎片，碎片太多可能导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作
        

1. 复制算法（新生代）

    为了解决效率问题，“复制”收集算法出现了。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完，需要进行垃圾收集时，就将存活者的对象复制到另一块上面，然后将第一块内存全部清除。这种算法有优有劣：

    * 优点：不会有内存碎片的问题。

    * 缺点：内存缩小为原来的一半，浪费空间。

    为了解决空间利用率问题，可以将内存分为三块： Eden、From Survivor、To Survivor，比例是 8:1:1，每次使用 Eden 和其中一块 Survivor。回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才使用的 Survivor 空间。这样只有 10% 的内存被浪费。

    但是我们无法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够，需要依赖其他内存（指老年代）进行**分配担保**。

    **分配担保**

    **为对象分配内存空间时，如果 Survivor 中空闲区域无法装下该对象，会触发 MinorGC 进行垃圾收集。但如果 Minor GC 过后依然有超过 10% 的对象存活，这样存活的对象直接通过分配担保机制进入老年代，然后再将新对象存入 Eden 区。**
        
1. 标记-整理-清除算法（老年代, 回收率低）

    在回收垃圾前，首先将废弃对象做上标记，然后将未标记的对象移到一边，最后清空另一边区域即可。

    这是一种老年代的垃圾收集算法。老年代的对象一般寿命比较长，因此每次垃圾回收会有大量对象存活，如果采用复制算法，每次需要复制大量存活的对象，效率很低。
         
1. 分代收集算法

    根据对象存活周期的不同，将内存划分为几块。一般是把 Java 堆分为新生代和老年代，针对各个年代的特点采用最适当的收集算法。

    新生代：复制算法

    老年代：标记-清除算法、标记-整理算法

## 常见垃圾收集器

### 新生代垃圾收集器

1. Serial 垃圾收集器(单线程, 采用复制算法)

    * 最基本, 发展最悠久

    * 只开启一条 GC 线程进行垃圾回收，并且在垃圾收集过程中停止一切用户线程(Stop The World)。

    * 一般客户端应用所需内存较小，不会创建太多对象，而且堆内存不大，因此垃圾收集器回收时间短，即使在这段时间停止一切用户线程，也不会感觉明显卡顿。因此 Serial 垃圾收集器**适合客户端使用**。

    * 由于 Serial 收集器只使用一条 GC 线程，避免了线程切换的开销，从而简单高效。 

    应用程序线程 -> GC线程(应用程序线程暂停Stop The World) -> 应用程序线程

1. ParNew 垃圾收集器（多线程）

    * ParNew 是 Serial 的多线程版本。由多条 GC 线程并行地进行垃圾清理。但清理过程依然需要 Stop The World。

    * ParNew 追求“低停顿时间”,与 Serial 唯一区别就是使用了多线程进行垃圾收集，在多 CPU 环境下性能比 Serial 会有一定程度的提升；但线程切换需要额外的开销，因此在单 CPU 环境中表现不如 Serial。

1. Parallel Scavenge收集器(多线程), 提高了用户体验, 相比Parnew多了吞吐量

    * 复制算法(新生代收集器)

    * Parallel Scavenge 和 ParNew 一样，都是多线程、新生代垃圾收集器。但是两者有巨大的不同点：

        * Parallel Scavenge：追求 CPU 吞吐量，能够在较短时间内完成指定任务，因此适合没有交互的后台计算。

        * ParNew：追求降低用户停顿时间，适合交互式应用。

    * 达到可控制的吞吐量

        * 吞吐量: CPU用于运行用户代码的时间与CPU消耗的总时间的比值

        * 吞吐量 = (执行用户代码时间) / (执行用户代码时间 + 垃圾回收所占用的时间)

        追求高吞吐量，可以通过减少 GC 执行实际工作的时间，然而，仅仅偶尔运行 GC 意味着每当 GC 运行时将有许多工作要做，因为在此期间积累在堆中的对象数量很高。单个 GC 需要花更多的时间来完成，从而导致更高的暂停时间。而考虑到低暂停时间，最好频繁运行 GC 以便更快速完成，反过来又导致吞吐量下降。

        * 通过参数 -XX:GCTimeRadio 设置垃圾回收时间占总 CPU 时间的百分比。0 < 吞吐量大小 < 100

        * 通过参数 -XX:MaxGCPauseMillis 设置垃圾处理过程最久停顿时间, 单位是毫秒。这个值设置的小了, 机会增加频率, 所以要设置合理的值

        * 通过命令 -XX:+UseAdaptiveSizePolicy 开启自适应策略。我们只要设置好堆的大小和 MaxGCPauseMillis 或 GCTimeRadio，收集器会自动调整新生代的大小、Eden 和 Survivor 的比例、对象进入老年代的年龄，以最大程度上接近我们设置的 MaxGCPauseMillis 或 GCTimeRadio。

### 老年代垃圾收集器

1. Serial Old 垃圾收集器（单线程）

    Serial Old 收集器是 Serial 的老年代版本，都是单线程收集器，只启用一条 GC 线程，都适合客户端应用。它们唯一的区别就是：Serial Old 工作在老年代，使用“标记-整理”算法；Serial 工作在新生代，使用“复制”算法。

1. Parallel Old 垃圾收集器（多线程）

    Parallel Old 收集器是 Parallel Scavenge 的老年代版本，追求 CPU 吞吐量。

1. Cms, Concurrent Mark Sweep

    CMS(Concurrent Mark Sweep，并发标记清除)收集器是以获取最短回收停顿时间为目标的收集器（追求低停顿），它在垃圾收集时使得用户线程和 GC 线程并发执行，因此在垃圾收集过程中用户也不会感到明显的卡顿。

    工作过程:

    * 初始标记: Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记。

    * 并发标记: 使用多条标记线程，与用户线程并发执行。此过程进行可达性分析，标记出所有废弃对象。速度很慢。

    * 重新标记: Stop The World，使用多条标记线程并发执行，将刚才并发标记过程中新出现的废弃对象标记出来。

    * 并发清理: 只使用一条 GC 线程，与用户线程并发执行，清除刚才标记的对象。这个过程非常耗时。

    并发标记与并发清除过程耗时最长，且可以与用户线程一起工作，因此，总体上说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。

    优点

    * 并发收集

    * 低停顿

    缺点

    * 吞吐量低

    * 无法处理浮动垃圾，导致频繁 Full GC

    * 出现Concurrent Mode Failure

    * 占用CPU资源高

    * 使用“标记-清除”算法产生碎片空间

        **对于产生碎片空间的问题，可以通过开启 -XX:+UseCMSCompactAtFullCollection，在每次 Full GC 完成后都会进行一次内存压缩整理，将零散在各处的对象整理到一块。设置参数 -XX:CMSFullGCsBeforeCompaction告诉 CMS，经过了 N 次 Full GC 之后再进行一次内存整理。**

1. G1(标记, 整理, 清除)

    G1 是一款面向服务端应用的垃圾收集器，它没有新生代和老年代的概念，而是将堆划分为一块块独立的 Region。当要进行垃圾收集时，首先估计每个 Region 中垃圾的数量，每次都从垃圾回收价值最大的 Region 开始回收，因此可以获得最大的回收效率。

    从整体上看， G1 是基于“标记-整理”算法实现的收集器，从局部（两个 Region 之间）上看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。

    **这里抛个问题**

    **一个对象和它内部所引用的对象可能不在同一个 Region 中，那么当垃圾回收时，是否需要扫描整个堆内存才能完整地进行一次可达性分析？**

    **并不！每个 Region 都有一个 Remembered Set，用于记录本区域中所有对象引用的对象所在的区域，进行可达性分析时，只要在 GC Roots 中再加上 Remembered Set 即可防止对整个堆内存进行遍历。**

    * 优势

        * 并行与并发

        * 分代收集

        * 空间整合

        * 可预测的停顿

    * 步骤

        * 初始标记: Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记。

        * 并发标记: 使用一条标记线程与用户线程并发执行。此过程进行可达性分析，速度很慢。

        * 最终标记: Stop The World，使用多条标记线程并发执行。

        * 筛选回收(维护了一张表): 回收废弃对象，此时也要 Stop The World，并使用多条筛选回收线程并发执行。

### Major GC和Full GC

* Minor GC触发条件：当Eden区满时，触发Minor GC。

* Major: 回收老年代

* Full GC触发条件：

    * 调用System.gc时，系统建议执行Full GC，但是不必然执行

    * 老年代空间不足

    * 方法区空间不足

    * 通过Minor GC后进入老年代的平均大小大于老年代的可用内存

    * 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

## 内存分配

### 内存分配策略

* 优先分配到Eden区域

    * 如果放不下了, 会将内存放到Survivor中, Survivor中也放不下, 会放到老年代中

    * -Xmn10M, 指定新生代内存

    * -XX:SurvivorRatio=8 指定Eden内存大小

* 大对象直接分配到老年代(垃圾回收次数低)

    * -XX:PretenureSizeThreshold=10M 指定多大的内存是大内存

* 长期存活的对象分配到老年代

    * -XX:MaxTenuringThreshold 15

    * Age 1 + 1 + 1 每次GC之后对象的年龄+1

* 空间分配担保

    * -XX:+HandlePromotionFailure 是否开启空间分配担保

* 动态对象年龄

* 逃逸分析与栈上分配

    * 逃逸分析: 分析对象的作用域, 如果没有方法外部引用方法内部的对象, 就认为这个对象没有发生逃逸, 就可以把这个对象放到栈内存中

    * 栈上分配: 根据方法的执行进行分配与释放, 不需要垃圾回收, 性能高
    
    
    
    
    
    
    