---
layout: post
title: 面试题
categories: [Others]
description: 
keywords: 
---

* content
{:toc}


## 请描述 synchronized 和 reentrantlock 的底层实现及重入的底层原理

synchronized 的底层汇编还是 lock cmpxchg 命令

## 请描述锁的四种状态和升级过程

在 JDK1.2 时 synchronized 的性能非常差, 在 JDK1.6 后优化了锁的升级状态

**JDK 早期, synchronized 叫做重量级锁, 因为申请锁资源必须通过 kernel(内核), 早期 APP 可以直接系统调用底层硬件**

现代操作系统会分为两层, 内核态和用户态, 自己的 APP 就是用户态, 系统资源就是内核态, 如果用户态想访问内核态的资源需要通过 kernel 的允许, 将用户态转向内核态, 拿到结果后再从内核态返回用户态. 早期 synchronized 加锁就需要申请系统资源, 进行用户态和内核态的转换, 所以是重量级锁, 经过优化后在某些情况下不需要通过内核态就可以解决, 比如 CAS(轻量级锁), 只需要用户态就可以完成

![http://www.milky.show/images/mashibing/synchronized/syn_3.png](http://www.milky.show/images/mashibing/synchronized/syn_3.png)

### 无锁态

最后是 001

### 偏向锁

最后是 101, 用户态完成

将自己的线程号写进了 markword 上, 此时只是贴了一个自己的 id 上去, 并没有发生锁的竞争

多数 synchronized 方法, 在很多情况下, 只有一个线程在运行, 没有必要向内核态申请资源, 例如 StringBuffer 中的 sync 方法

**只要有另外的线程来竞争, 就会升级为轻量级锁**

### 轻量级锁, 自旋锁, 无锁(CAS)

最后是 00, 用户态完成

当发生了多线程争锁的情况, 哪个线程能将自己的 id 写进 markword 谁就能获得锁, 此时是在用户空间完成的 CAS 操作, 此时偏向锁的线程也会发起争锁, 但是会有一定优势

CAS 适合操作特别快或者线程数较小的情况, 因为自旋会消耗 CPU 资源

### 重量级锁

最后是 10, 需要向内核态申请

向操作系统申请锁

为什么有了自旋锁, 还需要重量级锁, 因为重量级锁不需要消耗 CPU 资源, 会将其他线程放到一个队列中(waitset),  因此不需要自旋的过程了

## CAS 的 ABA 的问题如何解决

加版本号

## 请谈一下 AQS, 为什么 AQS 的底层是 CAS + volatile

## 请谈一下你对 volatile 的理解

## volatile 的可见性和禁止指令重排序是如何实现的

## CAS 底层原理

java 中的 AtomicInteger 的 incrementAndGet() 方法会调用 unsafe 类的 incrementAndGet() 方法, 这个方法是本地 C/C++ 方法, 在 C/C++ 中使用汇编指令`cmpxchg` 实现 java 中的 cas 操作, **但是这条指令不是原子的, 所以这条指令前加入 lock 指令**, 对这一块内存加锁, 不允许其他任何的 cpu 打断, 就保证了原子性
`lock cmpxchg`

## DCL(Double Check Lock)单例为什么要加 volatile

首先讲一下对象的创建过程

![http://www.milky.show/images/java/volatile/volatile_1.png](http://www.milky.show/images/java/volatile/volatile_1.png)

1.  在堆内存中开辟一片空间, 此时 m 是默认值 0
2.  构造函数将 m 赋值为 8
3.  将 t 指向堆内存中的对象

所以实际上创建一个对象在字节码层面是分为 3 个步骤的

![http://www.milky.show/images/java/volatile/volatile_2.png](http://www.milky.show/images/java/volatile/volatile_2.png)

线程 1 在 DCL 单例中正在执行初始化过程时, **发生了指令重排序**, 导致步骤 3 比 2 先执行, 此时 m 是一个半初始化的状态, 恰巧线程 2 此时过来判断 instance != null 是成立的, 那么线程 2 就拿到了一个初始化不完全的单例对象

所以需要加 volatile 关键字, 防止指令重排序的发生

## 解释一下锁的四种状态

## 请描述一下对象的创建过程

## 对象在内存中的布局

JOL = Java Object Layout(Java 对象内存布局)

在堆内存中 new 出来一个对象, 这个对象在堆中分为四个部分

1.  markword, 8 个字节, synchronized(o) 锁定对象的本质是修改了 markword, **使 markword 包含了锁的信息**, 我们平时所说的加锁, 就是修改对象的 markword 的内容

    *   锁信息, 无锁态, 偏向锁...
    *   GC 标记信息
    *   HashCode

    ![http://www.milky.show/images/mashibing/synchronized/syn_2.png](http://www.milky.show/images/mashibing/synchronized/syn_2.png)

2.  klass poniter, 是一个指针, 指向 T.class, 表名这个对象属于哪一个 class, 压缩是 4 字节, 不压缩是 8 字节

3.  instance state, 成员变量所占的位置, byte, short, int, long...

4.  padding, 对齐, 64 位虚拟机 padding 是需要 4 块内容可以被 8 字节整除, 如果前 3 块不能被 8 整除, 就用 padding 补齐

![http://www.milky.show/images/mashibing/synchronized/syn_1.png](http://www.milky.show/images/mashibing/synchronized/syn_1.png)

## Object o = new Object() 在内存中占了多少字节

16 字节

JOL 是 openjdk 的一个工具类

Object o = new Object();
sysout ClassLayout.parseInstance(o).toPrintable();

## 请描述 synchronized 和 Reentrantlock 的异同

## 聊聊你对 as-if-serial 和 happens-before 语义的理解

as-if-serial 是看上去像同步的, CPU 为了提高效率, 会将没有依赖关系的语句打乱执行, 提高效率, 最终结果是一致的

## 你了解 ThreadLocal 吗? 你知道 ThreadLocal 如何解决内存泄露的问题吗

## 请描述一下锁的分类以及 JDK 的应用

## 自旋锁一定比重量级锁效率高吗

## 打开偏向锁是否效率一定会提升

## 偏向锁一定比自旋锁效率高吗

**偏向锁是在 JVM 启动 4s 后开启的, 因为 JVM 启动时有很多内存区域需要进行加锁, 这时已经明确知道有多线程去竞争锁, 就不需要开启偏向锁了**

很多情况下我明知道会存在锁的竞争情况, 就不需要加偏向锁了, 如果加了偏向锁还存在一个偏向锁升级的过程, 反而效率会降低



## Spring 源码

![http://www.milky.show/images/java/spring/spr_1.png](http://www.milky.show/images/java/spring/spr_1.png)

![http://www.milky.show/images/java/spring/spr_2.png](http://www.milky.show/images/java/spring/spr_2.png)