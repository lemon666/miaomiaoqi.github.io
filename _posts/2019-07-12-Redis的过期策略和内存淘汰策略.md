---
layout: post
title:  "Redis的过期策略和内存淘汰策略"
date:   2019-07-12 10:50:30
categories: NoSql
tags: Redis
author: miaoqi
---

* content
{:toc}
# Redis的 Key 过期策略

我们都知道，Redis是key-value数据库，我们可以设置Redis中缓存的key的过期时间。Redis的过期策略就是指当Redis中缓存的key过期了，Redis如何处理。

过期策略通常有以下三种：

- 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；**但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。**
- 惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。
- 定期过期：**Redis默认每隔 100ms** 会随机抽取进行检查一定数量的数据库的expires字典中的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。
     (expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)
    1. Redis配置项hz定义了serverCron任务的执行周期，默认为10，即CPU空闲时每秒执行10次
    2. 每次过期key清理的时间不超过CPU时间的25%，即若hz=1，则一次清理时间最大为250ms，若hz=10，则一次清理时间最大为25ms
    3. 清理时依次遍历所有的db
    4. 从db中随机取20个key，判断是否过期，若过期，则逐出
    5. 若有5个以上key过期，则重复步骤4，否则遍历下一个db
    6. 在清理过程中，若达到了25%CPU时间，退出清理过程

**Redis采用的是定期删除+惰性删除策略**

* 如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。

    在redis.conf中有一行配置

    ```
    # maxmemory-policy volatile-lru
    ```

    该配置就是配内存淘汰策略的

# Redis的内存淘汰策略

Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。。

- noeviction(默认)：当内存不足以容纳新写入数据时，新写入操作会报错, 读和删除可继续。**应该没人用吧**
- allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。**推荐使用，目前项目在用这种**
- allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。**你不删最少使用Key,去随机删**
- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。**这种情况一般是把redis既当缓存，又做持久化存储的时候才用**
- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。**依然不推荐**
- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。**不推荐**

**如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。**

## Redis LRU近似算法

Redis 使用的是一种近似 LRU 算法：

1. key增加最近访问时间戳字段

2. 选取一定数量的key（默认5，server.maxmemory_samples进行配置），比较最近访问时间。按照LRU算法淘汰key。

当 Redis 执行写操作时，发现内存超出 maxmemory，就会执行一次 LRU 淘汰算法。

注意：maxmemory_samples的值越大，Redis的近似LRU算法就越接近于严格LRU算法（队列结构重排，批量非热点数据缓存垃圾），但是相应消耗也变高，对性能有一定影响，样本值默认为5。

