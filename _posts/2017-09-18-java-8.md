---
layout: post
title: "Java8新特性"
date: 2017-09-18 19:48:50
categories: Language
tags: Java
author: miaoqi
---

* content
{:toc}      
    

## Java8新特性简介

* 速度更快(底层数据结构改变)

    * HashMap

        1.7: 数组 + 链表

        1.8: 数组 + 链表 + 红黑树

    * 内存结构

        1.7: 栈内存, 堆内存, 方法区(堆内存中永久区的一部分), PremGenSize, MaxPremGenSize

        1.8: 栈内存, 堆内存, MetaSpace(元空间, 使用物理内存), MetaSpaceSize, MaxMetaSpaceSize

* 代码更少(增加了Lambda表达式)

* 强大的Stream API

* 便于并行

* 最大化减少空指针异常 Optional
    
## Lambda表达式(核心)

* Lambda 是一个匿名函数, 我们可以把 Lambda 表达式理解为是一段可以传递的代码(将代码 像数据一样进行传递)。可以写出更简洁、更 灵活的代码。作为一种更紧凑的代码风格, 使 Java的语言表达能力得到了提升。

* 从匿名类到Lambda的转换

        // 原来的匿名内部类
        @Test
        public void test1() {
            Comparator<Integer> com = new Comparator<Integer>() {
                @Override
                public int compare(Integer o1, Integer o2) {
                    return Integer.compare(o1, o2);
                }
            };
        }
    
        // Lambda表达式
        @Test
        public void test2() {
            Comparator<Integer> com = (o1, o2) -> Integer.compare(o1, o2);
        }

### 语法

* Lambda 表达式在Java 语言中引入了一个新的语法元 素和操作符。这个操作符为 “->” ,  该操作符被称 为 Lambda 操作符或剪头操作符。它将 Lambda 分为 两个部分:左侧:指定了 Lambda 表达式需要的所有参数 右侧:指定了 Lambda 体, 即 Lambda 表达式要执行 的功能。

* 语法格式

    语法格式一: 无参, 无返回值, Lambda 体只需一条语句

        Runnable r1 = () -> System.out.println("Hello Lambda!");
    语法格式二: Lambda 需要一个参数, 无返回值

        Consumer<String> fun = (args) -> System.out.println(args);
    语法格式三: Lambda 只需要一个参数时, 参数的小括号可以省略

        Consumer<String> fun = args -> System.out.println(args);

    语法格式四: Lambda 需要两个参数, 并且有返回值 
        BinaryOperator<Long> bo = (x, y) -> {
            System.out.println("实现函数接口方法!");
            return x + y;
        }

    语法格式五: 当 Lambda 体只有一条语句时, return 与大括号可以省略

        BinaryOperator<Long> bo = (x, y) -> x + y;

    语法格式六: 数据类型可以省略, 因为可由编译器推断得出, 称为"类型推断"

        BinaryOperator<Long> bo = (Long x, Long y) -> {
            System.out.println("实现函数接口方法!");
            return x + y;
        }

* 类型推断

    上述 Lambda 表达式中的参数类型都是由编译器推断 得出的。Lambda 表达式中无需指定类型, 程序依然可 以编译, 这是因为 javac 根据程序的上下文, 在后台 推断出了参数的类型。Lambda 表达式的类型依赖于上 下文环境, 是由编译器推断出来的。这就是所谓的 “类型推断” 

## 函数式接口

* 只包含一个抽象方法的接口, 称为函数式接口。* 你可以通过 Lambda 表达式来创建该接口的对象。(若 Lambda表达式抛出一个受检异常, 那么该异常需要在目标接口的抽象方法上进行声明)。* 我们可以在任意函数式接口上使用 @FunctionalInterface 注解, 这样做可以检查它是否是一个函数式接口, 同时 javadoc 也会包 含一条声明, 说明这个接口是一个函数式接口。

### 语法

* 自定义函数式接口

        @FunctionInterface
        public interface MyNumber{
            public double getValue();
        }

* 函数式接口中使用泛型

        @FunctionInterface
        public interface MyNumber<T>{
            public T getValue(T t);
        }

* 作为参数传递Lambda表达式

        public String toUpperString(MyFun<String> mf, String str){
            return mf.getValue(str);
        }
        
        作为参数传递
        
        String newStr = toUpperString((str) -> str.toUpperCase, "abcd");
        System.out.println(newStr);


    **作为参数传递 Lambda 表达式:为了将 Lambda 表达式作为参数传递, 接 收Lambda 表达式的参数类型必须是与该 Lambda 表达式兼容的函数式接口 的类型。**

### Java内置四大核心函数式接口

|函数式接口|参数类型|返回类型|用途|
|--------|-----|-------|-----|
|Consumer<T><br/>消费型接口|T|void|对类型为T的对象应用操作<br/>包含方法: void accept(T t);|
|Supplier<T><br/>供给型接口|无|T|返回类型为T的对象<br/>包含方法: T get();|
|Function<T, R><br/>函数型接口|T|R|对类型为T的对象应用操作<br/>并返回结果是R类型的对象<br/>包含方法: R apply(T t);|
|Predicate<T><br/>断定型接口|T|boolean|确定类型为T的对象是否满足某约束<br/>并返回boolean值<br/>包含方法: boolean test(T t);|

### 其他接口

|函数式接口|参数类型|返回类型|用途|
|--------|-----|-------|-----|
|BiFunction<T, U, R>|T, U|R|对类型为 T, U 参数应用操作<br/>返回R类型的结果<br/>包含方法: R apply(T t, U u);||UnaryOperator<T><br/>(Function子接口)|T|T|对类型为T的对象进行一元运算<br/>并返回T类型的结果<br/>包含方法为: T apply(T t);||BinaryOperator<T><br/>(BiFunction子接口)|T, T|T|对类型为T的对象进行二 元运算<br/>并返回T类型的结果<br/>包含方法为: T apply(T t1, T t2);||BiConsumer<T, U>|T, U|void|对类型为T, U 参数应用操作<br/>包含方法为: void accept(T t, U u);||ToIntFunction<T><br/>ToLongFunction<T><br/>ToDoubleFunction<T>|T|int<br/>long<br/>double|分别计算int、long、 double、值的函数||IntFunction<R><br/>LongFunction<R><br/>DoubleFunction<R>|int<br/>long<br/>double|R|参数分别为int、long、 double 类型的函数|

## 方法引用与构造器引用

### 方法引用

* 当要传递给Lambda体的操作, 已经有实现的方法了, 可以使用方法引用! (实现抽象方法的参数列表, 必须与方法引用方法的参数列表保持一致!) 方法引用:使用操作符 “::” 将方法名和对象或类的名字分隔开来。 如下三种主要使用情况:

    对象::实例方法

    类::静态方法

    类::实例方法

* 例1:

        (x) -> System.out.println(x);
        等同于:
        System.out::println

* 例2:

        BinaryOperator<Double> bo = (x, y) -> Math.pow(x, y);
        等同于:
        BinaryOperator<Double> bo = Math::pow;

* 例3:

        compare((x, y) -> x.equals(y), "abcdef", "abcdef");
        等同于:
        compare(String::equals, "abc", "abc")

    **注意：       
    ①方法引用所引用的方法的参数列表与返回值类型，需要与函数式接口中抽象方法的参数列表和返回值类型保持一致！     
    ②若Lambda 的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，格式： ClassName::MethodName**

### 构造器引用(ClassName::new)

* 与函数式接口相结合, 自动与函数式接口中方法兼容. 可以把构造器引用赋值给定义的方法, 与构造器参数列表要与接口中抽象方法的参数列表一致!

* 例1:

        Function<Integer, MyClass> fun = n -> new MyClass(n);
        等同于:
        Function<Integer, MyClass> fun = MyClass::new;

### 数组引用(type[]::new)

* 例1:

        Function<Integer, Integer[]> fun = n -> new Integer[n];
        等同于:
        Function<Integer, Integer[]> fun = n -> Integer[]::new;

## Stream API(核心)

* Java8中有两大最为重要的改变。第一个是 Lambda 表达式;另外一 个则是 Stream API(java.util.stream.*)。     * Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对 集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数 据库查询。也可以使用 Stream API 来并行执行操作。简而言之， Stream API  供了一种高效且易于使用的处理数据的方式

### 什么是 Stream
* 是数据渠道，用于操作数据源(集合、数组等)所生成的元素序列。* “集合讲的是数据，流讲的是计算!”     
    **注意:          Stream 自己不会存储元素。         Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。      
    Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。**

###  Stream 的操作三个步骤   
* 创建 Stream   中间操作

    一个数据源(如:集合、数组)，获取一个流

* 中间操作

    一个中间操作链，对数据源的数据进行处理

* 终止操作(终端操作)

    一个终止操作，执行中间操作链，并产生结果

### 由Collection接口创建流

Java8 中的 Collection 接口被扩展，提供了两个获取流的方法

* default Stream<E> stream() : 返回一个顺序流
* default Stream<E> parallelStream() : 返回一个并行流

### 由数组创建流

Java8 中的 Arrays 的静态方法 stream() 可以获取数组流

* static <T> Stream<T> stream(T[] array): 返回一个流
* public static IntStream stream(int[] array)
* public static LongStream stream(long[] array)
* public static DoubleStream stream(double[] array)

### 由值创建流

可以使用静态方法 Stream.of(), 通过显示值 创建一个流。它可以接收任意数量的参数

* public static<T> Stream<T> of(T... values) : 返回一个流

### 由函数创建流, 创建无限流

可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流

* 迭代

    public static<T> Stream<T> iterate(final T seed, final UnaryOperator<T> f)

* 生成

    public static<T> Stream<T> generate(Supplier<T> s)

### Stream的中间操作

多个中间操作可以连接起来形成一个流水线，除非流水 线上触发终止操作，否则中间操作不会执行任何的处理! 而在终止操作时一次性全部处理，称为“惰性求值”

* 筛选与切片

    |方法|描述|
    |---|----|
    |filter(Predicate p)|接收Lambda，从流中排除某些元素。|
    |distinct()|筛选，通过流所生成元素的hashCode()和equals()<br/>去除重复元素|
    |limit(long maxSize)|截断流，使其元素不超过给定数量。|
    |skip(long n)|跳过元素，返回一个扔掉了前 n 个元素的流。<br/>若流中元素 不足 n 个，则返回一个空流。与 limit(n) 互补|

* 映射

    |方法|描述|
    |---|----|
    |map(Function f)|该函数会被应用到每个元素上，<br/>并将其映射成一个新的元素。|
    |mapToDouble(ToDoubleFunction f)|该函数会被应用到每个元 素上，<br/>产生一个新的 DoubleStream|
    |mapToInt(ToIntFunction f)|该函数会被应用到每个元素上，<br/>产生一个新的 IntStream。|
    |mapToLong(ToLongFunction f)|该函数会被应用到每个元素上，<br/>产生一个新的 LongStream。|
    |flatMap(Function f)|将流中的每个值都换成另一个流，<br/>然后把所有流连接成一个流|

* 排序

    |方法|描述|
    |---|----|
    |sorted()|产生一个新流，其中按自然顺序排序|
    |sorted(Comparator comp)|产生一个新流，其中按比较器顺序排序|

### Stream的终止操作

* 终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如:List、Integer，甚至是 void 。

* 查找与匹配

    |方法|描述|
    |---|----|
    |allMatch(Predicate p)|检查是否匹配所有元素|
    |anyMatch(Predicate p)|检查是否至少匹配一个元素|
    |noneMatch(Predicate p)|检查是否没有匹配所有元素|
    |findFirst()|返回第一个元素|
    |findAny()|返回当前流中的任意元素|
    |count()|返回流中元素总数|
    |max(Comparator c)|返回流中最大值|
    |min(Comparator c)|返回流中最小值|
    |forEach(Consumer c)|内部迭代(使用 Collection 接口需要用户去做迭 代，称为外部迭代。<br/>相反，Stream API 使用内部 迭代——它帮你把迭代做了)|

* 归约

    |方法|描述|
    |---|----|
    |reduce(T iden, BinaryOperator b)|可以将流中元素反复结合起来，<br/>得到一个值。 返回 T|
    |reduce(BinaryOperator b)|可以将流中元素反复结合起来，<br/>得到一个值。 返回 Optional<T>|

    **备注:map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名。**

* 收集

    |方法|描述|
    |---|----|
    |collect(Collector c)|接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法|

    Collector 接口中方法的实现决定了如何对流执行收集操作(如收 集到 List、Set、Map)。但是 Collectors 实用类 供了很多静态 方法，可以方便地创建常见收集器实例，具体方法与实例如下表:

    <table>
        <tr>
            <th>方法</th>
            <th>返回类型</th>
            <th>作用</th>
        </tr>
        <tr>
            <td>toList</td>
            <td>List&lt;T&gt;</td>
            <td>把流中元素收集到List</td>
        </tr>
        <tr>
            <td colspan="3">List&lt;Employee&gt; emps= list.stream().collect(Collectors.toList());</td>
        </tr>
        <tr>
            <td>toSet</td>
            <td>Set&lt;T&gt;</td>
            <td>把流中元素收集到Set</td>
        </tr>
        <tr>
            <td colspan="3">Set&lt;Employee&gt; emps= list.stream().collect(Collectors.toSet());</td>
        </tr>
        <tr>
            <td>toCollection</td>
            <td>Collection&lt;T&gt;</td>
            <td>把流中元素收集到创建的集合</td>
        </tr>
        <tr>
            <td colspan="3">Collection&lt;Employee&gt; emps=list.stream().collect(Collectors.toCollection(ArrayList::new));</td>
        </tr>
        <tr>
            <td>counting</td>
            <td>Long</td>
            <td>计算流中元素的个数</td>
        </tr>
        <tr>
            <td colspan="3">long count = list.stream().collect(Collectors.counting());</td>
        </tr>
        <tr>
            <td>summingInt</td>
            <td>Integer</td>
            <td>对流中元素的整数属性求和</td>
        </tr>
        <tr>
            <td colspan="3">int total = list.stream().collect(Collectors.summingInt(Employee::getSalary));</td>
        </tr>
        <tr>
            <td>averagingInt</td>
            <td>Double</td>
            <td>计算流中元素Integer属性的平均 值</td>
        </tr>
        <tr>
            <td colspan="3">double avg = list.stream().collect(Collectors.averagingInt(Employee::getSalary));</td>
        </tr>
        <tr>
            <td>summarizingInt</td>
            <td>IntSummaryStatistics</td>
            <td>收集流中Integer属性的统计值。 如:平均值</td>
        </tr>
        <tr>
            <td colspan="3">Int SummaryStatisticsiss = list.stream().collect(Collectors.summarizingInt(Employee::getSalary));</td>
        </tr>
        <tr>
            <td>joining</td>
            <td>String</td>
            <td>连接流中每个字符串</td>
        </tr>
        <tr>
            <td colspan="3">String str= list.stream().map(Employee::getName).collect(Collectors.joining());</td>
        </tr>
        <tr>
            <td>maxBy</td>
            <td>Optional&lt;T&gt;</td>
            <td>根据比较器选择最大值</td>
        </tr>
        <tr>
            <td colspan="3">Optional&lt;Emp&gt; max = list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));</td>
        </tr>
        <tr>
            <td>minBy</td>
            <td>Optional&lt;T&gt;</td>
            <td>根据比较器选择最小值</td>
        </tr>
        <tr>
            <td colspan="3"> Optional&lt;Emp&gt; min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));</td>
        </tr>
        <tr>
            <td>reducing</td>
            <td>归约产生的类型</td>
            <td>从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值</td>
        </tr>
        <tr>
            <td colspan="3"> int total = list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum));</td>
        </tr>
        <tr>
            <td>collectingAndThen</td>
            <td>转换函数返回的类型</td>
            <td>包裹另一个收集器，对其结果转换函数</td>
        </tr>
        <tr>
            <td colspan="3"> int how =  list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));</td>
        </tr>
        <tr>
            <td>groupingBy</td>
            <td>Map&lt;K, List&lt;T&gt;&gt;</td>
            <td>根据某属性值对流分组，属 性为K，结果为V</td>
        </tr>
        <tr>
            <td colspan="3">Map&lt;Emp.Status, List&lt;Emp&gt;&gt; map = list.stream().collect(Collectors.groupingBy(Employee::getStatus));</td>
        </tr>
        <tr>
            <td>partitioningBy</td>
            <td>Map&lt;Boolean, List&lt;T&gt;&gt;</td>
            <td>根据true或false进行分区</td>
        </tr>
        <tr>
            <td colspan="3">Map&lt;Boolean,List&lt;Emp&gt;&gt; vd = list.stream().collect(Collectors.partitioningBy(Employee::getManage));</td>
        </tr>
    </table>

### 并行流与串行流

* 并行流就是把一个内容分成多个数据块，并用不同的线程分 别处理每个数据块的流。

* Java 8 中将并行进行了优化，我们可以很容易的对数据进行并 行操作。Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换。

### Fork/Join框架

* Fork/Join 框架:

    就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务(拆到不可再拆时)，再将一个个的小任务运算的结果进行 join 汇总

* Fork/Join 框架与传统线程池的区别

    采用 “工作窃取”模式(work-stealing): 当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。    相对于一般的线程池实现,fork/join框架的优势体现在对其中包含的任务的处理方式上.在一般的线程池中,如果一个线程正在执行的任务由于某些原因无法继续运行,那么该线程会处于等待状态.而在fork/join框架实现中,如果某个子问题由于等待另外一个子问题的完成而无法继续运行.那么处理该子 问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程的等待时间, 提高了性能

## Optional类

Optional<T> 类(java.util.Optional) 是一个容器类，代表一个值存在或不存在， 原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。     * 常用方法:    * Optional.of(T t) : 创建一个 Optional 实例    * Optional.empty() : 创建一个空的 Optional 实例    * Optional.ofNullable(T t):若 t 不为 null,创建 Optional 实例,否则创   建空实例
    * isPresent() : 判断是否包含值    * orElse(T t) : 如果调用对象包含值，返回该值，否则返回t    * orElseGet(Supplier s) :如果调用对象包含值，返回该值，否则返回 s 获取的值
    * map(Function f): 如果有值对其处理，并返回处理后的Optional，否则返回      Optional.empty()
    * flatMap(Function mapper):与 map 类似，要求返回值必须是Optional

## 接口中的默认方法与静态方法

### 接口中的默认方法

* Java 8中允许接口中包含具有具体实现的方法，该方法称为 “默认方法”，默认方法使用 default 关键字修饰。
        interface MyFun<T>{
            T func(int a);
            
            default String getName(){
                return "Hello Java8!";
            }
        }

* 接口默认方法的”类优先”原则    若一个接口中定义了一个默认方法，而另外一个父类或接口中 又定义了一个同名的方法时  
    * 选择父类中的方法。如果一个父类提供了具体的实现，那么 接口中具有相同名称和参数的默认方法会被忽略。    * 接口冲突。如果一个父接口 供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法(不管方法是否是默认方法)，那么必须覆盖该方法来解决冲突

## 新时间日期API

## 其他新特性

### 重复注解与类型注解
        
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    