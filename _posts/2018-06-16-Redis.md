---
layout: post
title:  "Redis学习"
date:   2018-06-14 15:12:38
categories: NoSql
tags: Redis
author: miaoqi
---

* content
{:toc}
            

## Redis笔记

### 简介

* Redis是非关系型数据库, 即NoSql数据库, 存储的数据模型是key-value, 特点是访问速度快

### 数据结构

1. String类型, value只能是String类型

1. Hash类型, 可以对key进行分类

1. List类型, 所有元素是有序的
    
1. Set类型, 元素是无序的, 元素不能重复. 并集, 交集, 差集
    
1. SortedSet, 有序的set, 元素不能重复且有序
    
### Redis持久化的机制

1. RDB快照

    * 把内存中的数据来一份一模一样的放在硬盘中, 会丢失掉最后一部分存储的数据, 适合大规模的数据恢复, 对数据完整性和一致性要求不高, 默认是这种方式

    * Redis会单独创建(fork)一个子进程来进行持久化, 会先将数据写入到一个临时文件中, 待持久化过程结束后, 再用这个临时文件替换上次持久化的文件, 整个过程中, 主进程不进行任何IO操作, 这就确保了极高的性能

    * 隐患:

        若当前的进程数据量庞大, fork之后数据量*2, 会造成服务器压力过大

    * save 900 1: 900秒内1次操作会备份

    * save 60 10000: 60秒内10000次操作会备份

    * save "": 不备份

1. AOF保存命令日志

    * 把每一条对redis的写操作命令, 也支持每秒同步和不同步, 保存到类似日志文件中文件采用Redis协议的格式来保存, 新命令会追加到文件末尾, 配置文件中appendonly yes开启aof持久化, 日志文件过大新增了重写机制, 相同数据集而言, aof文件要远大于rdb文件, 恢复速度慢于rdb, 运行效率也要慢于rdb文件

* 如果只做缓存, 可以不适用任何持久化方式

* 如果两个持久化方案同时开启, 优先采用aof方式, 因为aof保存的数据要比rdb完整

* 建议同时开启rdb和aof, rdb适合备份数据库, 因为aof在不断变化, 不好备份, 可以快速重启, 作为以防万一的手段

### 集群

* 所有的redis节点之间都是互联的(ping-pong机制)

* 节点的fail是通过集群中超过半数的节点检测失效时才生效

* 客户端与redis节点直连, 不需要中间proxy层, 客户端不需要连接集群所有节点, 连接集群中任何一个可用节点即可

* redis-cluster把所有的物理节点映射到[0-16383]slot上, cluster负责维护nodes<>slot<>value

* 单节点fail: 所有master节点投票, 如果超过半数就认为节点挂掉

* 集群fail: 集群任意master挂掉, 如果没有slave集群进入fail状态, 也可以理解为集群挂掉, 如果集群半数以上master挂掉, 无论是否有slave, 集群都进入fail状态

* 集群搭建: 3主3从, 复制6份配置文件, 修改端口号, 开启集群模式, 安装ruby环境, 启动6台机器, 开启集群模式(src目录下命令)    
    ./redis-trib.rb create --replicas 1 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006     
    可以使用-c命令连接任一节点
    
* 增删节点: 

    * 增加节点: 首先建立一个节点, 直接启动这个节点, 要保证这个redis实例没有存储过数据, 没有持久化文件, 执行命令./redis-trib add-node127.0.0.1:7007 to cluster 127.0.0.1:7001添加到集群中, 随便进入到一个集群节点中, 执行 ./redis-trib.rb reshard 192.168.20.140:7001, 会问将多少个槽点移走, 在创建新的实例, 启动以后我们只命令./redis-trib.rb add-node --slave127.0.0.1:7008  127.0.0.1:7007, 然后我们在执行，cluster nodes 命令，就会发现新添加的节点已经作为7007 备份节点开始工作了！

    * 删除节点: 从节点直接删除就可以, 主节点首先执行 redis-trib.rb reshard 192.168.139.30:7000(接收哈希槽的节点), 随后会提示接受哈希槽的node ID: 即192.168.139.30:7000的node ID转移哈希槽的node ID，然后再输入done 表示输入完毕, 然后删除节点就可以了。
redis-trib.rb del-node 192.168.139.30:7003 0a2e35cc593e8fcc0c0ebf382333d8cc66cd8a43 
0a2e35cc593e8fcc0c0ebf382333d8cc66cd8a43 ：待删除节点的node ID。

### 主从

* 主从策略: 

    主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。

* 全量同步: 

    Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下：     
　　1）从服务器连接主服务器，发送SYNC命令；      
　　2）主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；      
　　3）主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；      
　　4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；      
　　5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；     
　　6）从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；

* 增量同步:

    Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。

### 故障

1. 缓存雪崩

    * 定义

        * 由于缓存层承载着大量请求，有效的保护了存储层，但是如果缓存层由于某些原因整体不能提供服务，于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况

    * 解决方法

        * 保证缓存层服务高可用性, 例如Redis Sentinel 和 Redis Cluster 都实现了高可用

        * 赖隔离组件为后端限流并降级, 对重要的资源(如 Redis、 MySQL、 Hbase、外部接口)都进行隔离, 让每种资源都单独运行在自己的线程池中

1. 缓存穿透

    * 定义

        * 缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中

        * 缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义

    * 造成缓存穿透的原因

        * 业务自身代码或者数据出现问题

        * 一些恶意攻击、爬虫等造成大量空命中

    * 解决方法

        * 缓存空对象, 空值做缓存, 即缓存层中存了更多的键, 这就需要更多的内存空间, 可以对其设置一个较短的过期时间, 让其自动清除, 优点是实时性高, 代码维护简单

        * 布隆过滤器拦截, 如果布隆过滤器认为某个键不存在, 那么就不会访问存储层, 适用于数据命中不高, 数据相对固定实时性低（通常是数据集较大）的应用场景, 代码维护较为复杂，但是缓存空间占用少

1. 热点key重建

### 备份

* RDB 文件一旦被创建， 就不会进行任何修改。 当服务器要创建一个新的 RDB 文件时， 它先将文件的内容保存在一个临时文件里面， 当临时文件写入完毕时， 程序才使用 rename(2) 原子地用临时文件替换原来的 RDB 文件。这也就是说， 无论何时， 复制 RDB 文件都是绝对安全的。创建一个定期任务（cron job）， 每小时将一个 RDB 文件备份到一个文件夹， 并且每天将一个 RDB 文件备份到另一个文件夹。




    
    
    
    
    
    
    
    
    
    