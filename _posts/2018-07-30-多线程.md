---
layout: post
title:  "多线程"
date:   2018-07-30 13:32:21
categories: Java
tags: Thread
author: miaoqi
---

* content
{:toc}

## 多线程

1. 多线程的实现方式

    * 继承Thread类, 重写run方法

    * 方式二: 实现Runnable接口, 作为参数构造Thread类

    * 方式三: 实现Callable接口, 相较于实现 Runnable 接口的方式, 方法可以有返回值, 并且可以抛出异常

    * 方式四: 线程池

1. 解决线程安全问题:

    * 方式一: 同步代码块

    * 方式二: 同步方法

    * 方式三: 1.5以后出现的同步锁(Lock)

1. 线程状态转换

![](http://www.miaomiaoqi.cn/images/thread/thread_transfer1.png)

![](http://www.miaomiaoqi.cn/images/thread/thread_transfer2.png)

1. 新建(new)：新创建了一个线程对象。

2. 可运行(runnable)：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。

3. 运行(running)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。

4. 阻塞(block)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： 

    * 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。

    * 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。

    * 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。

5. 死亡(dead)：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生

    
## 线程池

在web开发中，服务器需要接受并处理请求，所以会为一个请求来分配一个线程来进行处理。如果每次请求都新创建一个线程的话实现起来非常简便，但是存在一个问题：

如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。

那么有没有一种办法使执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？

这就是线程池的目的了。线程池为线程生命周期的开销和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。

**什么时候使用线程池？**

* 单个任务处理时间比较短

* 需要处理的任务数量很大

**使用线程池的好处**

* 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

* 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。

* 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

Java中的线程池是用ThreadPoolExecutor类来实现的

![](http://www.miaomiaoqi.cn/images/thread/executor_1.png)

    
    
    
    
    
    
    
    
    