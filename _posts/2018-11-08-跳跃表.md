---
layout: post
title: "跳跃表"
categories: [DataStructure]
description:
keywords:
---

* content
{:toc} 
## 跳跃表(skiplist)

在内存中维护数据集合, 按照顺序进行有序排序, 这一列表是线性的, 最容易表达线性结构的自然是数组和链表. 可是, 无论是数组还是链表, 在插入新数据的时候, 都会存在性能问题. 

如果使用数组, 插入新商品的方式如下

<img src="http://www.milky.show/images/algorithm/jump/jump_1.png" alt="http://www.milky.show/images/algorithm/jump/jump_1.png" style="zoom: 50%;" />

如果要插入一个等级是3的商品, 首先要知道这个商品应该插入的位置. 使用二分查找可以最快定位, 这一步时间复杂度是O(logN). 

插入过程中, 原数组中所有大于3的商品都要右移, 这一步时间复杂度是O(N). 所以总体时间复杂度是O(N). 

如果使用链表, 插入新商品的方式如下

<img src="http://www.milky.show/images/algorithm/jump/jump_2.png" alt="http://www.milky.show/images/algorithm/jump/jump_2.png" style="zoom: 50%;" />

如果要插入一个等级是3的商品, 首先要知道这个商品应该插入的位置. 链表无法使用二分查找, 只能和原链表中的节点逐一比较大小来确定位置. 这一步的时间复杂度是O(N). 

插入的过程倒是很容易, 直接改变节点指针的目标, 时间复杂度O(1). 因此总体的时间复杂度也是O(N). 

这对于拥有几十万商品的集合来说, 这两种方法显然都太慢了. 



SkipList(跳跃表)是一种支持快速查找的数据结构, 插入、查找和删除操作都仅仅只需要O(logN)对数级别的时间复杂度, 它的效率甚至可以与红黑树等二叉平衡树相提并论, 而且实现的难度要比红黑树简单多了. 

SkipList 主要思想是将链表与二分查找相结合, 它维护了一个多层级的链表结构(用空间换取时间), 可以把Skip List看作一个含有多个行的链表集合, 每一行就是一条链表, 这样的一行链表被称为一层, 每一层都是下一层的”快速通道”, 即如果x层和y层都含有元素a, 那么x层的a会与y层的a相互连接(垂直). 最底层的链表是含有所有节点的普通序列, 而越接近顶层的链表, 含有的节点则越少. 

<img src="http://www.milky.show/images/algorithm/jump/jump_3.png" alt="http://www.milky.show/images/algorithm/jump/jump_3.png" style="zoom: 50%;" />