---
layout: post
title: "跳跃表"
categories: [DataStructure]
description:
keywords:
---

* content
{:toc} 
## 跳跃表(skiplist)

在内存中维护数据集合, 按照顺序进行有序排序, 这一列表是线性的, 最容易表达线性结构的自然是数组和链表. 可是, 无论是数组还是链表, 在插入新数据的时候, 都会存在性能问题. 

如果使用数组, 插入新商品的方式如下

<img src="http://www.milky.show/images/algorithm/jump/jump_1.png" alt="http://www.milky.show/images/algorithm/jump/jump_1.png" style="zoom: 50%;" />

如果要插入一个等级是3的商品, 首先要知道这个商品应该插入的位置. 使用二分查找可以最快定位, 这一步时间复杂度是O(logN). 

插入过程中, 原数组中所有大于3的商品都要右移, 这一步时间复杂度是O(N). 所以总体时间复杂度是O(N). 

如果使用链表, 插入新商品的方式如下

<img src="http://www.milky.show/images/algorithm/jump/jump_2.png" alt="http://www.milky.show/images/algorithm/jump/jump_2.png" style="zoom: 50%;" />

如果要插入一个等级是3的商品, 首先要知道这个商品应该插入的位置. 链表无法使用二分查找, 只能和原链表中的节点逐一比较大小来确定位置. 这一步的时间复杂度是O(N). 

插入的过程倒是很容易, 直接改变节点指针的目标, 时间复杂度O(1). 因此总体的时间复杂度也是O(N). 

这对于拥有几十万商品的集合来说, 这两种方法显然都太慢了. 



SkipList(跳跃表)是一种支持快速查找的数据结构, 插入、查找和删除操作都仅仅只需要O(logN)对数级别的时间复杂度, 它的效率甚至可以与红黑树等二叉平衡树相提并论, 而且实现的难度要比红黑树简单多了. 

SkipList 主要思想是将链表与二分查找相结合, 它维护了一个多层级的链表结构(用空间换取时间), 可以把Skip List看作一个含有多个行的链表集合, 每一行就是一条链表, 这样的一行链表被称为一层, 每一层都是下一层的”快速通道”, 即如果x层和y层都含有元素a, 那么x层的a会与y层的a相互连接(垂直). 最底层的链表是含有所有节点的普通序列, 而越接近顶层的链表, 含有的节点则越少. 

<img src="http://www.milky.show/images/algorithm/jump/jump_11.png" alt="http://www.milky.show/images/algorithm/jump/jump_11.png" style="zoom: 50%;" />

对一个目标元素的搜索会从顶层链表的头部元素开始, 然后遍历该链表, 直到找到元素大于或等于目标元素的节点, 如果当前元素正好等于目标, 那么就直接返回它. 如果当前元素小于目标元素, 那么就垂直下降到下一层继续搜索, 如果当前元素大于目标或到达链表尾部, 则移动到前一个节点的位置, 然后垂直下降到下一层. 正因为Skip List的搜索过程会不断地从一层跳跃到下一层的, 所以被称为跳跃表. 

Skip List还有一个明显的特征, 即它是一个不准确的概率性结构, 这是因为Skip List在决定是否将节点冗余复制到上一层的时候(而在到达或超过顶层时, 需要构建新的顶层)依赖于一个概率函数, 举个栗子, 我们使用一个最简单的概率函数：丢硬币, 即概率P为0.5, 那么依赖于该概率函数实现的Skip List会不断地”丢硬币”, 如果硬币为正面就将节点复制到上一层, 直到硬币为反. 



首先思考一件事, 如何更快的查找一个有序链表的某一节点呢, 我们可以利用类似索引的思想, 提取出链表中的部分关键节点, 不如给定一个长度是7的有序链表, 1->2->3->5->6->7->8, 那么我们可以提取出所有值为奇数节点作为关键节点

<img src="http://www.milky.show/images/algorithm/jump/jump_3.png" alt="http://www.milky.show/images/algorithm/jump/jump_3.png" style="zoom: 50%;" />

此时如果要插入一个值是4的新节点, 不再需要和原节点的8,7,6,5,3逐一比较, 只需要比较关键节点7,5,3

<img src="http://www.milky.show/images/algorithm/jump/jump_4.png" alt="http://www.milky.show/images/algorithm/jump/jump_4.png" style="zoom:50%;" />

确定了新节点在关键节点中的位置(3和5之间), 就可以回到原链表, 迅速定位到对应的位置插入(恰巧同样是3和5)

<img src="http://www.milky.show/images/algorithm/jump/jump_5.png" alt="http://www.milky.show/images/algorithm/jump/jump_5.png" style="zoom:50%;" />

我们可以进一步思考, 既然已经提取出了一层关键节点作为索引, 那我们为何不能从索引中进一步提取, 提出一层索引的索引

<img src="http://www.milky.show/images/algorithm/jump/jump_6.png" alt="http://www.milky.show/images/algorithm/jump/jump_6.png" style="zoom:50%;" />

有了2级索引后, 新的节点可以先和2级索引比较, 确定大体范围, 然后在和1级索引比较, 最后再回到原链表, 找到并插入对应位置, 当节点很多的时候, 比较次数会减少到四分之一

当节点足够多的时候, 我们不止可以提出两层索引, 还可以向更高层次提取, 保证每一层是上一层节点数的一半, **至于提取的极限则是同一层只有两个节点的时候, 因为一个节点没有比较的意义, 这样的多层链表结构就是所谓的跳跃表**

当大量的新节点通过逐层比较, 最终插入到原链表之后, 上层的索引节点会渐渐变得不够用,
这时候需要从新节点中选取一部分提到上一层, 可究竟应该提拔谁忽略谁呢?关于这一点, 跳跃表的设计者采用了一种有趣的办法**[抛硬币]**, 也就是随机决定新节点是否提拔, 每向上提拔一层的几率是50%

假如值为9的新节点插入原链表

<img src="http://www.milky.show/images/algorithm/jump/jump_7.png" alt="http://www.milky.show/images/algorithm/jump/jump_7.png" style="zoom:50%;" />

<img src="http://www.milky.show/images/algorithm/jump/jump_8.png" alt="http://www.milky.show/images/algorithm/jump/jump_8.png" style="zoom:50%;" />

<img src="http://www.milky.show/images/algorithm/jump/jump_9.png" alt="http://www.milky.show/images/algorithm/jump/jump_9.png" style="zoom:50%;" />

因为跳跃表的删除和增加节点是不可预测的, 很难用一种有效的算法保证跳跃表索引分布的始终均匀, 随机抛硬币法虽然不能保证绝对分布, 但能保证大体趋于均匀

**总结一下跳跃表的插入分为如下几个步骤**

1. 新节点和各层索引节点逐一比较, 确定原链表的插入位置. O(logN)

1. 把索引插入到原链表. O(1)

1. 利用抛硬币的随机方式, 决定新节点是否提升为上一级索引. 结果为“正”则提升并继续抛硬币, 结果为“负”则停止. O(logN)

**总体上, 跳跃表插入操作的时间复杂度是O(logN), 而这种数据结构所占空间是2N, 既空间复杂度是 O(N). **

那么如何进行节点的删除呢? 只要在索引层找到要删除的节点, 然后顺藤摸瓜删除每一层相同的节点即可, 如果某一层索引在删除后只剩下一个节点, 那么整个一层就可以干掉了, 举个例子如果要删除的节点值是5

<img src="http://www.milky.show/images/algorithm/jump/jump_10.png" alt="http://www.milky.show/images/algorithm/jump/jump_10.png" style="zoom:50%;" />

**总结一下跳跃表的删除分为如下几个步骤:**

1. 自上而下, 查找第一次出现节点的索引, 并逐层找到每一层对应的节点. O(logN)

1. 删除每一层查找到的节点, 如果该层只剩下1个节点, 删除整个一层(原链表除外). O(logN)

**总体上, 跳跃表删除操作的时间复杂度是O(logN)**

Redis 中的 SortedSet 有序集合正是对于跳跃表的改进和应用



理解Skip List的原理并不困难, 下面我们将使用Java来动手实现一个支持基本需求(查找, 插入和删除)的Skip List. 

## 代码实现

### 节点与基本实现

对于一个普通的链表节点一般只含有一个指向后续节点的指针(双向链表的节点含有两个指针, 一个指向前节点, 一个指向后节点), 由于Skip List是一个多层级的链表结构, 我们的设计要让节点拥有四个指针, 分别对应该节点的前后左右, 为了方便地将头链表永远置于顶层, 还需要设置一个int属性表示该链表所处的层级. 

```java
protected static class Node<K extends Comparable<K>, V> {
    private K key;
    private V value;
    private int level; // 该节点所处的层级
    private Node<K, V> up, down, next, previous;
    public Node(K key, V value, int level) {
        this.key = key;
        this.value = value;
        this.level = level;
    }
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Node[")
                .append("key:");
        if (this.key == null)
            sb.append("None");
        else
            sb.append(this.key.toString());
        sb.append(" value:");
        if (this.value == null)
            sb.append("None");
        else
            sb.append(this.value.toString());
        sb.append("]");
        return sb.toString();
    }

    // 余下都是get,set方法, 这里省略
.....
}
```

接下来是SkipList的基本实现, 为了能够让Key进行比较, 我们规定Key的类型必须实现了Comparable接口, 同时为了支持ForEach循环, 该类还实现了Iterable接口. 

```java
public class SkipList<K extends Comparable<K>, V> implements Iterable<K> {
  
	// 一个随机数生成器
    protected static final Random randomGenerator = new Random();
  
 	// 默认的概率
    protected static final double DEFAULT_PROBABILITY = 0.5;
  
 	// 头节点
    private Node<K, V> head;
    private double probability;
  
 	// SkipList中的元素数量(不计算多个层级中的冗余元素)
    private int size;
    
    public SkipList() {
        this(DEFAULT_PROBABILITY);
    }
    
    public SkipList(double probability) {
        this.head = new Node<K, V>(null, null, 0);
        this.probability = probability;
        this.size = 0;
    }
  .....
}
```

我们还需要定义几个辅助方法, 如下所示(都很简单)

```java
// 对key进行检查
// 因为每条链表的头节点就是一个key为null的节点, 所以不允许其他节点的key也为null
protected void checkKeyValidity(K key) {
    if (key == null)
        throw new IllegalArgumentException("Key must be not null!");
}

// a是否小于等于b
protected boolean lessThanOrEqual(K a, K b) {
    return a.compareTo(b) <= 0;
}

// 概率函数
protected boolean isBuildLevel() {
    return randomGenerator.nextDouble() < probability;
}

// 将y水平插入到x的后面
protected void horizontalInsert(Node<K, V> x, Node<K, V> y) {
    y.setPrevious(x);
    y.setNext(x.getNext());
    if (x.getNext() != null)
        x.getNext().setPrevious(y);
    x.setNext(y);
}

// x与y进行垂直连接
protected void verticalLink(Node<K, V> x, Node<K, V> y) {
    x.setDown(y);
    y.setUp(x);
}
```

### 查找

查找一个节点的过程如下：

-   从顶层链表的头部开始进行遍历, 比较每一个节点的元素与目标元素的大小. 
-   如果当前元素小于目标元素, 则继续遍历. 
-   如果当前元素等于目标元素, 返回该节点. 
-   如果当前元素大于目标元素, 移动到前一个节点(必须小于等于目标元素), 然后跳跃到下一层继续遍历. 
-   如果遍历至链表尾部, 跳跃到下一层继续遍历. 

```java
protected Node<K, V> findNode(K key) {
    Node<K, V> node = head;
    Node<K, V> next = null;
    Node<K, V> down = null;
    K nodeKey = null;
    while (true) {
        // 不断遍历直到遇见大于目标元素的节点
        next = node.getNext();
        while (next != null && lessThanOrEqual(next.getKey(), key)) {
            node = next;
            next = node.getNext();
        }
        // 当前元素等于目标元素, 中断循环
        nodeKey = node.getKey();
        if (nodeKey != null && nodeKey.compareTo(key) == 0) {
            break;
        }
        // 否则, 跳跃到下一层级
        down = node.getDown();
        if (down != null) {
            node = down;
        } else {
            break;
        }
    }
    return node;
}

public V get(K key) {
    checkKeyValidity(key);
    Node<K, V> node = this.findNode(key);
    // 如果找到的节点并不等于目标元素, 则目标元素不存在于SkipList中
    if (node.getKey().compareTo(key) == 0) {
        return node.getValue();
    } else {
        return null;
    }
}
```

### 插入

插入操作的过程要稍微复杂些, 主要在于复制节点到上一层与构建新层的操作上. 

```java
public void add(K key, V value) {
    checkKeyValidity(key);
    // 直接找到key, 然后修改对应的value即可
    Node<K, V> node = findNode(key);
    if (node.getKey() != null && node.getKey().compareTo(key) == 0) {
        node.setValue(value);
        return;
    }

    // 将newNode水平插入到node之后
    Node<K, V> newNode = new Node<K, V>(key, value, node.getLevel());
    horizontalInsert(node, newNode);

    int currentLevel = node.getLevel();
    int headLevel = head.getLevel();
    while (isBuildLevel()) {
        // 如果当前层级已经到达或超越顶层
        // 那么需要构建一个新的顶层
        if (currentLevel >= headLevel) {
            Node<K, V> newHead = new Node<K, V>(null, null, headLevel + 1);
            verticalLink(newHead, head);
            head = newHead;
            headLevel = head.getLevel();
        }
        // 找到node对应的上一层节点
        while (node.getUp() == null) {
            node = node.getPrevious();
        }
        node = node.getUp();
        // 将newNode复制到上一层
        Node<K, V> tmp = new Node<K, V>(key, value, node.getLevel());
        horizontalInsert(node, tmp);
        verticalLink(tmp, newNode);
        newNode = tmp;
        currentLevel++;
    }
    size++;
}
```

### 删除

对于删除一个节点, 需要先找到节点所在的位置(位于最底层链表中的位置), 之后再自底向上地删除该节点在每一行中的冗余复制. 

```java
public void remove(K key) {
    checkKeyValidity(key);
    Node<K, V> node = findNode(key);
    if (node == null || node.getKey().compareTo(key) != 0)
        throw new NoSuchElementException("The key is not exist!");
    // 移动到最底层
    while (node.getDown() != null)
        node = node.getDown();
    // 自底向上地进行删除
    Node<K, V> prev = null;
    Node<K, V> next = null;
    for (; node != null; node = node.getUp()) {
        prev = node.getPrevious();
        next = node.getNext();
        if (prev != null)
            prev.setNext(next);
        if (next != null)
            next.setPrevious(prev);
    }
    // 对顶层链表进行调整, 去除无效的顶层链表
    while (head.getNext() == null && head.getDown() != null) {
        head = head.getDown();
        head.setUp(null);
    }
    size--;
}
```

### 迭代器

由于我们的SkipList实现了Iterable接口, 所以还需要实现一个迭代器. 对于迭代一个Skip List, 只需要找到最底层的链表并且移动到它的首节点, 然后进行遍历即可. 

```java
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    Node<K, V> node = head;
    // 移动到最底层
    while (node.getDown() != null) {
        node = node.getDown();
    }
    while (node.getPrevious() != null) {
        node = node.getPrevious();
    }
    // 第一个节点是头部节点, 没有任何意义, 所以需要移动到后一个节点
    if (node.getNext() != null) {
        node = node.getNext();
    }
    // 遍历
    while (node != null) {
        sb.append(node.toString()).append("\n");
        node = node.getNext();
    }
    return sb.toString();
}

@Override
public Iterator<K> iterator() {
    return new SkipListIterator<K, V>(head);
}

protected static class SkipListIterator<K extends Comparable<K>, V> implements Iterator<K> {

    private Node<K, V> node;

    public SkipListIterator(Node<K, V> node) {
        while (node.getDown() != null) {
            node = node.getDown();
        }
        while (node.getPrevious() != null) {
            node = node.getPrevious();
        }
        if (node.getNext() != null) {
            node = node.getNext();
        }
        this.node = node;
    }

    @Override
    public boolean hasNext() {
        return this.node != null;
    }

    @Override
    public K next() {
        K result = this.node.getKey();
        this.node = this.node.getNext();
        return result;
    }

    @Override
    public void remove() {
        throw new UnsupportedOperationException();
    }

}
```

