---
 
layout: post
title: "分布式事务"
categories: [Distributed]
description:
keywords:
---

* content
{:toc}
# 假如没有分布式事务

在一系列微服务系统当中，假如不存在分布式事务，会发生什么呢？让我们以互联网中常用的交易业务为例子：

![http://www.milky.show/images/distributed/transaction/tran_22.png](http://www.milky.show/images/distributed/transaction/tran_22.png)

上图中包含了库存和订单两个独立的微服务，每个微服务维护了自己的数据库。在交易系统的业务逻辑中，一个商品在下单之前需要先调用库存服务，进行扣除库存，再调用订单服务，创建订单记录。

正常情况下，两个数据库各自更新成功，两边数据维持着一致性。

![http://www.milky.show/images/distributed/transaction/tran_23.png](http://www.milky.show/images/distributed/transaction/tran_23.png)

但是，在非正常情况下，有可能库存的扣减完成了，随后的订单记录却因为某些原因插入失败。这个时候，两边数据就失去了应有的一致性。

![http://www.milky.show/images/distributed/transaction/tran_24.png](http://www.milky.show/images/distributed/transaction/tran_24.png)

**这种情况, 库存减少了, 却没有相应的订单, 这种时候必须要保证数据的一致性. 单数据源的一致性依靠单机事务来保证, 多数据源就要依靠分布式事务**

# 什么是分布式事务？

分布式事务用于在分布式系统中保证不同节点之间的数据一致性。分布式事务的实现有很多种，最具有代表性的是由**Oracle Tuxedo**系统提出的**XA**分布式事务协议。

在魔兽世界这款游戏中，副本组团打BOSS的时候，为了更方便队长与队员们之间的协作，队长可以发起一个“就位确认”的操作：

![http://www.milky.show/images/distributed/transaction/tran_25.png](http://www.milky.show/images/distributed/transaction/tran_25.png)

当队员收到就位确认提示后，如果已经就位，就选择“是”，如果还没就位，就选择“否”。

![http://www.milky.show/images/distributed/transaction/tran_26.png](http://www.milky.show/images/distributed/transaction/tran_26.png)

当队长收到了所有人的就位确认，就会向所有队员们发布消息，告诉他们开始打BOSS。

![http://www.milky.show/images/distributed/transaction/tran_27.png](http://www.milky.show/images/distributed/transaction/tran_27.png)

相应的，在队长发起就位确认的时候，有可能某些队员还并没有就位：

![http://www.milky.show/images/distributed/transaction/tran_28.png](http://www.milky.show/images/distributed/transaction/tran_28.png)

![http://www.milky.show/images/distributed/transaction/tran_29.png](http://www.milky.show/images/distributed/transaction/tran_29.png)

![http://www.milky.show/images/distributed/transaction/tran_30.png](http://www.milky.show/images/distributed/transaction/tran_30.png)

以上就是魔兽世界当中组团打BOSS的确认流程。这个流程和XA分布式事务协议的两阶段提交非常相似。

那么XA协议究竟是什么样子呢？在XA协议中包含着两个角色：**事务协调者**和**事务参与者**。让我们来看一看他们之间的交互流程：

**第一阶段：**

![http://www.milky.show/images/distributed/transaction/tran_31.png](http://www.milky.show/images/distributed/transaction/tran_31.png)

在XA分布式事务的第一阶段，作为事务协调者的节点会首先向所有的参与者节点发送Prepare请求。

在接到Prepare请求之后，每一个参与者节点会各自执行与事务有关的数据更新，写入Undo Log和Redo Log。如果参与者执行成功，暂时不提交事务，而是向事务协调节点返回“完成”消息。

当事务协调者接到了所有参与者的返回消息，整个分布式事务将会进入第二阶段。

**第二阶段：**

![http://www.milky.show/images/distributed/transaction/tran_32.png](http://www.milky.show/images/distributed/transaction/tran_32.png)

在XA分布式事务的第二阶段，如果事务协调节点在之前所收到都是正向返回，那么它将会向所有事务参与者发出Commit请求。

接到Commit请求之后，事务参与者节点会各自进行本地的事务提交，并释放锁资源。当本地事务完成提交后，将会向事务协调者返回“完成”消息。

当事务协调者接收到所有事务参与者的“完成”反馈，整个分布式事务完成。

**以上所描述的是XA两阶段提交的正向流程，接下来我们看一看失败情况的处理流程：**

**第一阶段：**

![http://www.milky.show/images/distributed/transaction/tran_33.png](http://www.milky.show/images/distributed/transaction/tran_33.png)

**第二阶段：**

![http://www.milky.show/images/distributed/transaction/tran_34.png](http://www.milky.show/images/distributed/transaction/tran_34.png)



在XA的第一阶段，如果某个事务参与者反馈失败消息，说明该节点的本地事务执行不成功，必须回滚。

于是在第二阶段，事务协调节点向所有的事务参与者发送Abort请求。接收到Abort请求之后，各个事务参与者节点需要在本地进行事务的回滚操作，回滚操作依照Undo Log来进行。

**XA两阶段提交的不足**

1. **性能问题**

    XA协议遵循强一致性。在事务执行过程中，各个节点占用着数据库资源，只有当所有节点准备完毕，事务协调者才会通知提交，参与者提交后释放资源。这样的过程有着非常明显的性能问题。

2. **协调者单点故障问题**

    事务协调者是整个XA模型的核心，一旦事务协调者节点挂掉，参与者收不到提交或是回滚通知，参与者会一直处于中间状态无法完成事务。

3. **丢失消息导致的不一致问题**

    在XA协议的第二个阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。

**如果避免XA两阶段提交的种种问题呢？有许多其他的分布式事务方案可供选择：**

1. XA三阶段提交

    XA三阶段提交在两阶段提交的基础上增加了CanCommit阶段，并且引入了超时机制。一旦事物参与者迟迟没有接到协调者的commit请求，会自动进行本地commit。这样有效解决了协调者单点故障的问题。但是性能问题和不一致的问题仍然没有根本解决。

2. MQ事务

    利用消息中间件来异步完成事务的后一半更新，实现系统的最终一致性。这个方式避免了像XA协议那样的性能问题。

3. TCC事务

    TCC事务是Try、Commit、Cancel三种指令的缩写，其逻辑模式类似于XA两阶段提交，但是实现方式是在代码层面来人为实现。



# 微服务系统的最大挑战

## 数据一致性问题

数据的并发访问, 修改

不同请求之间的数据隔离

多个服务共同完成一个业务请求, 保证都完成或都失败

发生异常时的数据回滚

## 单服务系统如何解决这些问题?

数据的并发访问, 修改 - **事物**

不同请求之间的数据隔离 - **事物**

多个服务共同完成一个业务请求, 保证都完成或都失败 - **事物**

发生异常时的数据回滚 - **事物**

# 事物

事物以一种**可靠**, **一致**的方式, 访问和操作**数据库**中数据的**程序单元**

## 事物的原则

A 原子性

C 一致性

I 隔离性

D 持久性

## 数据库事物

```
BEGIN TRANSACTION;
UPDATE t_user SET amount = amount - 100 WHERE username = 'BatMan';
UPDATE t_user set amount = amount + 100 WHERE username = 'SupserMan';
COMMIT;
-- ROLLBACK 
```

## JDBC事物管理

```
// 获取连接
Connection conn = getConnection();
// 关闭自动提交
conn.setAutoCommit(false);
Statement stmt1 = conn.prepareStatement(updateUser1SQL);
stmt1.executeUpdate();
Statement stmt2 = conn.prepareStatement(updateUser2SQL);
stmt2.executeUpdate();
conn.commit(); // or conn.rollback();
```

# Spring事物机制

## Spring事物管理

提供同意的API接口支持不同的资源

提供声明式事物

方便与Spring框架继承

多个资源的事务管理, 同步

## Spring事物抽象

**事物管理器: PlatformTransactionManager**

```
public interface PlatformTransactionManager {
	// 通过事物定义获取事物实例
    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;
	// 提交事物
    void commit(TransactionStatus status) throws TransactionException;
	// 回滚事物
    void rollback(TransactionStatus status) throws TransactionException;
}
```

* DataSourceTransactionManager
* JpaTransactionManager

* JmsTransactionManager
* JtaTransactionManager

事物定义: TransactionDefinition**

```
public interface TransactionDefinition {
	// 获取事物传播属性
	int getPropagationBehavior();
	// 获取事物隔离级别
	int getIsolationLevel();
	// 获取事物名称
	String getName();
	// 获取事物超时时间
	int getTimeout();
	// 事物是否是只读
	boolean isReadOnly();
}
```

**事物隔离机制**

```
// 默认使用数据库的隔离机制, mysql默认的是可重复读
int ISOLATION_DEFAULT = -1;
int ISOLATION_READ_UNCOMMITTED = Connection.TRANSACTION_READ_UNCOMMITTED;
int ISOLATION_READ_COMMITTED = Connection.TRANSACTION_READ_COMMITTED;
int ISOLATION_REPEATABLE_READ = Connection.TRANSACTION_REPEATABLE_READ;
int ISOLATION_SERIALIZABLE = Connection.TRANSACTION_SERIALIZABLE;
```

| 事务的隔离级别                                        | 脏读 | 不可重复读 | 幻读 |
| ----------------------------------------------------- | ---- | ---------- | ---- |
| Read uncommitted                                      | √    | √          | √    |
| Read committed--Sql Server , Oracle                   | ×    | √          | √    |
| Repeatable read--[MySQL](http://lib.csdn.net/base/14) | ×    | ×          | √    |
| Serializable                                          | ×    | ×          | ×    |

**事物传播机制**

如果有两个service方法, serviceA的方法调用serviceB的方法, 这两个service的方法都是在事物中执行的,

事物是如何在这两个事物中传播的就是事物传播机制解决的问题

```
// 如果A开启事物B就加入, A不开启B就开启新事物, 默认就是这个级别
int PROPAGATION_REQUIRED = 0;
// 如果A开启事物B就加入, A不开启B就不开启
int PROPAGATION_SUPPORTS = 1;
// A必须在事物中, 如果不在事物中B会报错, 一般用在被调用者上
int PROPAGATION_MANDATORY = 2;
// 不管A在不在事物中, B都会新建事物
int PROPAGATION_REQUIRES_NEW = 3;
// A不管在不在事物中, B都会挂起事物
int PROPAGATION_NOT_SUPPORTED = 4;
// A在事物中就会抛出异常, A不在事物中就可以正常运行, 一般用在被调用者上
int PROPAGATION_NEVER = 5;
// 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。（这个和REQUIRED区别在于一个是加入到一个事务，一个是在嵌套事务运行）
int PROPAGATION_NESTED = 6;
```

可以这么理解，大多数情况下，效果和REQUIRED一样。但是有一种情况，就是上述代码中，被调用者事务传播属性为NESTED，当出现异常时， 调用者把departmentService try，catch了。这个区别与REQUIRED的并不会报错，而且addEmpByNested方法不会回滚，只有addDeptByNested回滚了。
 大概原理：当被调用者使用PROPAGATION_NESTED时，底层的数据源必须基于JDBC 3.0，并且实现者需要支持保存点事务机制。按上述代码来说（去掉try，catch），当执行到addDeptByNested这个方法时，Spring会为它创建一个内部的嵌套事务，如果addDeptByNested执行失败，则事务回滚到addDeptByNested之前的点，此时如果不抛异常，则不会回滚。这个嵌套事务，是addEmpByNested的一部分，只有外层事务提交了，内层的嵌套事务才会一起提交，这也是与REQUIRED（加入事务），REQUIRES_NEW（开启新事务）的区别。
 还值得一提的是，NESTED是嵌套的意思，其实并不是只有NESTED用于嵌套，只要理解上述7个传播机制的意思，都可以嵌套用。

| 传播属性                  | 调用者                                                       | 被调用者  |
| ------------------------- | ------------------------------------------------------------ | --------- |
| PROPAGATION_REQUIRED      | T1                                                           | T1        |
|                           | 无                                                           | T2        |
| PROPAGATION_SUPPORTS      | T1                                                           | T1        |
|                           | 无                                                           | 无        |
| PROPAGATION_MANDATORY     | T1                                                           | T1        |
|                           | 无                                                           | Exception |
| PROPAGATION_REQUIRES_NEW  | T1                                                           | T2        |
|                           | 无                                                           | T2        |
| PROPAGATION_NOT_SUPPORTED | T1                                                           | 无        |
|                           | 无                                                           | 无        |
| PROPAGATION_NEVER         | T1                                                           | Exception |
|                           | 无                                                           | 无        |
| NESTED                    | 设置savePoint, 一旦事物回滚, 事物将回滚到savePoint处, 交由客户响应提交/回滚 |           |

**事物状态: TransactionStatus**

```
public interface TransactionStatus extends SavepointManager, Flushable {

   boolean isNewTransaction();

   boolean hasSavepoint();

   void setRollbackOnly();

   boolean isRollbackOnly();

   boolean isCompleted();

}
```

# Spring事物实例

代码方式, 标签方式实现事物

JPA事务管理

使用MySQL数据库(支持事物)

```
@Autowired
private CustomerRepository customerRepository;
@Autowired
private PlatformTransactionManager transactionManager;

public Customer create(Customer customer) {
    LOG.info("CustomerService In Code create customer:{}", customer.getUsername());
    if (customer.getId() != null) {
        throw new RuntimeException("用户已经存在");
    }
    DefaultTransactionDefinition def = new DefaultTransactionDefinition();
    def.setIsolationLevel(TransactionDefinition.ISOLATION_SERIALIZABLE);
    def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
    def.setTimeout(15);
    TransactionStatus status = transactionManager.getTransaction(def);
    try {
        customer.setUsername("Code:" + customer.getUsername());
        customerRepository.save(customer);
        transactionManager.commit(status);
        return customer;
    } catch (Exception e) {
        transactionManager.rollback(status);
        throw e;
    }
}
```

```
@Transactional
public Customer create(Customer customer) {
    LOG.info("CustomerService In Annotation create customer:{}", customer.getUsername());
    if (customer.getId() != null) {
        throw new RuntimeException("用户已经存在");
    }
    customer.setUsername("Annotation:" + customer.getUsername());
    return customerRepository.save(customer);
}
```

## SpringJMS事物实例

SpringBoot中使用JMS

SpringBootActiveMQStarter

内置的可运行的ActiveMQ服务

实现读写ActiveMQ的事物

### SpringJMS事物类型

JMS Session管理的事物 - 原生事物

外部管理的事物 - JmsTransactionManager(底层还是使用JMS Session), JTA

## Spring外部事物与JTA

### Spring内部事务

Spring容器管理事物的生命周期

通过Spring事物接口调用

业务代码与具体事物的实现无关

![http://www.milky.show/images/distributed/transaction/tran_1.png](http://www.milky.show/images/distributed/transaction/tran_1.png)

### Spring外部(全局)事物

外部事务管理器提供事物管理

通过Spring事物接口, 调用外部管理器

使用JNDI等方式获取外部事物管理器的实例

外部事务管理器一般由应用服务器提供, 如JBoss等

### 外部(全局)事物JTA与SpringJTA实现

外部事务管理器提供JTA事物管理

JTA事物管理器可以管理多个数据源

通过2阶段提交实现多数据源的事物

**在一个服务中使用2个数据源保证事物**

```
1. Start messaging transaction
2. Receive message
3. Start database transaction
4. Update database
5. Commit database transaction
6. Commit messaging transaction
```

### JTA与XA

TransactionManager接口

XAResource接口

XID

两阶段提交

![http://www.milky.show/images/distributed/transaction/tran_2.png](http://www.milky.show/images/distributed/transaction/tran_2.png)

![http://www.milky.show/images/distributed/transaction/tran_3.png](http://www.milky.show/images/distributed/transaction/tran_3.png)

### JTA分布式事物实例-单数据源

使用Spring JTA事物管理

Atomikos外部事物管理器提供JTA事务管理(引入jta的jar包即可)

使用一个数据库 - 单数据源

### JTA分布式事物实例-多数据源

使用Spring JTA事物管理

Atomikos外部事物管理器提供JTA事物管理

多个数据源: DB, MQ



# 分布式系统

将不同的组件分布在不同的服务器上, 给用户提供一个可靠, 统一的服务

## 分布式的基本原则

C: 一致性

* 强一致性(几乎不可能)
* 弱一致性(要考虑多个机器的回滚, 比较复杂)
* **最终一致性**(在弱一致性的基础上, 通过重试, 定时任务扫描或者人为干预的形式达到最终一致性)

A: 可用性(单一服务集群部署)

P: 分区容错性(拆分服务, 分布式部署)

## BASE理论

Basically Available(基本可用)

Soft state(软状态)

Eventually consistent(最终一致性)

相当于CAP原则中的一致性和可用性的权衡结果

## 几种分布式形式

多数据源

![http://www.milky.show/images/distributed/transaction/tran_4.png](http://www.milky.show/images/distributed/transaction/tran_4.png)

多服务

![http://www.milky.show/images/distributed/transaction/tran_5.png](http://www.milky.show/images/distributed/transaction/tran_5.png)

SOA

![http://www.milky.show/images/distributed/transaction/tran_6.png](http://www.milky.show/images/distributed/transaction/tran_6.png)

微服务架构

![http://www.milky.show/images/distributed/transaction/tran_7.png](http://www.milky.show/images/distributed/transaction/tran_7.png)

## 分布式系统需要考虑的问题

服务拆分

数据拆分

计算拆分

服务状态以及异常处理

## 微服务架构的组成

服务发现与注册(注册中心)

服务网管与负载均衡

监控与熔断机制

配置, 消息等



# Spring Cloud微服务架构

## 微服务架构组成

服务

服务注册中心

网关

服务间调用协议

## Spring Cloud微服务架构

Spring Cloud Netfix微服务架构

* 服务注册中心: Eureka
* 网管: Zuul
* 声明式Rest调用接口: Feign Client
* 负载均衡: Ribbon
* 监控, 熔断组件: Hystrix与Hystrix Dashboard

Spring Cloud Config配置服务器

* 配置方式: 文件夹, Git, SVN, DB
* 配置服务器
* 服务 -> 配置服务器 -> 配置

Spring Cloud Bus事件总线



# 多数据源事务

在多个数据源中实现事物

## JTA实现分布式事物

![http://www.milky.show/images/distributed/transaction/tran_8.png](http://www.milky.show/images/distributed/transaction/tran_8.png)

## 不使用JTA实现分布式事务

![http://www.milky.show/images/distributed/transaction/tran_9.png](http://www.milky.show/images/distributed/transaction/tran_9.png)

如果在6的位置发生错误, 会导致DB不能回滚, 这是我们要解决的问题

### 多个资源的事物同步方法

XA与最后资源博弈

1. Start messaging transaction
1. Receive message
1. Start JTA transaction on DB
1. Update database
1. Phase-1 Commit on DB transaction
1. Commit messaging transaction
1. Phase-2 Commit on DB transaction

共享资源

* 两个数据源共享同一个底层资源
* ActiveMQ使用DB作为存储
* 使用DB上的connection控制事物提交
* 需要数据源支持

最大努力一次提交

* 依次提交事物
* 可能出错
* 通过AOP或Listener实现事物直接的同步

链式事物

* 定义一个事物链
* 多个事物在一个事务管理器里一次提交
* 可能出错

## 如何选择

### 根据一致性要求

强一致性事物: JTA(性能差, 只适用于单个服务内)

弱, 最终一致性事物: 最大努力一次提交, 链式事物(设计相应的错误处理机制)

### 根据场景

MQ-DB: 最大努力一次提交 + 重试

多个DB: 链式事物管理

多个数据源: 链式事物, 或其他事物同步方式



## 实例一:

MySQL + MySQL

链式事物: DataSouceTransactionManager + DataSouceTransactionManager

不处理重试

## 实例二:

MySQL + MySQL

链式事物: JpaTransactionManager + DataSourceTransactionManager

不处理重试

## 实例三

JMS + DB

ActiveMQ + MySQL

最大努力一次提交: TransactionAwareConnectionFactoryProxy

# 分布式系统唯一性ID: GUID

分布式系统的全局唯一标识

UUID: 生成唯一ID的规范

用于唯一标识, 处理重复消息

## 常见唯一ID生成方式

数据库自增id: 所有的微服务的数据要放到同一个库中, 实现简单

uuid: 唯一ID标准, 128位, 几种版本

MongoDB的ObjectID: 时间戳 + 机器ID + 近程ID + 序号

Redis的NCR操作, Zookeeper节点的版本号

## 使用何种方式

自定id: 考虑安全性, 部署

时间有序: 便于通过id判断创建时间

长度, 是否数字类型: 便于创建索引



# 微服务架构事物实现模式与技术

## 微服务架构事物实现的几种模式

消息驱动模式: Message Driver

事件溯源模式: Event Sourcing

TCC模式: Try-Confirm-Cancel

## 幂等性

幂等操作: 任意多次执行所产生的影响, 与一次执行的影响相同

方法幂等性: 使用同样的参数调用一个方法多次, 与调用一次结果相同

接口幂等性: 接口被重复调用, 结果一致

### 微服务接口的幂等性

重要性: 经常需要通过重试实现分布式事务的最终一致性

GET方法不会对系统产生副作用, 具有幂等性

POST, PUT, DELETE方法的实现需要满足幂等性

## 微服务架构的事务问题

服务间调用操作的回滚

服务间调用失败的重试问题

## 消息驱动的分布式事务实现

事件不需要持久化保存

消息只是为了更新业务数据的状态, 数据库才是一等数据

不要求所有的数据操作都通过消息驱动

![http://www.milky.show/images/distributed/transaction/tran_10.png](http://www.milky.show/images/distributed/transaction/tran_10.png)

### 需要注意的问题

消息中间件需要支持事务

如何处理消息重试

发生业务异常时回滚操作

### 系统错误的处理

将出错未处理的消息写到失败队列, 进行相应的回滚操作

通过定时任务检查超时订单, 对未完成的订单做自动回滚

保存出错消息, 人工处理

### 实例

Order服务, User服务, Ticket服务

ActiveMQ作为消息中间件

错误处理: 定时任务检查并回滚

幂等性: 实现方法的幂等性

![http://www.milky.show/images/distributed/transaction/tran_13.png](http://www.milky.show/images/distributed/transaction/tran_13.png)

curl -X POST -d '{"customerId": 1, "title": "new_order", "amount": 100, "ticketNum": 100}' -H 'Content-Type: application/json' http://localhost:9601/order/api/order

![http://www.milky.show/images/distributed/transaction/tran_11.png](http://www.milky.show/images/distributed/transaction/tran_11.png)

![http://www.milky.show/images/distributed/transaction/tran_12.png](http://www.milky.show/images/distributed/transaction/tran_12.png)

![http://www.milky.show/images/distributed/transaction/tran_14.png](http://www.milky.show/images/distributed/transaction/tran_14.png)

#### 异常订单处理

定时处理异常订单: 1. 未被处理完成 2. 未被按失败订单处理

解锁票, 撤销交票

对于余额之类的重要数据, 可能使用人工处理

#### 实现锁票的安全性

利用@JmsListener设置一个消费者, 不适用于多实例

使用事务和数据库锁的特性

分布式锁



## 事件溯源模式的分布式事务实现

事件作为一等数据保存

统一的事件管理器和接口, 数据更新都由事件产生

数据库中的数据当前状态根据事件的聚合产生

聚合数据可以保存在数据库中, 可以根据事件重新生成

![http://www.milky.show/images/distributed/transaction/tran_15.png](http://www.milky.show/images/distributed/transaction/tran_15.png)

### 事件溯源模式的优点

历史重现: 从事件中重新生成视图数据库

方便的数据流处理与报告生成

性能

服务的松耦合

### 事件溯源模式的缺点

只能保证事务的最终一致性

设计和开发的思维转变, 学习成本

事件结构的改变

扩展性: Event Store的分布式实现, 事件的分布式处理

### 事件溯源的数据一致性

一个事件只处理一个服务的数据

保证事件的至少一次处理, 幂等性

业务请求的错误处理: 多次重试失败, 网络异常, 服务不可用

### 实例

![http://www.milky.show/images/distributed/transaction/tran_16.png](http://www.milky.show/images/distributed/transaction/tran_16.png)

![http://www.milky.show/images/distributed/transaction/tran_17.png](http://www.milky.show/images/distributed/transaction/tran_17.png)

### 事件溯源与Axon框架

#### 使用Axon框架的设计过程

领域模型设计: 账户Account

业务 - Command - Command处理: 创建账户, 存款, 取款

数据 - Event - Event处理: 账户创建, 存款, 取款

将数据保存到数据库: 聚合数据 - 映射到 - 视图数据

查询Query: 查询账户

## TCC模式的分布式事务实现

### 事务管理的过程

do

commit / rollback

### JTA事务管理的过程

do

prepare / rollback

commit / rollback

### TCC模式的事物管理

Try

Commit(Confirm) / Cancel

### TCC模式的实现思路

每个需要实现事务的接口, 都需要实现3个接口

tryXx(): 业务检查, 预留资源

confirmXx(): 执行业务, 使用资源

cancelXx(): 回滚业务, 释放资源

![http://www.milky.show/images/distributed/transaction/tran_18.png](http://www.milky.show/images/distributed/transaction/tran_18.png)

![http://www.milky.show/images/distributed/transaction/tran_19.png](http://www.milky.show/images/distributed/transaction/tran_19.png)

### TCC模式协调器的功能

接管事务管理, 类似JTA的独立事务管理器(非两阶段提交)

保存每个资源上的事务记录: 跟踪状态, 检查超时

保证每个资源上的事务性

处理各种错误: 超时, 重试, 网络异常, 服务不可用

### TCC模式实现分布式事务

借鉴XA的统一资源管理, 又不是两阶段提交

不同资源之间没有锁, 事务过程数据没有锁, 没有隔离

出错时可能多次调用Confirm/Cancel方法, 以及顺序无法保证

Confirm/Cancel方法需要满足幂等性, 即重复调用时结果一致

![http://www.milky.show/images/distributed/transaction/tran_20.png](http://www.milky.show/images/distributed/transaction/tran_20.png)

### TCC模式下的业务方法 - 思路1: REST风格接口

```
@RestController
public class UserResource{
    @Transactional
    public void tryCharge(DTO dto){}
    @Transactional
    public void confirmCharge(DTO dto){}
    @Transactional
    public void cancelCharge(DTO dto){}
}
```

![http://www.milky.show/images/distributed/transaction/tran_21.png](http://www.milky.show/images/distributed/transaction/tran_21.png)

Try方法返回confirm/cancel时调用的接口URI: user/charge/{userId}/{orderId}

Confirm: PUT

Cancel: DELETE

### TCC模式下的业务方法 - 思路2: Service规范

```
public interface TccMethod<P extends TccRequest<R>, R extends Serializable>{
    R doTry(P param);
    void doConfirm(P param);
    void doCancel(P param);
}
```

将一个业务逻辑封装成TccMethod类来调用

将协调器保存TccMethod, TccRequest, TccResponse

服务会有一个专门的接口接收协调器的请求, 处理Confirm/Cancel

服务不需要开放Confirm/Cancel接口

### TCC模式出错处理

1. order服务创建订单
1. order服务调用user服务tryCharge()
1. order服务调用ticket服务tryTicketMove()
1. 协调器调用user服务confirmCharge()
1. 协调器调用ticket服务confirmCharge()
1. 提交事务

### 基于TCC模式的开发

没有统一的规范, 也没有广泛使用框架

协调器的开发比较复杂, 需要保证各种情况出错下的最终一致性

协调器监控事物: 事务及其参数, 返回值保存在数据库中

TCC模式的服务组件的复用性

### 实现TCC模式的框架

https://github.com/liuyangming/ByteTCC

https://github.com/QNJR-GROUP/EasyTransaction

https://github.com/changmingxie/tcc-transaction