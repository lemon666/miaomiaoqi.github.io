---
 
layout: post
title:  "分布式事务"
date:   2018-12-05 14:01:35
categories: Distributed
tags: Transaction
author: miaoqi
---

* content
{:toc}
# 微服务系统的最大挑战

## 数据一致性问题

数据的并发访问, 修改

不同请求之间的数据隔离

多个服务共同完成一个业务请求, 保证都完成或都失败

发生异常时的数据回滚

## 单服务系统如何解决这些问题?

数据的并发访问, 修改 - **事物**

不同请求之间的数据隔离 - **事物**

多个服务共同完成一个业务请求, 保证都完成或都失败 - **事物**

发生异常时的数据回滚 - **事物**

# 事物

事物以一种**可靠**, **一致**的方式, 访问和操作**数据库**中数据的**程序单元**

## 事物的原则

A 原子性

C 一致性

I 隔离性

D 持久性

## 数据库事物

```
BEGIN TRANSACTION;
UPDATE t_user SET amount = amount - 100 WHERE username = 'BatMan';
UPDATE t_user set amount = amount + 100 WHERE username = 'SupserMan';
COMMIT;
-- ROLLBACK 
```

## JDBC事物管理

```
// 获取连接
Connection conn = getConnection();
// 关闭自动提交
conn.setAutoCommit(false);
Statement stmt1 = conn.prepareStatement(updateUser1SQL);
stmt1.executeUpdate();
Statement stmt2 = conn.prepareStatement(updateUser2SQL);
stmt2.executeUpdate();
conn.commit(); // or conn.rollback();
```

# Spring事物机制

## Spring事物管理

提供同意的API接口支持不同的资源

提供声明式事物

方便与Spring框架继承

多个资源的事务管理, 同步

## Spring事物抽象

**事物管理器: PlatformTransactionManager**

```
public interface PlatformTransactionManager {
	// 通过事物定义获取事物实例
    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;
	// 提交事物
    void commit(TransactionStatus status) throws TransactionException;
	// 回滚事物
    void rollback(TransactionStatus status) throws TransactionException;
}
```

* DataSourceTransactionManager
* JpaTransactionManager

* JmsTransactionManager
* JtaTransactionManager

事物定义: TransactionDefinition**

```
public interface TransactionDefinition {
	// 获取事物传播属性
	int getPropagationBehavior();
	// 获取事物隔离级别
	int getIsolationLevel();
	// 获取事物名称
	String getName();
	// 获取事物超时时间
	int getTimeout();
	// 事物是否是只读
	boolean isReadOnly();
}
```

**事物隔离机制**

```
// 默认使用数据库的隔离机制, mysql默认的是可重复读
int ISOLATION_DEFAULT = -1;
int ISOLATION_READ_UNCOMMITTED = Connection.TRANSACTION_READ_UNCOMMITTED;
int ISOLATION_READ_COMMITTED = Connection.TRANSACTION_READ_COMMITTED;
int ISOLATION_REPEATABLE_READ = Connection.TRANSACTION_REPEATABLE_READ;
int ISOLATION_SERIALIZABLE = Connection.TRANSACTION_SERIALIZABLE;
```

| 事务的隔离级别                                        | 脏读 | 不可重复读 | 幻读 |
| ----------------------------------------------------- | ---- | ---------- | ---- |
| Read uncommitted                                      | √    | √          | √    |
| Read committed--Sql Server , Oracle                   | ×    | √          | √    |
| Repeatable read--[MySQL](http://lib.csdn.net/base/14) | ×    | ×          | √    |
| Serializable                                          | ×    | ×          | ×    |

**事物传播机制**

如果有两个service方法, serviceA的方法调用serviceB的方法, 这两个service的方法都是在事物中执行的,

事物是如何在这两个事物中传播的就是事物传播机制解决的问题

```
// 如果A开启事物B就加入, A不开启B就开启新事物, 默认就是这个级别
int PROPAGATION_REQUIRED = 0;
// 如果A开启事物B就加入, A不开启B就不开启
int PROPAGATION_SUPPORTS = 1;
// A必须在事物中, 如果不在事物中B会报错, 一般用在被调用者上
int PROPAGATION_MANDATORY = 2;
// 不管A在不在事物中, B都会新建事物
int PROPAGATION_REQUIRES_NEW = 3;
// A不管在不在事物中, B都会挂起事物
int PROPAGATION_NOT_SUPPORTED = 4;
// A在事物中就会抛出异常, A不在事物中就可以正常运行, 一般用在被调用者上
int PROPAGATION_NEVER = 5;
// 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。（这个和REQUIRED区别在于一个是加入到一个事务，一个是在嵌套事务运行）
int PROPAGATION_NESTED = 6;
```

可以这么理解，大多数情况下，效果和REQUIRED一样。但是有一种情况，就是上述代码中，被调用者事务传播属性为NESTED，当出现异常时， 调用者把departmentService try，catch了。这个区别与REQUIRED的并不会报错，而且addEmpByNested方法不会回滚，只有addDeptByNested回滚了。
 大概原理：当被调用者使用PROPAGATION_NESTED时，底层的数据源必须基于JDBC 3.0，并且实现者需要支持保存点事务机制。按上述代码来说（去掉try，catch），当执行到addDeptByNested这个方法时，Spring会为它创建一个内部的嵌套事务，如果addDeptByNested执行失败，则事务回滚到addDeptByNested之前的点，此时如果不抛异常，则不会回滚。这个嵌套事务，是addEmpByNested的一部分，只有外层事务提交了，内层的嵌套事务才会一起提交，这也是与REQUIRED（加入事务），REQUIRES_NEW（开启新事务）的区别。
 还值得一提的是，NESTED是嵌套的意思，其实并不是只有NESTED用于嵌套，只要理解上述7个传播机制的意思，都可以嵌套用。

| 传播属性                  | 调用者                                                       | 被调用者  |
| ------------------------- | ------------------------------------------------------------ | --------- |
| PROPAGATION_REQUIRED      | T1                                                           | T1        |
|                           | 无                                                           | T2        |
| PROPAGATION_SUPPORTS      | T1                                                           | T1        |
|                           | 无                                                           | 无        |
| PROPAGATION_MANDATORY     | T1                                                           | T1        |
|                           | 无                                                           | Exception |
| PROPAGATION_REQUIRES_NEW  | T1                                                           | T2        |
|                           | 无                                                           | T2        |
| PROPAGATION_NOT_SUPPORTED | T1                                                           | 无        |
|                           | 无                                                           | 无        |
| PROPAGATION_NEVER         | T1                                                           | Exception |
|                           | 无                                                           | 无        |
| NESTED                    | 设置savePoint, 一旦事物回滚, 事物将回滚到savePoint处, 交由客户响应提交/回滚 |           |

**事物状态: TransactionStatus**

```
public interface TransactionStatus extends SavepointManager, Flushable {

   boolean isNewTransaction();

   boolean hasSavepoint();

   void setRollbackOnly();

   boolean isRollbackOnly();

   boolean isCompleted();

}
```

# Spring事物实例

代码方式, 标签方式实现事物

JPA事务管理

使用MySQL数据库(支持事物)

```
@Autowired
private CustomerRepository customerRepository;
@Autowired
private PlatformTransactionManager transactionManager;

public Customer create(Customer customer) {
    LOG.info("CustomerService In Code create customer:{}", customer.getUsername());
    if (customer.getId() != null) {
        throw new RuntimeException("用户已经存在");
    }
    DefaultTransactionDefinition def = new DefaultTransactionDefinition();
    def.setIsolationLevel(TransactionDefinition.ISOLATION_SERIALIZABLE);
    def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
    def.setTimeout(15);
    TransactionStatus status = transactionManager.getTransaction(def);
    try {
        customer.setUsername("Code:" + customer.getUsername());
        customerRepository.save(customer);
        transactionManager.commit(status);
        return customer;
    } catch (Exception e) {
        transactionManager.rollback(status);
        throw e;
    }
}
```

```
@Transactional
public Customer create(Customer customer) {
    LOG.info("CustomerService In Annotation create customer:{}", customer.getUsername());
    if (customer.getId() != null) {
        throw new RuntimeException("用户已经存在");
    }
    customer.setUsername("Annotation:" + customer.getUsername());
    return customerRepository.save(customer);
}
```

## SpringJMS事物实例

SpringBoot中使用JMS

SpringBootActiveMQStarter

内置的可运行的ActiveMQ服务

实现读写ActiveMQ的事物

### SpringJMS事物类型

JMS Session管理的事物 - 原生事物

外部管理的事物 - JmsTransactionManager(底层还是使用JMS Session), JTA

## Spring外部事物与JTA

### Spring内部事务

Spring容器管理事物的生命周期

通过Spring事物接口调用

业务代码与具体事物的实现无关

![http://www.miaomiaoqi.cn/iamges/distributed/transaction/tran_1.png](http://www.miaomiaoqi.cn/iamges/distributed/transaction/tran_1.png)

### Spring外部(全局)事物

外部事务管理器提供事物管理

通过Spring事物接口, 调用外部管理器

使用JNDI等方式获取外部事物管理器的实例

外部事务管理器一般由应用服务器提供, 如JBoss等

### 外部(全局)事物JTA与SpringJTA实现

外部事务管理器提供JTA事物管理

JTA事物管理器可以管理多个数据源

通过2阶段提交实现多数据源的事物

**在一个服务中使用2个数据源保证事物**

```
1. Start messaging transaction
2. Receive message
3. Start database transaction
4. Update database
5. Commit database transaction
6. Commit messaging transaction
```

### JTA与XA

TransactionManager接口

XAResource接口

XID

两阶段提交

![http://www.miaomiaoqi.cn/iamges/distributed/transaction/tran_2.png](http://www.miaomiaoqi.cn/iamges/distributed/transaction/tran_2.png)

![http://www.miaomiaoqi.cn/iamges/distributed/transaction/tran_3.png](http://www.miaomiaoqi.cn/iamges/distributed/transaction/tran_3.png)

### JTA分布式事物实例-单数据源

使用Spring JTA事物管理

Atomikos外部事物管理器提供JTA事务管理(引入jta的jar包即可)

使用一个数据库 - 单数据源

### JTA分布式事物实例-多数据源

使用Spring JTA事物管理

Atomikos外部事物管理器提供JTA事物管理

多个数据源: DB, MQ



# 分布式系统

将不同的组件分布在不同的服务器上, 给用户提供一个可靠, 统一的服务

## 分布式的基本原则

C: 一致性

* 强一致性(几乎不可能)
* 弱一致性(要考虑多个机器的回滚, 比较复杂)
* **最终一致性**(在弱一致性的基础上, 通过重试, 定时任务扫描或者人为干预的形式达到最终一致性)

A: 可用性(单一服务集群部署)

P: 分区容错性(拆分服务, 分布式部署)

## BASE理论

Basically Available(基本可用)

Soft state(软状态)

Eventually consistent(最终一致性)

相当于CAP原则中的一致性和可用性的权衡结果

## 几种分布式形式

多数据源

![http://www.miaomiaoqi.cn/images/distributed/transaction/tran_4.png](http://www.miaomiaoqi.cn/images/distributed/transaction/tran_4.png)

多服务

![http://www.miaomiaoqi.cn/images/distributed/transaction/tran_5.png](http://www.miaomiaoqi.cn/images/distributed/transaction/tran_5.png)

SOA

![http://www.miaomiaoqi.cn/images/distributed/transaction/tran_6.png](http://www.miaomiaoqi.cn/images/distributed/transaction/tran_6.png)

微服务架构

![http://www.miaomiaoqi.cn/images/distributed/transaction/tran_7.png](http://www.miaomiaoqi.cn/images/distributed/transaction/tran_7.png)

## 分布式系统需要考虑的问题

服务拆分

数据拆分

计算拆分

服务状态以及异常处理

## 微服务架构的组成

服务发现与注册(注册中心)

服务网管与负载均衡

监控与熔断机制

配置, 消息等



# Spring Cloud微服务架构

## 微服务架构组成

服务

服务注册中心

网关

服务间调用协议

## Spring Cloud微服务架构

Spring Cloud Netfix微服务架构

* 服务注册中心: Eureka
* 网管: Zuul
* 声明式Rest调用接口: Feign Client
* 负载均衡: Ribbon
* 监控, 熔断组件: Hystrix与Hystrix Dashboard

Spring Cloud Config配置服务器

* 配置方式: 文件夹, Git, SVN, DB
* 配置服务器
* 服务 -> 配置服务器 -> 配置

Spring Cloud Bus事件总线



# 多数据源事务

在多个数据源中实现事物

## JTA实现分布式事物

![http://www.miaomiaoqi.cn/images/distributed/transaction/tran_8.png](http://www.miaomiaoqi.cn/images/distributed/transaction/tran_8.png)

## 不使用JTA实现分布式事务

![http://www.miaomiaoqi.cn/images/distributed/transaction/tran_9.png](http://www.miaomiaoqi.cn/images/distributed/transaction/tran_9.png)

如果在6的位置发生错误, 会导致DB不能回滚, 这是我们要解决的问题

### 多个资源的事物同步方法

XA与最后资源博弈

1. Start messaging transaction
1. Receive message
1. Start JTA transaction on DB
1. Update database
1. Phase-1 Commit on DB transaction
1. Commit messaging transaction
1. Phase-2 Commit on DB transaction

共享资源

* 两个数据源共享同一个底层资源
* ActiveMQ使用DB作为存储
* 使用DB上的connection控制事物提交
* 需要数据源支持

最大努力一次提交

* 依次提交事物
* 可能出错
* 通过AOP或Listener实现事物直接的同步

链式事物

* 定义一个事物链
* 多个事物在一个事务管理器里一次提交
* 可能出错

## 如何选择

### 根据一致性要求

强一致性事物: JTA(性能差, 只适用于单个服务内)

弱, 最终一致性事物: 最大努力一次提交, 链式事物(设计相应的错误处理机制)

### 根据场景

MQ-DB: 最大努力一次提交 + 重试

多个DB: 链式事物管理

多个数据源: 链式事物, 或其他事物同步方式



## 实例一:

MySQL + MySQL

链式事物: DataSouceTransactionManager + DataSouceTransactionManager

不处理重试

## 实例二:

MySQL + MySQL

链式事物: JpaTransactionManager + DataSourceTransactionManager

不处理重试

## 实例三

JMS + DB

ActiveMQ + MySQL

最大努力一次提交: TransactionAwareConnectionFactoryProxy

# 分布式系统唯一性ID: GUID

分布式系统的全局唯一标识

UUID: 生成唯一ID的规范

用于唯一标识, 处理重复消息

## 常见唯一ID生成方式

数据库自增id: 所有的微服务的数据要放到同一个库中, 实现简单

uuid: 唯一ID标准, 128位, 几种版本

MongoDB的ObjectID: 时间戳 + 机器ID + 近程ID + 序号

Redis的NCR操作, Zookeeper节点的版本号

## 使用何种方式

自定id: 考虑安全性, 部署

时间有序: 便于通过id判断创建时间

长度, 是否数字类型: 便于创建索引



# 微服务架构事物实现模式与技术

## 微服务架构事物实现的几种模式

消息驱动模式: Message Driver

事件溯源模式: Event Sourcing

TCC模式: Try-Confirm-Cancel

## 幂等性

幂等操作: 任意多次执行所产生的影响, 与一次执行的影响相同

方法幂等性: 使用同样的参数调用一个方法多次, 与调用一次结果相同

接口幂等性: 接口被重复调用, 结果一致

### 微服务接口的幂等性

重要性: 经常需要通过重试实现分布式事务的最终一致性

GET方法不会对系统产生副作用, 具有幂等性

POST, PUT, DELETE方法的实现需要满足幂等性

## 微服务架构的事务问题

服务间调用操作的回滚

服务间调用失败的重试问题

## 消息驱动的分布式事务实现

事件不需要持久化保存

消息只是为了更新业务数据的状态, 数据库才是一等数据

不要求所有的数据操作都通过消息驱动

![http://www.miaomiaoqi.cn/images/distributed/transaction/tran_10.png](http://www.miaomiaoqi.cn/images/distributed/transaction/tran_10.png)

### 需要注意的问题

消息中间件需要支持事务

如何处理消息重试

发生业务异常时回滚操作

### 系统错误的处理

将出错未处理的消息写到失败队列, 进行相应的回滚操作

通过定时任务检查超时订单, 对未完成的订单做自动回滚

保存出错消息, 人工处理

### 实例

Order服务, User服务, Ticket服务

ActiveMQ作为消息中间件

错误处理: 定时任务检查并回滚

幂等性: 实现方法的幂等性

![http://www.miaomiaoqi.cn/images/distributed/transaction/tran_13.png](http://www.miaomiaoqi.cn/images/distributed/transaction/tran_13.png)

curl -X POST -d '{"customerId": 1, "title": "new_order", "amount": 100, "ticketNum": 100}' -H 'Content-Type: application/json' http://localhost:9601/order/api/order

![http://www.miaomiaoqi.cn/images/distributed/transaction/tran_11.png](http://www.miaomiaoqi.cn/images/distributed/transaction/tran_11.png)

![http://www.miaomiaoqi.cn/images/distributed/transaction/tran_12.png](http://www.miaomiaoqi.cn/images/distributed/transaction/tran_12.png)

![http://www.miaomiaoqi.cn/images/distributed/transaction/tran_14.png](http://www.miaomiaoqi.cn/images/distributed/transaction/tran_14.png)

#### 异常订单处理

定时处理异常订单: 1. 未被处理完成 2. 未被按失败订单处理

解锁票, 撤销交票

对于余额之类的重要数据, 可能使用人工处理

#### 实现锁票的安全性

利用@JmsListener设置一个消费者, 不适用于多实例

使用事务和数据库锁的特性

分布式锁



## 事件溯源模式的分布式事务实现

事件作为一等数据保存

统一的事件管理器和接口, 数据更新都由事件产生

数据库中的数据当前状态根据事件的聚合产生

聚合数据可以保存在数据库中, 可以根据事件重新生成

![http://www.miaomiaoqi.cn/images/distributed/transaction/tran_14.png](http://www.miaomiaoqi.cn/images/distributed/transaction/tran_15.png)

