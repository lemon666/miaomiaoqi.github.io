---

layout: post
title:  "分布式事务"
date:   2018-12-05 14:01:35
categories: Distributed
tags: Transaction
author: miaoqi
---

* content
{:toc}
# 微服务系统的最大挑战

## 数据一致性问题

数据的并发访问, 修改

不同请求之间的数据隔离

多个服务共同完成一个业务请求, 保证都完成或都失败

发生异常时的数据回滚

## 单服务系统如何解决这些问题?

数据的并发访问, 修改 - **事物**

不同请求之间的数据隔离 - **事物**

多个服务共同完成一个业务请求, 保证都完成或都失败 - **事物**

发生异常时的数据回滚 - **事物**

# 事物

事物以一种**可靠**, **一致**的方式, 访问和操作**数据库**中数据的**程序单元**

## 事物的原则

A 原子性

C 一致性

I 隔离性

D 持久性

## 数据库事物

```
BEGIN TRANSACTION;
UPDATE t_user SET amount = amount - 100 WHERE username = 'BatMan';
UPDATE t_user set amount = amount + 100 WHERE username = 'SupserMan';
COMMIT;
-- ROLLBACK 
```

## JDBC事物管理

```
// 获取连接
Connection conn = getConnection();
// 关闭自动提交
conn.setAutoCommit(false);
Statement stmt1 = conn.prepareStatement(updateUser1SQL);
stmt1.executeUpdate();
Statement stmt2 = conn.prepareStatement(updateUser2SQL);
stmt2.executeUpdate();
conn.commit(); // or conn.rollback();
```

# Spring事物机制

## Spring事物管理

提供同意的API接口支持不同的资源

提供声明式事物

方便与Spring框架继承

多个资源的事务管理, 同步

## Spring事物抽象

**事物管理器: PlatformTransactionManager**

```
public interface PlatformTransactionManager {
	// 通过事物定义获取事物实例
    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;
	// 提交事物
    void commit(TransactionStatus status) throws TransactionException;
	// 回滚事物
    void rollback(TransactionStatus status) throws TransactionException;
}
```

* DataSourceTransactionManager
* JpaTransactionManager

* JmsTransactionManager
* JtaTransactionManager

事物定义: TransactionDefinition**

```
public interface TransactionDefinition {
	// 获取事物传播属性
	int getPropagationBehavior();
	// 获取事物隔离级别
	int getIsolationLevel();
	// 获取事物名称
	String getName();
	// 获取事物超时时间
	int getTimeout();
	// 事物是否是只读
	boolean isReadOnly();
}
```

**事物隔离机制**

```
// 默认使用数据库的隔离机制, mysql默认的是可重复读
int ISOLATION_DEFAULT = -1;
int ISOLATION_READ_UNCOMMITTED = Connection.TRANSACTION_READ_UNCOMMITTED;
int ISOLATION_READ_COMMITTED = Connection.TRANSACTION_READ_COMMITTED;
int ISOLATION_REPEATABLE_READ = Connection.TRANSACTION_REPEATABLE_READ;
int ISOLATION_SERIALIZABLE = Connection.TRANSACTION_SERIALIZABLE;
```

| 事务的隔离级别                                        | 脏读 | 不可重复读 | 幻读 |
| ----------------------------------------------------- | ---- | ---------- | ---- |
| Read uncommitted                                      | √    | √          | √    |
| Read committed--Sql Server , Oracle                   | ×    | √          | √    |
| Repeatable read--[MySQL](http://lib.csdn.net/base/14) | ×    | ×          | √    |
| Serializable                                          | ×    | ×          | ×    |

**事物传播机制**

如果有两个service方法, serviceA的方法调用serviceB的方法, 这两个service的方法都是在事物中执行的,

事物是如何在这两个事物中传播的就是事物传播机制解决的问题

```
// 如果A开启事物B就加入, A不开启B就开启新事物, 默认就是这个级别
int PROPAGATION_REQUIRED = 0;
// 如果A开启事物B就加入, A不开启B就不开启
int PROPAGATION_SUPPORTS = 1;
// A必须在事物中, 如果不在事物中B会报错, 一般用在被调用者上
int PROPAGATION_MANDATORY = 2;
// 不管A在不在事物中, B都会新建事物
int PROPAGATION_REQUIRES_NEW = 3;
// A不管在不在事物中, B都会挂起事物
int PROPAGATION_NOT_SUPPORTED = 4;
// A在事物中就会抛出异常, A不在事物中就可以正常运行, 一般用在被调用者上
int PROPAGATION_NEVER = 5;
// 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。（这个和REQUIRED区别在于一个是加入到一个事务，一个是在嵌套事务运行）
int PROPAGATION_NESTED = 6;
```

可以这么理解，大多数情况下，效果和REQUIRED一样。但是有一种情况，就是上述代码中，被调用者事务传播属性为NESTED，当出现异常时， 调用者把departmentService try，catch了。这个区别与REQUIRED的并不会报错，而且addEmpByNested方法不会回滚，只有addDeptByNested回滚了。
 大概原理：当被调用者使用PROPAGATION_NESTED时，底层的数据源必须基于JDBC 3.0，并且实现者需要支持保存点事务机制。按上述代码来说（去掉try，catch），当执行到addDeptByNested这个方法时，Spring会为它创建一个内部的嵌套事务，如果addDeptByNested执行失败，则事务回滚到addDeptByNested之前的点，此时如果不抛异常，则不会回滚。这个嵌套事务，是addEmpByNested的一部分，只有外层事务提交了，内层的嵌套事务才会一起提交，这也是与REQUIRED（加入事务），REQUIRES_NEW（开启新事务）的区别。
 还值得一提的是，NESTED是嵌套的意思，其实并不是只有NESTED用于嵌套，只要理解上述7个传播机制的意思，都可以嵌套用。

| 传播属性                  | 调用者                                                       | 被调用者  |
| ------------------------- | ------------------------------------------------------------ | --------- |
| PROPAGATION_REQUIRED      | T1                                                           | T1        |
|                           | 无                                                           | T2        |
| PROPAGATION_SUPPORTS      | T1                                                           | T1        |
|                           | 无                                                           | 无        |
| PROPAGATION_MANDATORY     | T1                                                           | T1        |
|                           | 无                                                           | Exception |
| PROPAGATION_REQUIRES_NEW  | T1                                                           | T2        |
|                           | 无                                                           | T2        |
| PROPAGATION_NOT_SUPPORTED | T1                                                           | 无        |
|                           | 无                                                           | 无        |
| PROPAGATION_NEVER         | T1                                                           | Exception |
|                           | 无                                                           | 无        |
| NESTED                    | 设置savePoint, 一旦事物回滚, 事物将回滚到savePoint处, 交由客户响应提交/回滚 |           |

**事物状态: TransactionStatus**

```
public interface TransactionStatus extends SavepointManager, Flushable {

   boolean isNewTransaction();

   boolean hasSavepoint();

   void setRollbackOnly();

   boolean isRollbackOnly();

   boolean isCompleted();

}
```

## Spring事物实例

代码方式, 标签方式实现事物

JPA事务管理

使用MySQL数据库(支持事物)

```
@Autowired
private CustomerRepository customerRepository;
@Autowired
private PlatformTransactionManager transactionManager;

public Customer create(Customer customer) {
    LOG.info("CustomerService In Code create customer:{}", customer.getUsername());
    if (customer.getId() != null) {
        throw new RuntimeException("用户已经存在");
    }
    DefaultTransactionDefinition def = new DefaultTransactionDefinition();
    def.setIsolationLevel(TransactionDefinition.ISOLATION_SERIALIZABLE);
    def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
    def.setTimeout(15);
    TransactionStatus status = transactionManager.getTransaction(def);
    try {
        customer.setUsername("Code:" + customer.getUsername());
        customerRepository.save(customer);
        transactionManager.commit(status);
        return customer;
    } catch (Exception e) {
        transactionManager.rollback(status);
        throw e;
    }
}
```

```
@Transactional
public Customer create(Customer customer) {
    LOG.info("CustomerService In Annotation create customer:{}", customer.getUsername());
    if (customer.getId() != null) {
        throw new RuntimeException("用户已经存在");
    }
    customer.setUsername("Annotation:" + customer.getUsername());
    return customerRepository.save(customer);
}
```

## SpringJMS事物实例

SpringBoot中使用JMS

SpringBootActiveMQStarter

内置的可运行的ActiveMQ服务

实现读写ActiveMQ的事物

### SpringJMS事物类型

Session管理的事物 - 原生事物

外部管理的事物 - JmsTransactionManager, JTA





