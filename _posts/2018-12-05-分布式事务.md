---
 
layout: post
title: "分布式事务"
categories: [Distributed]
description:
keywords:
---

* content
{:toc}




## 事务

对同一数据源, 进行一组相关的 sql 操作, 要么全部成功, 要么全部失败.

### 事务的四个特性

原子性(Atomicity): 同生共死(要么全部成功, 要么全部失败)

一致性(Consistency): 相互抵消(卖方+200 元和买方-200 元)

隔离性(Isolation): 并行不扰, 理论上并行的两个事务, 互相之间是不干扰的

持久性(Durability): 落子无悔, 对数据库的操作是不可逆的

### 事务的隔离级别

根据两个事务之间的干扰性强弱, 划分为几个级别

读未提交\读已提交\可重复度\串行化

**脏读**: 事务 a, 读到了事务 b 未提交的数据.

**不可重复度**: 两次读到的数据不一致

**幻读**: 一个事务在查询, 另一个事务在做插入或者删除, 此时就会出现幻读

| 事务的隔离级别                                        | 脏读 | 不可重复读 | 幻读 |
| ----------------------------------------------------- | ---- | ---------- | ---- |
| Read uncommitted                                      | √    | √          | √    |
| Read committed--Sql Server , Oracle                   | ×    | √          | √    |
| Repeatable read--[MySQL](http://lib.csdn.net/base/14) | ×    | ×          | √    |
| Serializable                                          | ×    | ×          | ×    |

### 数据库事务

```sql
BEGIN TRANSACTION;
UPDATE t_user SET amount = amount - 100 WHERE username = 'BatMan';
UPDATE t_user set amount = amount + 100 WHERE username = 'SupserMan';
COMMIT;
-- ROLLBACK 
```



## 本地事务

本地事务的本质是对单个数据库, 单个会话的原子性操作

### 如何实现本地事务

手动事务编程: 手动写代码控制事务的提交回滚

```java
// 获取连接
Connection conn = getConnection();
// 关闭自动提交
conn.setAutoCommit(false);
Statement stmt1 = conn.prepareStatement(updateUser1SQL);
stmt1.executeUpdate();
Statement stmt2 = conn.prepareStatement(updateUser2SQL);
stmt2.executeUpdate();
conn.commit(); // or conn.rollback();
```

自动事务编程: Spring 通过 AOP 实现自动事务编程

*   配置数据源
*   配置事务管理器, 跟数据源匹配
*   切面和切入点, 决定给哪些业务什么方法配置事务
*   配置事务通知
*   将切入点和事务通知联系起来





## 什么是分布式事务？

事务的参与者, 服务器, 数据源, 事务管理器, 分布在不同的节点上. 原子性操作要么全部成功, 要么全部失败

<img src="http://www.milky.show/images/distributed/transaction/tran_35.png" alt="http://www.milky.show/images/distributed/transaction/tran_35.png" style="zoom:50%;" />

最终的解决办法是要有一个全局的事务管理器

| 事务类别   | 数据库   | 会话     | 类比     | 事务管理器     |
| ---------- | -------- | -------- | -------- | -------------- |
| 本地事务   | 单数据库 | 单会话   | 单机游戏 | 本地事务管理器 |
| 分布式事务 | 多数据源 | 多个会话 | 斗地主   | 全局事务管理器 |



### 三种分布式事务架构

#### 单一服务分布式事务

可以使用 Atomikos 解决

<img src="http://www.milky.show/images/distributed/transaction/tran_36.png" alt="http://www.milky.show/images/distributed/transaction/tran_36.png" style="zoom:50%;" />

#### 分库分表

通过中间件+数据库同步技术, mycat\shardingdb

<img src="http://www.milky.show/images/distributed/transaction/tran_37.png" alt="http://www.milky.show/images/distributed/transaction/tran_37.png" style="zoom:50%;" />

#### 多服务多数据源分布式事务

全局事务管理器(TM)和服务协调者, 共同协调

<img src="http://www.milky.show/images/distributed/transaction/tran_38.png" alt="http://www.milky.show/images/distributed/transaction/tran_38.png" style="zoom:50%;" />

### 解决方案分类

刚性事务: ACID(本地事务)

柔性事务: CAP\BASE(分布式事务管理)

| 事务类型 | 时间要求   | 一致性要求 | 应用类型        | 场景           |
| -------- | ---------- | ---------- | --------------- | -------------- |
| 刚性事务 | 立刻\马上  | 强一致性   | 局域网\企业应用 | 订单\日志      |
| 柔性事务 | 有时间弹性 | 最终一致性 | 互联网应用      | 付款\订单\收获 |

#### CAP 理论

数据一致性(Consistency):

服务可用性(Availability): 非故障节点在**合理的时间**内返回**合理的响应**.

分区容错性(Partition-tolerance): 集群可用性

**网络无法 100% 可靠, 分区其实是一个必然现象, 所以 P 是必须保证的.**

**CA 无法保证, 如果我们选择了 CA 而放弃了 P, 那么当发生分区现象时, 为了保证一致性, 这个时候必须拒绝请求, 但是 A 又不允许, 所以分布式系统理论上不可能选择 CA 架构, 只能选择 CP 或者 AP 架构.**

#### BASE 理论

**分布式事务, 只需要达到最终一致性(Eventual Consistency)即可**

基本可用(Basically Available): 集群基本可用

软状态(Soft state): 比如订单状态, 待付款, 已付款, 发货, 已签收, 已结束.

最终一致性(Eventual Consistency): 只要保证最终一致就可以



### 柔性事务解决方案

#### TCC(两阶段型, 补偿型), 二阶段2pc(二阶段提交协议)

TCC事务是Try、Commit、Cancel三种指令的缩写, 其逻辑模式类似于XA两阶段提交, 但是实现方式是在代码层面来人为实现。

订婚(Try) -> 结婚领证(成功, Commit \\ 失败, Cancel)

#### 可靠消息最终一致性(异步确保型)消息队列来保证事务的一致性

利用消息中间件来异步完成事务的后一半更新, 实现系统的最终一致性。这个方式避免了像XA协议那样的性能问题。

rocketmq 的消息具备事务性, 是可靠消息

#### 最大努力通知(非可靠消息, 定期校对)

利用消息中间件来异步完成事务的后一半更新, 实现系统的最终一致性。这个方式避免了像XA协议那样的性能问题。

activemq, rabbitmq, kafka 不具备事务性, 所以需要本地扫描不断尝试重发消息保证最终一致性, 类似滴滴发送短信通知用户付款



### XA 分布式事务协议

分布式事务用于在分布式系统中保证不同节点之间的数据一致性。分布式事务的实现有很多种, 最具有代表性的是由**Oracle Tuxedo**系统提出的**XA**分布式事务协议。

在魔兽世界这款游戏中, 副本组团打BOSS的时候, 为了更方便队长与队员们之间的协作, 队长可以发起一个“就位确认”的操作：

<img src="http://www.milky.show/images/distributed/transaction/tran_25.png" alt="http://www.milky.show/images/distributed/transaction/tran_25.png" style="zoom:50%;" />

当队员收到就位确认提示后, 如果已经就位, 就选择“是”, 如果还没就位, 就选择“否”。

<img src="http://www.milky.show/images/distributed/transaction/tran_26.png" alt="http://www.milky.show/images/distributed/transaction/tran_26.png" style="zoom:50%;" />

当队长收到了所有人的就位确认, 就会向所有队员们发布消息, 告诉他们开始打BOSS。

<img src="http://www.milky.show/images/distributed/transaction/tran_27.png" alt="http://www.milky.show/images/distributed/transaction/tran_27.png" style="zoom:50%;" />

相应的, 在队长发起就位确认的时候, 有可能某些队员还并没有就位：

<img src="http://www.milky.show/images/distributed/transaction/tran_28.png" alt="http://www.milky.show/images/distributed/transaction/tran_28.png" style="zoom:50%;" />

<img src="http://www.milky.show/images/distributed/transaction/tran_29.png" alt="http://www.milky.show/images/distributed/transaction/tran_29.png" style="zoom:50%;" />

<img src="http://www.milky.show/images/distributed/transaction/tran_30.png" alt="http://www.milky.show/images/distributed/transaction/tran_30.png" style="zoom:50%;" />

以上就是魔兽世界当中组团打BOSS的确认流程。这个流程和XA分布式事务协议的两阶段提交非常相似。

那么XA协议究竟是什么样子呢？在XA协议中包含着两个角色：**事务协调者**和**事务参与者**。让我们来看一看他们之间的交互流程：

**第一阶段：**

<img src="http://www.milky.show/images/distributed/transaction/tran_31.png" alt="http://www.milky.show/images/distributed/transaction/tran_31.png" style="zoom:50%;" />

在XA分布式事务的第一阶段, 作为事务协调者的节点会首先向所有的参与者节点发送Prepare请求。

在接到Prepare请求之后, 每一个参与者节点会各自执行与事务有关的数据更新, 写入Undo Log和Redo Log。如果参与者执行成功, 暂时不提交事务, 而是向事务协调节点返回“完成”消息。

当事务协调者接到了所有参与者的返回消息, 整个分布式事务将会进入第二阶段。

**第二阶段：**

<img src="http://www.milky.show/images/distributed/transaction/tran_32.png" alt="http://www.milky.show/images/distributed/transaction/tran_32.png" style="zoom:50%;" />

在XA分布式事务的第二阶段, 如果事务协调节点在之前所收到都是正向返回, 那么它将会向所有事务参与者发出Commit请求。

接到Commit请求之后, 事务参与者节点会各自进行本地的事务提交, 并释放锁资源。当本地事务完成提交后, 将会向事务协调者返回“完成”消息。

当事务协调者接收到所有事务参与者的“完成”反馈, 整个分布式事务完成。

**以上所描述的是XA两阶段提交的正向流程, 接下来我们看一看失败情况的处理流程：**

**第一阶段：**

<img src="http://www.milky.show/images/distributed/transaction/tran_33.png" alt="http://www.milky.show/images/distributed/transaction/tran_33.png" style="zoom:50%;" />

**第二阶段：**

<img src="http://www.milky.show/images/distributed/transaction/tran_34.png" alt="http://www.milky.show/images/distributed/transaction/tran_34.png" style="zoom:50%;" />



在XA的第一阶段, 如果某个事务参与者反馈失败消息, 说明该节点的本地事务执行不成功, 必须回滚。

于是在第二阶段, 事务协调节点向所有的事务参与者发送Abort请求。接收到Abort请求之后, 各个事务参与者节点需要在本地进行事务的回滚操作, 回滚操作依照Undo Log来进行。

**XA两阶段提交的不足**

1. **性能问题**

    XA协议遵循强一致性。在事务执行过程中, 各个节点占用着数据库资源, 只有当所有节点准备完毕, 事务协调者才会通知提交, 参与者提交后释放资源。这样的过程有着非常明显的性能问题。

2. **协调者单点故障问题**

    事务协调者是整个XA模型的核心, 一旦事务协调者节点挂掉, 参与者收不到提交或是回滚通知, 参与者会一直处于中间状态无法完成事务。

3. **丢失消息导致的不一致问题**

    在XA协议的第二个阶段, 如果发生局部网络问题, 一部分事务参与者收到了提交消息, 另一部分事务参与者没收到提交消息, 那么就导致了节点之间数据的不一致。

**如果避免XA两阶段提交的种种问题呢？有许多其他的分布式事务方案可供选择：**

1. XA三阶段提交

    XA三阶段提交在两阶段提交的基础上增加了CanCommit阶段, 并且引入了超时机制。一旦事务参与者迟迟没有接到协调者的commit请求, 会自动进行本地commit。这样有效解决了协调者单点故障的问题。但是性能问题和不一致的问题仍然没有根本解决。

2. MQ事务

    利用消息中间件来异步完成事务的后一半更新, 实现系统的最终一致性。这个方式避免了像XA协议那样的性能问题。

3. TCC事务

    TCC事务是Try、Commit、Cancel三种指令的缩写, 其逻辑模式类似于XA两阶段提交, 但是实现方式是在代码层面来人为实现。



### 假如没有分布式事务

在一系列微服务系统当中, 假如不存在分布式事务, 会发生什么呢？让我们以互联网中常用的交易业务为例子：

<img src="http://www.milky.show/images/distributed/transaction/tran_22.png" alt="http://www.milky.show/images/distributed/transaction/tran_22.png" style="zoom: 50%;" />

上图中包含了库存和订单两个独立的微服务, 每个微服务维护了自己的数据库。在交易系统的业务逻辑中, 一个商品在下单之前需要先调用库存服务, 进行扣除库存, 再调用订单服务, 创建订单记录。

正常情况下, 两个数据库各自更新成功, 两边数据维持着一致性。

<img src="http://www.milky.show/images/distributed/transaction/tran_23.png" alt="http://www.milky.show/images/distributed/transaction/tran_23.png" style="zoom:50%;" />

但是, 在非正常情况下, 有可能库存的扣减完成了, 随后的订单记录却因为某些原因插入失败。这个时候, 两边数据就失去了应有的一致性。

<img src="http://www.milky.show/images/distributed/transaction/tran_24.png" alt="http://www.milky.show/images/distributed/transaction/tran_24.png" style="zoom:50%;" />

**这种情况, 库存减少了, 却没有相应的订单, 这种时候必须要保证数据的一致性. 单数据源的一致性依靠单机事务来保证, 多数据源就要依靠分布式事务**





## 分布式事务解决方案的关系

### DTP-XA-二阶段提交协议(2pc tcc)

#### DTP模型

分布式事务处理模型标准, 由几个巨头公司提出来的一种标准

##### 模型元素(5 个)

应用程序(Application Program, 简称 AP):

资源管理器(Resource Manager, 简称 RM): 如数据库, 文件系统等, 并提供访问资源的方式

事务管理器(Transaction Manager, 简称 TM): 负责分配事务唯一标识, 监控事务的执行进度, 并负责事务的提交, 回滚等.

通信资源管理器(Communication Resource Manager, 简称 CRM): 控制一个 TM 域(TM domain)内或者跨 TM 域的分布式应用之间的通信

通信协议(Communication Protocol, 简称 CP):

##### 模型实例

<img src="http://www.milky.show/images/distributed/transaction/tran_39.png" alt="http://www.milky.show/images/distributed/transaction/tran_39.png" style="zoom:50%;" />

#### XA 规范

XA 规范的最主要作用是定义了 RM-TM 之间的交互交口, 是 DTP 模型的一部分

<img src="http://www.milky.show/images/distributed/transaction/tran_40.png" alt="http://www.milky.show/images/distributed/transaction/tran_40.png" style="zoom:50%;" />

#### XA 规范与二阶段提交协议的关系

XA 规范定义了两阶段提交协议中需要使用到的接口, XA 和 2PC 是相互参考的

<img src="http://www.milky.show/images/distributed/transaction/tran_41.png" alt="http://www.milky.show/images/distributed/transaction/tran_41.png" style="zoom:50%;" />

### XA-JTA-atomikos 的关系

JTA, Java Transaction Api, XA 的 java 实现版, 某种程度上可以认为 JTA 规范是 XA 规范的 Java 版, 在 JTA 中, 事物管理器抽象为 javax.transaction.TransactionManager 接口, 并通过底层事物服务(即 JTS)实现

JTA 仅仅定义了接口

具体的实现如下

*   J2EE 容器所提供的 JTA 实现 JBOSS
*   第三方独立的 JTA 实现, JOTM, Atomikos, 用于 Tomcat, Jetty 以及普通的 Java 引用
*   Atomikos, JTA 的实现, 用于 tomcat 容器



### 二阶段 2pc 与 tcc 的关系

tcc 是二阶段协议的一种, 只不过 tcc 做了一些优化, 在 try 阶段只锁定了一部分资源, 剩余的资源其他事务还可以使用.

**二阶段尽量保证了数据一致性, 适合对数据一致要求很高的关键领域, 实现复杂, 牺牲了可用性, 对性能影响较大, 不适合高并发场景, 如分布式系统跨接口调用**

**tcc 跟 2pc 比起来, 实现及流程相对接单一些, 但数据的一致性比 2PC 差一些, 在 2,3 步骤中都有可能失败, TCC 属于应用层的一种补偿方式, 需要程序员在实现的时候写很多的补偿代码, 在一些场景中, 一些业务流程可能用 TCC 不太好定义及处理, 在代码无法完成时, 可以通过手工干预.**



## 分布式事务实战-Atomikos

**Atomikos 适合单服务多数据源的场景**

<img src="http://www.milky.show/images/distributed/transaction/tran_42.png" alt="http://www.milky.show/images/distributed/transaction/tran_42.png" style="zoom:50%;" />

我们准备 2 个数据库, 分别是订单数据库(tran_order)和日志数据库(tran_log), 订单数据库用于接收用户订单, 日志数据库用于记录用户的订单创建操作

```sql
CREATE TABLE order_info (
  id          INT    NOT NULL,
  money       DOUBLE NOT NULL,
  user_id     VARCHAR(20)  DEFAULT NULL,
  address     VARCHAR(200) DEFAULT NULL,
  create_time DATETIME     DEFAULT NULL,
  PRIMARY KEY (id)
);
```

```sql
CREATE TABLE log_info (
  id          INT NOT NULL,
  create_time DATETIME DEFAULT NULL,
  content     LONGTEXT,
  PRIMARY KEY (id)
);
```

### 实现步骤

1.  公共数据源代理的配置
    1.  配置两个数据源
    2.  XA 数据源统一管理
    3.  分别配置两个 SessionFactory
    4.  管理各自的 Mapper
2.  配置全局事务管理器(atomikos 提供)
3.  将全局事务管理器集成到 spring 中
4.  切面管理和事务通知管理
5.  将切入点和事务通知关联起来

















## 微服务系统的最大挑战

### 数据一致性问题

数据的并发访问, 修改

不同请求之间的数据隔离

多个服务共同完成一个业务请求, 保证都完成或都失败

发生异常时的数据回滚

### 单服务系统如何解决这些问题?

数据的并发访问, 修改 - **事务**

不同请求之间的数据隔离 - **事务**

多个服务共同完成一个业务请求, 保证都完成或都失败 - **事务**

发生异常时的数据回滚 - **事务**

## Spring事务机制

### Spring事务管理

提供同意的API接口支持不同的资源

提供声明式事务

方便与Spring框架继承

多个资源的事务管理, 同步

### Spring事务抽象

**事务管理器: PlatformTransactionManager**

```java
public interface PlatformTransactionManager {
	// 通过事务定义获取事务实例
    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;
	// 提交事务
    void commit(TransactionStatus status) throws TransactionException;
	// 回滚事务
    void rollback(TransactionStatus status) throws TransactionException;
}
```

* DataSourceTransactionManager
* JpaTransactionManager

* JmsTransactionManager
* JtaTransactionManager

事务定义: TransactionDefinition**

```java
public interface TransactionDefinition {
	// 获取事务传播属性
	int getPropagationBehavior();
	// 获取事务隔离级别
	int getIsolationLevel();
	// 获取事务名称
	String getName();
	// 获取事务超时时间
	int getTimeout();
	// 事务是否是只读
	boolean isReadOnly();
}
```

**事务隔离机制**

```
// 默认使用数据库的隔离机制, mysql 默认的是可重复读
int ISOLATION_DEFAULT = -1;
int ISOLATION_READ_UNCOMMITTED = Connection.TRANSACTION_READ_UNCOMMITTED;
int ISOLATION_READ_COMMITTED = Connection.TRANSACTION_READ_COMMITTED;
int ISOLATION_REPEATABLE_READ = Connection.TRANSACTION_REPEATABLE_READ;
int ISOLATION_SERIALIZABLE = Connection.TRANSACTION_SERIALIZABLE;
```

| 事务的隔离级别                                        | 脏读 | 不可重复读 | 幻读 |
| ----------------------------------------------------- | ---- | ---------- | ---- |
| Read uncommitted                                      | √    | √          | √    |
| Read committed--Sql Server , Oracle                   | ×    | √          | √    |
| Repeatable read--[MySQL](http://lib.csdn.net/base/14) | ×    | ×          | √    |
| Serializable                                          | ×    | ×          | ×    |

**事务传播机制**

如果有两个service方法, serviceA的方法调用serviceB的方法, 这两个service的方法都是在事务中执行的,

事务是如何在这两个事务中传播的就是事务传播机制解决的问题

```java
// 如果A开启事务B就加入, A不开启B就开启新事务, 默认就是这个级别
int PROPAGATION_REQUIRED = 0;
// 如果A开启事务B就加入, A不开启B就不开启
int PROPAGATION_SUPPORTS = 1;
// A必须在事务中, 如果不在事务中B会报错, 一般用在被调用者上
int PROPAGATION_MANDATORY = 2;
// 不管A在不在事务中, B都会新建事务
int PROPAGATION_REQUIRES_NEW = 3;
// A不管在不在事务中, B都会挂起事务
int PROPAGATION_NOT_SUPPORTED = 4;
// A在事务中就会抛出异常, A不在事务中就可以正常运行, 一般用在被调用者上
int PROPAGATION_NEVER = 5;
// 如果当前存在事务, 则在嵌套事务内执行。如果当前没有事务, 则执行与PROPAGATION_REQUIRED类似的操作。(这个和REQUIRED区别在于一个是加入到一个事务, 一个是在嵌套事务运行)
int PROPAGATION_NESTED = 6;
```

可以这么理解, 大多数情况下, 效果和REQUIRED一样。但是有一种情况, 就是上述代码中, 被调用者事务传播属性为NESTED, 当出现异常时,  调用者把departmentService try, catch了。这个区别与REQUIRED的并不会报错, 而且addEmpByNested方法不会回滚, 只有addDeptByNested回滚了。
 大概原理：当被调用者使用PROPAGATION_NESTED时, 底层的数据源必须基于JDBC 3.0, 并且实现者需要支持保存点事务机制。按上述代码来说(去掉try, catch), 当执行到addDeptByNested这个方法时, Spring会为它创建一个内部的嵌套事务, 如果addDeptByNested执行失败, 则事务回滚到addDeptByNested之前的点, 此时如果不抛异常, 则不会回滚。这个嵌套事务, 是addEmpByNested的一部分, 只有外层事务提交了, 内层的嵌套事务才会一起提交, 这也是与REQUIRED(加入事务), REQUIRES_NEW(开启新事务)的区别。
 还值得一提的是, NESTED是嵌套的意思, 其实并不是只有NESTED用于嵌套, 只要理解上述7个传播机制的意思, 都可以嵌套用。

| 传播属性                  | 调用者                                                       | 被调用者  |
| ------------------------- | ------------------------------------------------------------ | --------- |
| PROPAGATION_REQUIRED      | T1                                                           | T1        |
|                           | 无                                                           | T2        |
| PROPAGATION_SUPPORTS      | T1                                                           | T1        |
|                           | 无                                                           | 无        |
| PROPAGATION_MANDATORY     | T1                                                           | T1        |
|                           | 无                                                           | Exception |
| PROPAGATION_REQUIRES_NEW  | T1                                                           | T2        |
|                           | 无                                                           | T2        |
| PROPAGATION_NOT_SUPPORTED | T1                                                           | 无        |
|                           | 无                                                           | 无        |
| PROPAGATION_NEVER         | T1                                                           | Exception |
|                           | 无                                                           | 无        |
| NESTED                    | 设置savePoint, 一旦事物回滚, 事物将回滚到savePoint处, 交由客户响应提交/回滚 |           |

**事务状态: TransactionStatus**

```
public interface TransactionStatus extends SavepointManager, Flushable {

   boolean isNewTransaction();

   boolean hasSavepoint();

   void setRollbackOnly();

   boolean isRollbackOnly();

   boolean isCompleted();

}
```

## Spring事务实例

代码方式, 标签方式实现事务

JPA事务管理

使用MySQL数据库(支持事务)

```java
@Autowired
private CustomerRepository customerRepository;
@Autowired
private PlatformTransactionManager transactionManager;

public Customer create(Customer customer) {
    LOG.info("CustomerService In Code create customer:{}", customer.getUsername());
    if (customer.getId() != null) {
        throw new RuntimeException("用户已经存在");
    }
    DefaultTransactionDefinition def = new DefaultTransactionDefinition();
    def.setIsolationLevel(TransactionDefinition.ISOLATION_SERIALIZABLE);
    def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
    def.setTimeout(15);
    TransactionStatus status = transactionManager.getTransaction(def);
    try {
        customer.setUsername("Code:" + customer.getUsername());
        customerRepository.save(customer);
        transactionManager.commit(status);
        return customer;
    } catch (Exception e) {
        transactionManager.rollback(status);
        throw e;
    }
}
```

```java
@Transactional
public Customer create(Customer customer) {
    LOG.info("CustomerService In Annotation create customer:{}", customer.getUsername());
    if (customer.getId() != null) {
        throw new RuntimeException("用户已经存在");
    }
    customer.setUsername("Annotation:" + customer.getUsername());
    return customerRepository.save(customer);
}
```

### SpringJMS事务实例

SpringBoot中使用JMS

SpringBootActiveMQStarter

内置的可运行的ActiveMQ服务

实现读写ActiveMQ的事务

#### SpringJMS事务类型

JMS Session管理的事务 - 原生事务

外部管理的事务 - JmsTransactionManager(底层还是使用JMS Session), JTA

### Spring外部事务与JTA

#### Spring内部事务

Spring容器管理事务的生命周期

通过Spring事务接口调用

业务代码与具体事务的实现无关

<img src="http://www.milky.show/images/distributed/transaction/tran_1.png" alt="http://www.milky.show/images/distributed/transaction/tran_1.png" style="zoom:67%;" />

#### Spring外部(全局)事务

外部事务管理器提供事务管理

通过Spring事务接口, 调用外部管理器

使用JNDI等方式获取外部事务管理器的实例

外部事务管理器一般由应用服务器提供, 如JBoss等

#### 外部(全局)事务JTA与SpringJTA实现

外部事务管理器提供JTA事务管理

JTA事务管理器可以管理多个数据源

通过2阶段提交实现多数据源的事务

**在一个服务中使用2个数据源保证事务**

```
1. Start messaging transaction
2. Receive message
3. Start database transaction
4. Update database
5. Commit database transaction
6. Commit messaging transaction
```

#### JTA与XA

TransactionManager接口

XAResource接口

XID

两阶段提交

<img src="http://www.milky.show/images/distributed/transaction/tran_2.png" alt="http://www.milky.show/images/distributed/transaction/tran_2.png" style="zoom:67%;" />

<img src="http://www.milky.show/images/distributed/transaction/tran_3.png" alt="http://www.milky.show/images/distributed/transaction/tran_3.png" style="zoom:67%;" />

#### JTA分布式事务实例-单数据源

使用Spring JTA事务管理

Atomikos外部事务管理器提供JTA事务管理(引入jta的jar包即可)

使用一个数据库 - 单数据源

#### JTA分布式事务实例-多数据源

使用Spring JTA事务管理

Atomikos外部事务管理器提供JTA事务管理

多个数据源: DB, MQ



## 分布式系统

将不同的组件分布在不同的服务器上, 给用户提供一个可靠, 统一的服务

### 分布式的基本原则

C: 一致性

* 强一致性(几乎不可能)
* 弱一致性(要考虑多个机器的回滚, 比较复杂)
* **最终一致性**(在弱一致性的基础上, 通过重试, 定时任务扫描或者人为干预的形式达到最终一致性)

A: 可用性(单一服务集群部署)

P: 分区容错性(拆分服务, 分布式部署)

### BASE理论

Basically Available(基本可用)

Soft state(软状态)

Eventually consistent(最终一致性)

相当于CAP原则中的一致性和可用性的权衡结果

### 几种分布式形式

多数据源

<img src="http://www.milky.show/images/distributed/transaction/tran_4.png" alt="http://www.milky.show/images/distributed/transaction/tran_4.png" style="zoom:67%;" />

多服务

<img src="http://www.milky.show/images/distributed/transaction/tran_5.png" alt="http://www.milky.show/images/distributed/transaction/tran_5.png" style="zoom:67%;" />

SOA

<img src="http://www.milky.show/images/distributed/transaction/tran_6.png" alt="http://www.milky.show/images/distributed/transaction/tran_6.png" style="zoom:67%;" />

微服务架构

<img src="http://www.milky.show/images/distributed/transaction/tran_7.png" alt="http://www.milky.show/images/distributed/transaction/tran_7.png" style="zoom:67%;" />

### 分布式系统需要考虑的问题

服务拆分

数据拆分

计算拆分

服务状态以及异常处理

### 微服务架构的组成

服务发现与注册(注册中心)

服务网管与负载均衡

监控与熔断机制

配置, 消息等



## Spring Cloud微服务架构

### 微服务架构组成

服务

服务注册中心

网关

服务间调用协议

### Spring Cloud微服务架构

Spring Cloud Netfix微服务架构

* 服务注册中心: Eureka
* 网管: Zuul
* 声明式Rest调用接口: Feign Client
* 负载均衡: Ribbon
* 监控, 熔断组件: Hystrix与Hystrix Dashboard

Spring Cloud Config配置服务器

* 配置方式: 文件夹, Git, SVN, DB
* 配置服务器
* 服务 -> 配置服务器 -> 配置

Spring Cloud Bus事件总线



## 多数据源事务

在多个数据源中实现事务

### JTA实现分布式事务

<img src="http://www.milky.show/images/distributed/transaction/tran_8.png" alt="http://www.milky.show/images/distributed/transaction/tran_8.png" style="zoom:67%;" />

### 不使用JTA实现分布式事务

<img src="http://www.milky.show/images/distributed/transaction/tran_9.png" alt="http://www.milky.show/images/distributed/transaction/tran_9.png" style="zoom:67%;" />

如果在6的位置发生错误, 会导致DB不能回滚, 这是我们要解决的问题

#### 多个资源的事务同步方法

XA与最后资源博弈

1. Start messaging transaction
1. Receive message
1. Start JTA transaction on DB
1. Update database
1. Phase-1 Commit on DB transaction
1. Commit messaging transaction
1. Phase-2 Commit on DB transaction

共享资源

* 两个数据源共享同一个底层资源
* ActiveMQ使用DB作为存储
* 使用DB上的connection控制事务提交
* 需要数据源支持

最大努力一次提交

* 依次提交事务
* 可能出错
* 通过AOP或Listener实现事务直接的同步

链式事务

* 定义一个事务链
* 多个事务在一个事务管理器里一次提交
* 可能出错

### 如何选择

#### 根据一致性要求

强一致性事务: JTA(性能差, 只适用于单个服务内)

弱, 最终一致性事务: 最大努力一次提交, 链式事务(设计相应的错误处理机制)

#### 根据场景

MQ-DB: 最大努力一次提交 + 重试

多个DB: 链式事务管理

多个数据源: 链式事务, 或其他事务同步方式



### 实例一:

MySQL + MySQL

链式事务: DataSouceTransactionManager + DataSouceTransactionManager

不处理重试

### 实例二:

MySQL + MySQL

链式事务: JpaTransactionManager + DataSourceTransactionManager

不处理重试

### 实例三

JMS + DB

ActiveMQ + MySQL

最大努力一次提交: TransactionAwareConnectionFactoryProxy

## 分布式系统唯一性ID: GUID

分布式系统的全局唯一标识

UUID: 生成唯一ID的规范

用于唯一标识, 处理重复消息

### 常见唯一ID生成方式

数据库自增id: 所有的微服务的数据要放到同一个库中, 实现简单

uuid: 唯一ID标准, 128位, 几种版本

MongoDB的ObjectID: 时间戳 + 机器ID + 近程ID + 序号

Redis的NCR操作, Zookeeper节点的版本号

### 使用何种方式

自定id: 考虑安全性, 部署

时间有序: 便于通过id判断创建时间

长度, 是否数字类型: 便于创建索引



## 微服务架构事务实现模式与技术

### 微服务架构事务实现的几种模式

消息驱动模式: Message Driver

事件溯源模式: Event Sourcing

TCC模式: Try-Confirm-Cancel

### 幂等性

幂等操作: 任意多次执行所产生的影响, 与一次执行的影响相同

方法幂等性: 使用同样的参数调用一个方法多次, 与调用一次结果相同

接口幂等性: 接口被重复调用, 结果一致

#### 微服务接口的幂等性

重要性: 经常需要通过重试实现分布式事务的最终一致性

GET方法不会对系统产生副作用, 具有幂等性

POST, PUT, DELETE方法的实现需要满足幂等性

### 微服务架构的事务问题

服务间调用操作的回滚

服务间调用失败的重试问题

### 消息驱动的分布式事务实现

事件不需要持久化保存

消息只是为了更新业务数据的状态, 数据库才是一等数据

不要求所有的数据操作都通过消息驱动

<img src="http://www.milky.show/images/distributed/transaction/tran_10.png" alt="http://www.milky.show/images/distributed/transaction/tran_10.png" style="zoom:67%;" />

#### 需要注意的问题

消息中间件需要支持事务

如何处理消息重试

发生业务异常时回滚操作

#### 系统错误的处理

将出错未处理的消息写到失败队列, 进行相应的回滚操作

通过定时任务检查超时订单, 对未完成的订单做自动回滚

保存出错消息, 人工处理

#### 实例

Order服务, User服务, Ticket服务

ActiveMQ作为消息中间件

错误处理: 定时任务检查并回滚

幂等性: 实现方法的幂等性

<img src="http://www.milky.show/images/distributed/transaction/tran_13.png" alt="http://www.milky.show/images/distributed/transaction/tran_13.png" style="zoom:67%;" />

curl -X POST -d '{"customerId": 1, "title": "new_order", "amount": 100, "ticketNum": 100}' -H 'Content-Type: application/json' http://localhost:9601/order/api/order

<img src="http://www.milky.show/images/distributed/transaction/tran_11.png" alt="http://www.milky.show/images/distributed/transaction/tran_11.png" style="zoom:67%;" />

<img src="http://www.milky.show/images/distributed/transaction/tran_12.png" alt="http://www.milky.show/images/distributed/transaction/tran_12.png" style="zoom:67%;" />

<img src="http://www.milky.show/images/distributed/transaction/tran_14.png" alt="http://www.milky.show/images/distributed/transaction/tran_14.png" style="zoom:67%;" />

##### 异常订单处理

定时处理异常订单: 1. 未被处理完成 2. 未被按失败订单处理

解锁票, 撤销交票

对于余额之类的重要数据, 可能使用人工处理

##### 实现锁票的安全性

利用@JmsListener设置一个消费者, 不适用于多实例

使用事务和数据库锁的特性

分布式锁



## 事件溯源模式的分布式事务实现

事件作为一等数据保存

统一的事件管理器和接口, 数据更新都由事件产生

数据库中的数据当前状态根据事件的聚合产生

聚合数据可以保存在数据库中, 可以根据事件重新生成

<img src="http://www.milky.show/images/distributed/transaction/tran_15.png" alt="http://www.milky.show/images/distributed/transaction/tran_15.png" style="zoom:67%;" />

### 事件溯源模式的优点

历史重现: 从事件中重新生成视图数据库

方便的数据流处理与报告生成

性能

服务的松耦合

### 事件溯源模式的缺点

只能保证事务的最终一致性

设计和开发的思维转变, 学习成本

事件结构的改变

扩展性: Event Store的分布式实现, 事件的分布式处理

### 事件溯源的数据一致性

一个事件只处理一个服务的数据

保证事件的至少一次处理, 幂等性

业务请求的错误处理: 多次重试失败, 网络异常, 服务不可用

### 实例

<img src="http://www.milky.show/images/distributed/transaction/tran_16.png" alt="http://www.milky.show/images/distributed/transaction/tran_16.png" style="zoom:67%;" />

<img src="http://www.milky.show/images/distributed/transaction/tran_17.png" alt="http://www.milky.show/images/distributed/transaction/tran_17.png" style="zoom:67%;" />

### 事件溯源与Axon框架

#### 使用Axon框架的设计过程

领域模型设计: 账户Account

业务 - Command - Command处理: 创建账户, 存款, 取款

数据 - Event - Event处理: 账户创建, 存款, 取款

将数据保存到数据库: 聚合数据 - 映射到 - 视图数据

查询Query: 查询账户

## TCC模式的分布式事务实现

### 事务管理的过程

do

commit / rollback

### JTA事务管理的过程

do

prepare / rollback

commit / rollback

### TCC模式的事务管理

Try

Commit(Confirm) / Cancel

### TCC模式的实现思路

每个需要实现事务的接口, 都需要实现3个接口

tryXx(): 业务检查, 预留资源

confirmXx(): 执行业务, 使用资源

cancelXx(): 回滚业务, 释放资源

<img src="http://www.milky.show/images/distributed/transaction/tran_18.png" alt="http://www.milky.show/images/distributed/transaction/tran_18.png" style="zoom:67%;" />

<img src="http://www.milky.show/images/distributed/transaction/tran_19.png" alt="http://www.milky.show/images/distributed/transaction/tran_19.png" style="zoom:67%;" />

### TCC模式协调器的功能

接管事务管理, 类似JTA的独立事务管理器(非两阶段提交)

保存每个资源上的事务记录: 跟踪状态, 检查超时

保证每个资源上的事务性

处理各种错误: 超时, 重试, 网络异常, 服务不可用

### TCC模式实现分布式事务

借鉴XA的统一资源管理, 又不是两阶段提交

不同资源之间没有锁, 事务过程数据没有锁, 没有隔离

出错时可能多次调用Confirm/Cancel方法, 以及顺序无法保证

Confirm/Cancel方法需要满足幂等性, 即重复调用时结果一致

<img src="http://www.milky.show/images/distributed/transaction/tran_20.png" alt="http://www.milky.show/images/distributed/transaction/tran_20.png" style="zoom: 50%;" />

### TCC模式下的业务方法 - 思路1: REST风格接口

```
@RestController
public class UserResource{
    @Transactional
    public void tryCharge(DTO dto){}
    @Transactional
    public void confirmCharge(DTO dto){}
    @Transactional
    public void cancelCharge(DTO dto){}
}
```

<img src="http://www.milky.show/images/distributed/transaction/tran_21.png" alt="http://www.milky.show/images/distributed/transaction/tran_21.png" style="zoom:67%;" />

Try方法返回confirm/cancel时调用的接口URI: user/charge/{userId}/{orderId}

Confirm: PUT

Cancel: DELETE

### TCC模式下的业务方法 - 思路2: Service规范

```
public interface TccMethod<P extends TccRequest<R>, R extends Serializable>{
    R doTry(P param);
    void doConfirm(P param);
    void doCancel(P param);
}
```

将一个业务逻辑封装成TccMethod类来调用

将协调器保存TccMethod, TccRequest, TccResponse

服务会有一个专门的接口接收协调器的请求, 处理Confirm/Cancel

服务不需要开放Confirm/Cancel接口

### TCC模式出错处理

1. order服务创建订单
1. order服务调用user服务tryCharge()
1. order服务调用ticket服务tryTicketMove()
1. 协调器调用user服务confirmCharge()
1. 协调器调用ticket服务confirmCharge()
1. 提交事务

### 基于TCC模式的开发

没有统一的规范, 也没有广泛使用框架

协调器的开发比较复杂, 需要保证各种情况出错下的最终一致性

协调器监控事务: 事务及其参数, 返回值保存在数据库中

TCC模式的服务组件的复用性

### 实现TCC模式的框架

https://github.com/liuyangming/ByteTCC

https://github.com/QNJR-GROUP/EasyTransaction

https://github.com/changmingxie/tcc-transaction