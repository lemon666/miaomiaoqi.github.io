---
 
layout: post
title: "分布式事务"
categories: [Distributed]
description:
keywords:
---

* content
{:toc}




## 事务

什么是事务？举个生活中的例子：你去小卖铺买东西，“一手交钱，一手交货”就是一个事务的例子，交钱和交货必

须全部成功，事务才算成功，任一个活动失败，事务将撤销所有已成功的活动。

明白上述例子，再来看事务的定义：

事务可以看做是一次大的活动，它由不同的小活动组成，这些活动要么全部成功，要么全部失败。

**对同一数据源, 进行一组相关的 sql 操作, 要么全部成功, 要么全部失败.**



### 本地事务

在计算机系统中，更多的是通过关系型数据库来控制事务，这是利用数据库本身的事务特性来实现的，因此叫数据库事务，由于应用主要靠关系数据库来控制事务，而数据库通常和应用在同一个服务器，所以基于关系型数据库的事务又被称为本地事务。

数据库事务在实现时会将一次事务涉及的所有操作全部纳入到一个不可分割的执行单元，该执行单元中的所有操作要么都成功，要么都失败，只要其中任一操作执行失败，都将导致整个事务的回滚

### 事务的四个特性

原子性(Atomicity): 构成事务的所有操作，要么都执行完成，要么全部不执行，不可能出现部分成功部分失败的情况。

一致性(Consistency): 在事务执行前后，数据库的一致性约束没有被破坏。比如：张三向李四转100元，转账前和转账后的数据是正确状态这叫一致性，如果出现张三转出100元，李四账户没有增加100元这就出现了数据错误，就没有达到一致性。

隔离性(Isolation): 隔离性，数据库中的事务一般都是并发的，隔离性是指并发的两个事务的执行互不干扰，一个事务不能看到其他事务运行过程的中间状态。通过配置事务隔离级别可以避脏读、重复读等问题。

持久性(Durability): 事务完成之后，该事务对数据的更改会被持久化到数据库，且不会被回滚。

### 事务的隔离级别

根据两个事务之间的干扰性强弱, 划分为几个级别

读未提交\读已提交\可重复度\串行化

**脏读**: 事务 a, 读到了事务 b 未提交的数据.

**不可重复度**: 两次读到的数据不一致

**幻读**: 一个事务在查询, 另一个事务在做插入或者删除, 此时就会出现幻读

| 事务的隔离级别                                        | 脏读 | 不可重复读 | 幻读 |
| ----------------------------------------------------- | ---- | ---------- | ---- |
| Read uncommitted                                      | √    | √          | √    |
| Read committed--Sql Server , Oracle                   | ×    | √          | √    |
| Repeatable read--[MySQL](http://lib.csdn.net/base/14) | ×    | ×          | √    |
| Serializable                                          | ×    | ×          | ×    |

## 什么是分布式事务？

分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操作，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务，例如用户注册送积分事务、创建订单减库存事务，银行转账事务等都是分布式事务。

我们知道本地事务依赖数据库本身提供的事务特性来实现，因此以下逻辑可以控制本地事务：

```sql
begin transaction；
// 1.本地数据库操作：张三减少金额
// 2.本地数据库操作：李四增加金额
commit transation;
```

但是在分布式环境下，会变成下边这样：

```sql
begin transaction；
// 1.本地数据库操作：张三减少金额
// 2.远程调用：让李四增加金额
commit transation;
```

可以设想，当远程调用让李四增加金额成功了，由于网络问题远程调用并没有返回，此时本地事务提交失败就回滚了张三减少金额的操作，此时张三和李四的数据就不一致了。

因此在分布式架构的基础上，传统数据库事务就无法使用了，张三和李四的账户不在一个数据库中甚至不在一个应用系统里，实现转账事务需要通过远程调用，由于网络问题就会导致分布式事务问题。

最终的解决办法是要有一个全局的事务管理器

| 事务类别   | 数据库   | 会话     | 类比     | 事务管理器     |
| ---------- | -------- | -------- | -------- | -------------- |
| 本地事务   | 单数据库 | 单会话   | 单机游戏 | 本地事务管理器 |
| 分布式事务 | 多数据源 | 多个会话 | 斗地主   | 全局事务管理器 |



### 单一服务分布式事务

单体系统访问多个数据库实例 当单体系统需要访问多个数据库（实例）时就会产生分布式事务。 比如：用户信息和订单信息分别在两个MySQL实例存储，用户管理系统删除用户信息，需要分别删除用户信息及用户的订单信息，由于数据分布在不同的数据实例，需要通过不同的数据库链接去操作数据，此时产生分布式事务。 简言之：跨数据库实例产生分布式事务。

可以使用 Atomikos 解决

<img src="http://www.milky.show/images/distributed/transaction/tran_36.png" alt="http://www.milky.show/images/distributed/transaction/tran_36.png" style="zoom:50%;" />

### 分库分表

通过中间件+数据库同步技术, mycat\shardingdb

<img src="http://www.milky.show/images/distributed/transaction/tran_37.png" alt="http://www.milky.show/images/distributed/transaction/tran_37.png" style="zoom:50%;" />

### 多服务多数据源分布式事务

典型的场景就是微服务架构 微服务之间通过远程调用完成事务操作。 比如：订单微服务和库存微服务，下单的同时订单微服务请求库存微服务减库存。 简言之：跨JVM进程产生分布式事务。

全局事务管理器(TM)和服务协调者, 共同协调

<img src="http://www.milky.show/images/distributed/transaction/tran_38.png" alt="http://www.milky.show/images/distributed/transaction/tran_38.png" style="zoom:50%;" />











#### CAP 理论

数据一致性(Consistency):

服务可用性(Availability): 非故障节点在**合理的时间**内返回**合理的响应**.

分区容错性(Partition-tolerance): 集群可用性

**网络无法 100% 可靠, 分区其实是一个必然现象, 所以 P 是必须保证的.**

**CA 无法保证, 如果我们选择了 CA 而放弃了 P, 那么当发生分区现象时, 为了保证一致性, 这个时候必须拒绝请求, 但是 A 又不允许, 所以分布式系统理论上不可能选择 CA 架构, 只能选择 CP 或者 AP 架构.**

#### BASE 理论

**分布式事务, 只需要达到最终一致性(Eventual Consistency)即可**

基本可用(Basically Available): 集群基本可用

软状态(Soft state): 比如订单状态, 待付款, 已付款, 发货, 已签收, 已结束.

最终一致性(Eventual Consistency): 只要保证最终一致就可以



### 柔性事务解决方案

#### TCC(两阶段型, 补偿型), 二阶段2pc(二阶段提交协议)

TCC事务是Try、Commit、Cancel三种指令的缩写, 其逻辑模式类似于XA两阶段提交, 但是实现方式是在代码层面来人为实现。

订婚(Try) -> 结婚领证(成功, Commit \\ 失败, Cancel)

#### 可靠消息最终一致性(异步确保型)消息队列来保证事务的一致性

利用消息中间件来异步完成事务的后一半更新, 实现系统的最终一致性。这个方式避免了像XA协议那样的性能问题。

rocketmq 的消息具备事务性, 是可靠消息

#### 最大努力通知(非可靠消息, 定期校对)

利用消息中间件来异步完成事务的后一半更新, 实现系统的最终一致性。这个方式避免了像XA协议那样的性能问题。

activemq, rabbitmq, kafka 不具备事务性, 所以需要本地扫描不断尝试重发消息保证最终一致性, 类似滴滴发送短信通知用户付款







## 分布式事务基础理论

### CAP 理论

CAP是 Consistency、Availability、Partition tolerance三个词语的缩写，分别表示一致性、可用性、分区容忍
性。
下边我们分别来解释：
为了方便对CAP理论的理解，我们结合电商系统中的一些业务场景来理解CAP。
如下图，是商品信息管理的执行流程：

![http://www.milky.show/images/distributed/transaction/tran_1.png](http://www.milky.show/images/distributed/transaction/tran_1.png)

整体执行流程如下：
1、商品服务请求主数据库写入商品信息（添加商品、修改商品、删除商品）
2、主数据库向商品服务响应写入成功。
3、商品服务请求从数据库读取商品信息。
C - Consistency：
一致性是指写操作后的读操作可以读取到最新的数据状态，当数据分布在多个节点上，从任意结点读取到的数据都
是最新的状态。
上图中，商品信息的读写要满足一致性就是要实现如下目标：
1、商品服务写入主数据库成功，则向从数据库查询新数据也成功。
2、商品服务写入主数据库失败，则向从数据库查询新数据也失败。
如何实现一致性？
1、写入主数据库后要将数据同步到从数据库。
2、写入主数据库后，在向从数据库同步期间要将从数据库锁定，待同步完成后再释放锁，以免在新数据写入成功
后，向从数据库查询到旧的数据。
分布式系统一致性的特点：
1、由于存在数据同步的过程，写操作的响应会有一定的延迟。
2、为了保证数据一致性会对资源暂时锁定，待数据同步完成释放锁定资源。
3、如果请求数据同步失败的结点则会返回错误信息，一定不会返回旧数据。
A - Availability ：
可用性是指任何事务操作都可以得到响应结果，且不会出现响应超时或响应错误。
上图中，商品信息读取满足可用性就是要实现如下目标：
1、从数据库接收到数据查询的请求则立即能够响应数据查询结果。
2、从数据库不允许出现响应超时或响应错误。
如何实现可用性？
1、写入主数据库后要将数据同步到从数据库。
2、由于要保证从数据库的可用性，不可将从数据库中的资源进行锁定。
3、即时数据还没有同步过来，从数据库也要返回要查询的数据，哪怕是旧数据，如果连旧数据也没有则可以按照
约定返回一个默认信息，但不能返回错误或响应超时。
分布式系统可用性的特点：
1、 所有请求都有响应，且不会出现响应超时或响应错误。
P - Partition tolerance ：
通常分布式系统的各各结点部署在不同的子网，这就是网络分区，不可避免的会出现由于网络问题而导致结点之间
通信失败，此时仍可对外提供服务，这叫分区容忍性。
上图中，商品信息读写满足分区容忍性就是要实现如下目标：
1、主数据库向从数据库同步数据失败不影响读写操作。
2、其一个结点挂掉不影响另一个结点对外提供服务。
如何实现分区容忍性？
1、尽量使用异步取代同步操作，例如使用异步方式将数据从主数据库同步到从数据，这样结点之间能有效的实现
松耦合。
2、添加从数据库结点，其中一个从结点挂掉其它从结点提供服务。
分布式分区容忍性的特点：
1、分区容忍性分是布式系统具备的基本能力。











## 分布式事务解决方案的关系

### DTP-XA-二阶段提交协议(2pc tcc)

#### DTP模型

分布式事务处理模型标准, 由几个巨头公司提出来的一种标准

##### 模型元素(5 个)

应用程序(Application Program, 简称 AP):

资源管理器(Resource Manager, 简称 RM): 如数据库, 文件系统等, 并提供访问资源的方式

事务管理器(Transaction Manager, 简称 TM): 负责分配事务唯一标识, 监控事务的执行进度, 并负责事务的提交, 回滚等.

通信资源管理器(Communication Resource Manager, 简称 CRM): 控制一个 TM 域(TM domain)内或者跨 TM 域的分布式应用之间的通信

通信协议(Communication Protocol, 简称 CP):

##### 模型实例

<img src="http://www.milky.show/images/distributed/transaction/tran_39.png" alt="http://www.milky.show/images/distributed/transaction/tran_39.png" style="zoom:50%;" />

#### XA 规范

XA 规范的最主要作用是定义了 RM-TM 之间的交互交口, 是 DTP 模型的一部分

<img src="http://www.milky.show/images/distributed/transaction/tran_40.png" alt="http://www.milky.show/images/distributed/transaction/tran_40.png" style="zoom:50%;" />

#### XA 规范与二阶段提交协议的关系

XA 规范定义了两阶段提交协议中需要使用到的接口, XA 和 2PC 是相互参考的

<img src="http://www.milky.show/images/distributed/transaction/tran_41.png" alt="http://www.milky.show/images/distributed/transaction/tran_41.png" style="zoom:50%;" />

### XA-JTA-atomikos 的关系

JTA, Java Transaction Api, XA 的 java 实现版, 某种程度上可以认为 JTA 规范是 XA 规范的 Java 版, 在 JTA 中, 事物管理器抽象为 javax.transaction.TransactionManager 接口, 并通过底层事物服务(即 JTS)实现

JTA 仅仅定义了接口

具体的实现如下

*   J2EE 容器所提供的 JTA 实现 JBOSS
*   第三方独立的 JTA 实现, JOTM, Atomikos, 用于 Tomcat, Jetty 以及普通的 Java 引用
*   Atomikos, JTA 的实现, 用于 tomcat 容器



### 二阶段 2pc 与 tcc 的关系

tcc 是二阶段协议的一种, 只不过 tcc 做了一些优化, 在 try 阶段只锁定了一部分资源, 剩余的资源其他事务还可以使用.

**二阶段尽量保证了数据一致性, 适合对数据一致要求很高的关键领域, 实现复杂, 牺牲了可用性, 对性能影响较大, 不适合高并发场景, 如分布式系统跨接口调用**

**tcc 跟 2pc 比起来, 实现及流程相对接单一些, 但数据的一致性比 2PC 差一些, 在 2,3 步骤中都有可能失败, TCC 属于应用层的一种补偿方式, 需要程序员在实现的时候写很多的补偿代码, 在一些场景中, 一些业务流程可能用 TCC 不太好定义及处理, 在代码无法完成时, 可以通过手工干预.**



## 分布式事务实战-Atomikos

**Atomikos 适合单服务多数据源的场景**

<img src="http://www.milky.show/images/distributed/transaction/tran_42.png" alt="http://www.milky.show/images/distributed/transaction/tran_42.png" style="zoom:50%;" />

我们准备 2 个数据库, 分别是订单数据库(tran_order)和日志数据库(tran_log), 订单数据库用于接收用户订单, 日志数据库用于记录用户的订单创建操作

```sql
CREATE TABLE order_info (
  id          INT    NOT NULL,
  money       DOUBLE NOT NULL,
  user_id     VARCHAR(20)  DEFAULT NULL,
  address     VARCHAR(200) DEFAULT NULL,
  create_time DATETIME     DEFAULT NULL,
  PRIMARY KEY (id)
);
```

```sql
CREATE TABLE log_info (
  id          INT NOT NULL,
  create_time DATETIME DEFAULT NULL,
  content     LONGTEXT,
  PRIMARY KEY (id)
);
```

### 实现步骤

1.  公共数据源代理的配置
    1.  配置两个数据源
    2.  XA 数据源统一管理
    3.  分别配置两个 SessionFactory
    4.  管理各自的 Mapper
2.  配置全局事务管理器(atomikos 提供)
3.  将全局事务管理器集成到 spring 中
4.  切面管理和事务通知管理
5.  将切入点和事务通知关联起来



## 事务传播机制

如果有两个service方法, serviceA的方法调用serviceB的方法, 这两个service的方法都是在事务中执行的,

事务是如何在这两个事务中传播的就是事务传播机制解决的问题

```java
// 如果A开启事务B就加入, A不开启B就开启新事务, 默认就是这个级别
int PROPAGATION_REQUIRED = 0;
// 如果A开启事务B就加入, A不开启B就不开启
int PROPAGATION_SUPPORTS = 1;
// A必须在事务中, 如果不在事务中B会报错, 一般用在被调用者上
int PROPAGATION_MANDATORY = 2;
// 不管A在不在事务中, B都会新建事务
int PROPAGATION_REQUIRES_NEW = 3;
// A不管在不在事务中, B都会挂起事务
int PROPAGATION_NOT_SUPPORTED = 4;
// A在事务中就会抛出异常, A不在事务中就可以正常运行, 一般用在被调用者上
int PROPAGATION_NEVER = 5;
// 如果当前存在事务, 则在嵌套事务内执行。如果当前没有事务, 则执行与PROPAGATION_REQUIRED类似的操作。(这个和REQUIRED区别在于一个是加入到一个事务, 一个是在嵌套事务运行)
int PROPAGATION_NESTED = 6;
```

可以这么理解, 大多数情况下, 效果和REQUIRED一样。但是有一种情况, 就是上述代码中, 被调用者事务传播属性为NESTED, 当出现异常时,  调用者把departmentService try, catch了。这个区别与REQUIRED的并不会报错, 而且addEmpByNested方法不会回滚, 只有addDeptByNested回滚了。
 大概原理：当被调用者使用PROPAGATION_NESTED时, 底层的数据源必须基于JDBC 3.0, 并且实现者需要支持保存点事务机制。按上述代码来说(去掉try, catch), 当执行到addDeptByNested这个方法时, Spring会为它创建一个内部的嵌套事务, 如果addDeptByNested执行失败, 则事务回滚到addDeptByNested之前的点, 此时如果不抛异常, 则不会回滚。这个嵌套事务, 是addEmpByNested的一部分, 只有外层事务提交了, 内层的嵌套事务才会一起提交, 这也是与REQUIRED(加入事务), REQUIRES_NEW(开启新事务)的区别。
 还值得一提的是, NESTED是嵌套的意思, 其实并不是只有NESTED用于嵌套, 只要理解上述7个传播机制的意思, 都可以嵌套用。

| 传播属性                  | 调用者                                                       | 被调用者  |
| ------------------------- | ------------------------------------------------------------ | --------- |
| PROPAGATION_REQUIRED      | T1                                                           | T1        |
|                           | 无                                                           | T2        |
| PROPAGATION_SUPPORTS      | T1                                                           | T1        |
|                           | 无                                                           | 无        |
| PROPAGATION_MANDATORY     | T1                                                           | T1        |
|                           | 无                                                           | Exception |
| PROPAGATION_REQUIRES_NEW  | T1                                                           | T2        |
|                           | 无                                                           | T2        |
| PROPAGATION_NOT_SUPPORTED | T1                                                           | 无        |
|                           | 无                                                           | 无        |
| PROPAGATION_NEVER         | T1                                                           | Exception |
|                           | 无                                                           | 无        |
| NESTED                    | 设置 savePoint, 一旦事务回滚, 事务将回滚到 savePoint 处, 交由客户响应提交/回滚 |           |

