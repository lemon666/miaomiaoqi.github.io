---
layout: post
title: "Redis 高可用"
categories: [NoSql]
description:
keywords:
---

* content
{:toc}

## 集群

* 所有的redis节点之间都是互联的(ping-pong机制)

* 节点的fail是通过集群中超过半数的节点检测失效时才生效

* 客户端与redis节点直连, 不需要中间proxy层, 客户端不需要连接集群所有节点, 连接集群中任何一个可用节点即可

* redis-cluster把所有的物理节点映射到[0-16383]slot上, cluster负责维护nodes<>slot<>value

* 单节点fail: 所有master节点投票, 如果超过半数就认为节点挂掉

* 集群fail: 集群任意master挂掉, 如果没有slave集群进入fail状态, 也可以理解为集群挂掉, 如果集群半数以上master挂掉, 无论是否有slave, 集群都进入fail状态

### 集群搭建

集群搭建: 3主3从, 复制6份配置文件, 修改端口号, 开启集群模式, 安装ruby环境, 启动6台机器, 开启集群模式(src目录下命令)    
        
    ./redis-trib.rb create --replicas 1 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006     

可以使用-c命令连接任一节点就是登录集群了

redis-cli -h -p **-c**
    

### 增加节点: 

#### 增加主节点:

1. 首先复制配置文件修改端口号建立一个节点, 直接启动这个节点, 要保证这个redis实例没有存储过数据, 没有持久化文件, 

1. 添加这个节点到集群中, 执行如下命令
   
        ./redis-trib add-node127.0.0.1:7007 to cluster 127.0.0.1:7001（如果这句命令有误，可以用这个:  ./redis-trib add-node127.0.0.1:7007 127.0.0.1:7001）
    
    我们执行在任意一个客户端下执行 cluster nodes 命令，可以看到7007 已经作为主节点添加到我们的集群中了，但是可以看到他没有分配哈希槽，没有分配哈希槽的话表示就没有存储数据的能力，所以我们需要将其他节点上的哈希槽分配到这个节点上。
    
1. 为这个主节点分配哈希槽, 随便进入到一个集群节点中, 执行 
   
        ./redis-trib.rb reshard 192.168.20.140:7001
    
    问我们需要移动多少个哈希槽，输入数字即可, 我们在这里移动1000个
    
    又会问我们需要覆盖的节点id是什么，这个id就是我们新创建的节点id
    
    然后让我们输入源节点，如果这里我们输入all的话，他会随机的从所有的节点中抽取1000个作为新节点的哈希槽。

    移动完以后，我们进入客户端，执行cluster nodes 命令，查看集群节点的状态，我们会看到原来没有哈希槽的7007节点，分配到了1000个哈希槽，而且是不连续的。说明是从原来的三个节点中抽取的。

#### 增加从节点

这样我们一个新的节点就添加好了， 但是我们发现总共是7个节点，其中的六个互为住备，但有一个是有主，没有备，所以我们需要在为该节点添加一个备份节点。

1. 我们在创建一个实例，端口号为7008，启动该实例

1. 添加该节点到集群中, 执行如下命令

        ./redis-trib.rb add-node --slave127.0.0.1:7008  127.0.0.1:7007
    
    第一个实例127.0.0.1:7008为备份节点，第二个实例127.0.0.1:7007为主节点。然后我们在执行，cluster nodes 命令，就会发现新添加的节点已经作为7007 备份节点开始工作了！


### 删除节点

#### 删除从节点

在从节点中，我们没有分配哈希槽，所以删除很简单

1. 执行如下命令

        ./redis-trib.rb del-node 127.0.0.1:7008 65ee465423c925326a5137668541151b4c37d2d9

    有两个参数ip:port和节点的id(cluster nodes命令查看)。我们就可以将从节点从集群中删除了。

#### 删除主节点

而在删除主节点的时候，因为在主节点中存放着数据，所以我们在删除之前，要把这些数据迁移走，并且把该节点上的哈希槽分配到其他主节点上。

1. 首先执行如下命令移走哈希槽

        redis-trib.rb reshard 192.168.139.30:7007(要删除的节点)

    问我们有多少个哈希槽要移走，因为我们这个节点上有1000 个所以我们这里输入1000

    会问我们将槽移动到哪个节点, 输入node id
    
    输入要删除的节点的node id

    如果只删除一个, 紧接着输入done就可以

    会询问我们是否要从新分配, 输入yes, 然后就看到7007上的所有节点都被移动到了7001, 这样就将主节点的哈希槽移走了
    
1. 然后在执行删除节点的命令

        ./redis-trib.rb del-node 127.0.0.1:7007 61f786c40bcc170006a440abd7dc773e6dd15a1

### 集群命令

* 集群(cluster)  

    CLUSTER INFO 打印集群的信息 
    CLUSTER NODES 列出集群当前已知的所有节点（node），以及这些节点的相关信息。   
  
* 节点(node)  

    CLUSTER MEET <ip> <port> 将 ip 和 port 所指定的节点添加到集群当中，让它成为集群的一份子。 
    CLUSTER FORGET <node_id> 从集群中移除 node_id 指定的节点。 
    CLUSTER REPLICATE <node_id> 将当前节点设置为 node_id 指定的节点的从节点。 
    CLUSTER SAVECONFIG 将节点的配置文件保存到硬盘里面。   
  
* 槽(slot)  
    CLUSTER ADDSLOTS <slot> [slot ...] 将一个或多个槽（slot）指派（assign）给当前节点。 
    CLUSTER DELSLOTS <slot> [slot ...] 移除一个或多个槽对当前节点的指派。 
    CLUSTER FLUSHSLOTS 移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点。 
    CLUSTER SETSLOT <slot> NODE <node_id> 将槽 slot 指派给 node_id 指定的节点，如果槽已经指派给另一个节点，那么先让另一个节点删除该槽>，然后再进行指派。 
    CLUSTER SETSLOT <slot> MIGRATING <node_id> 将本节点的槽 slot 迁移到 node_id 指定的节点中。 
    CLUSTER SETSLOT <slot> IMPORTING <node_id> 从 node_id 指定的节点中导入槽 slot 到本节点。 
    CLUSTER SETSLOT <slot> STABLE 取消对槽 slot 的导入（import）或者迁移（migrate）。   
  
* 键 (key) 
    CLUSTER KEYSLOT <key> 计算键 key 应该被放置在哪个槽上。
    CLUSTER COUNTKEYSINSLOT <slot> 返回槽 slot 目前包含的键值对数量。
    CLUSTER GETKEYSINSLOT <slot> <count> 返回 count 个 slot 槽中的键。 

**这些命令是集群所独有的。执行上述命令要先登录** 

## 主从

* 主从策略: 

    主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。

* 全量同步: 

    Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下：
　　1）从服务器连接主服务器，发送SYNC命令
　　2）主服务器接收到SYNC命名后，主服务器开启一个子进程执行BGSAVE命令生成RDB文件, 并使用缓冲区记录此后执行的所有写命令
　　3）主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令
　　4）从服务器收到快照文件后丢弃所有旧数据，载入收到的快照
　　5）主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令
　　6）从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；

* 增量同步:

    Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。
        
