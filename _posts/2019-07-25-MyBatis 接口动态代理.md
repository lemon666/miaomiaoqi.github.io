---
layout: post
title:  "MyBatis 接口动态代理"
date:   2019-07-25 18:35:24
categories: Framework
tags: MyBatis
author: miaoqi
---

* content
{:toc}
# 静态代理

来大城市第一件事就是租房，免不了和中介打交道，因为很多房东很忙，你根本找不到他。从这个场景中就可以抽象出来代理模式

```
ISubject:被访问者资源的抽象
SubjectImpl:被访问者具体实现类（房东）
SubjectProxy:被访问者的代理实现类（中介）
```

UML图如下:

![http://www.miaomiaoqi.cn/images/mybatis/proxy/proxy_1.png](http://www.miaomiaoqi.cn/images/mybatis/proxy/proxy_1.png)

举个例子来理解一下这个设计模式
老板让记录一下用户服务的响应时间，用静态代理模式来实现这个功能。

```java
public interface IUserService {
    public void request();
}

public class UserServiceImpl implements IUserService {
    @Override
    public void request() {
        System.out.println("this is userService");
    }
}

public class UserServiceProxy implements IUserService {

    private IUserService userService;

    public UserServiceProxy(IUserService userService) {
        this.userService = userService;
    }

    @Override
    public void request() {
        long startTime = System.currentTimeMillis();
        userService.request();
        System.out.println("reques cost :" + (System.currentTimeMillis() - startTime));
    }

    public static void main(String[] args) {
        IUserService userService = new UserServiceImpl();
        UserServiceProxy userServiceProxy = new UserServiceProxy(userService);
        // this is userService
        // reques cost :0
        userServiceProxy.request();
    }
}
```

一切看起来都非常的美好，老板又发话了，把产品服务的响应时间也记录一下吧。又得写如下3个类

```
IProductService
ProductServiceImpl
ProductServiceProxy
```

UserServiceProxy 和 ProductServiceProxy 这两个代理类的逻辑都差不多，却还得写2次。其实这个还好，如果老板说，把现有系统的几十个服务的响应时间都记录一下吧，你是不是要疯了？这得写多少代理类啊？

# 动态代理

> 黑暗总是暂时的，终究会迎来黎明，在JDK1.3之后引入了一种称之为动态代理（Dynamic Proxy）的机制。使用该机制，我们可以为指定的接口在系统运行期间动态地生成代理对象，从而帮助我们走出最初使用静态代理实现AOP的窘境

动态代理的实现主要由一个类和一个接口组成，即 java.lang.reflect.Proxy 类和 java.lang.reflect.InvocationHandler 接口。

让我们用动态代理来改造一下上面记录系统响应时间的功能。虽然要为 IUserService 和 IProductService 两种服务提供代理对象，但因为代理对象中要添加的横切逻辑是一样的。所以我们只需要实现一个 InvocationHandler 就可以了。代码如下

```java
public class RequestCostInvocationHandler implements InvocationHandler {

    private Object target;

    public RequestCostInvocationHandler(Object target) {
        this.target = target;
    }

    /** 被代理对象的任何方法被执行时，都会先进入这个方法 */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (method.getName().equals("request")) {
            long startTime = System.currentTimeMillis();
            // 执行目标对象的方法
            method.invoke(this.target, args);
            System.out.println("reques cost :" + (System.currentTimeMillis() - startTime));
        }
        return null;
    }

    public static void main(String[] args) {
        // 3个参数解释如下
        // classloader,生成代理类
        // 代理类应该实现的接口
        // 实现InvocationHandler的切面类
        IUserService userService = (IUserService) Proxy.newProxyInstance(IUserService.class.getClassLoader(),
                new Class[]{IUserService.class}, new RequestCostInvocationHandler(new UserServiceImpl()));

        IProductService productService = (IProductService) Proxy.newProxyInstance(
                IProductService.class.getClassLoader(),
                new Class[]{IProductService.class}, new RequestCostInvocationHandler(new ProductServiceImpl()));

        // this is userService
        // reques cost :0
        userService.request();

        // this is productService
        // reques cost :0
        productService.request();
    }
}
```

UML图如下。恭喜你，你现在已经理解了Spring AOP是怎么回事了，就是这么简单.

![http://www.miaomiaoqi.cn/images/mybatis/proxy/proxy_2.png](http://www.miaomiaoqi.cn/images/mybatis/proxy/proxy_2.png)

# Mybatis核心设计思路

相信用过mybatis的小伙伴都能理解下面这段代码，通过roleMapper这个接口直接从数据库中拿到一个对象

```java
Role role = roleMapper.getRole(3L);
```

直觉告诉我，一个接口是不能运行的啊，一定有接口的实现类，可是这个实现类我自己没写啊，难道mybatis帮我们生成了？你猜的没错，mybatis利用动态代理帮我们生成了接口的实现类，这个类就是org.apache.ibatis.binding.MapperProxy，我先画一下UML图，MapperProxy就是下图中的SubjectProxy类

![http://www.miaomiaoqi.cn/images/mybatis/proxy/proxy_3.png](http://www.miaomiaoqi.cn/images/mybatis/proxy/proxy_3.png)

和上面的UML类图对比一下，发现不就少了一个SubjectImpl类吗？那应该就是SubjectProxy类把SubjectImple类要做的事情做了呗，猜对了。SubjectProxy通过SubjectImple和SubjectImple.xml之间的映射关系知道自己应该执行什么SQL。所以mybatis最核心的思路就是这么个意思，细节之类的可以看源码，理清最主要的思路，看源码就能把握住重点。