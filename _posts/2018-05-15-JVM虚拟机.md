---
layout: post
title:  "JVM虚拟机"
date:   2018-05-17 21:12:38
categories: Java
tags: JVM
author: miaoqi
---

* content
{:toc}

## 虚拟机

1. Sun Classic VM

    * 世界上第一款商用的Java虚拟机

    * 只能使用纯解释器的方式来执行Java代码

1. Exact VM

    * Exact Memory Management准确试内存管理

    * 编译器和解释器混合工作以及两级即时编译器

    * 只在Solaris平台发布

    * 英雄气短

1. HotSpot VM

    * 称霸武林

1. K VM

    * Kilobyte简单, 轻量, 高度可移植
    
    * 在手机平台运行

1. JRockit

    * BEA公司

    * 世界上最快的Java虚拟机

    * 专注服务器端应用

    * 优势:    
    
        垃圾收集器
        
        MissionControl服务套件

1. J9

    * IBM公司

    * IBM Technology for Java Virtual Machine
    
1. Microsoft JVM

1. TaobaoVM

## 虚拟机指令

* -Xms20M

    表示设置堆容量的最小值为20M，必须以M为单位

* -Xmx20M

    表示设置堆容量的最大值为20M，必须以M为单位。将-Xmx和-Xms设置为一样可以避免堆自动扩展。大的项目-Xmx和-Xms一般都要设置到10G、20G甚至还要高

* -verbose:gc

    表示输出虚拟机中GC的详细情况

* -Xss128k

    表示可以设置虚拟机栈的大小为128k

* -Xoss128k

    表示设置本地方法栈的大小为128k。不过HotSpot并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说这个参数是无效的

* -XX:PermSize=10M

    表示JVM初始分配的永久代的容量，必须以M为单位

* -XX:MaxPermSize=10M

    表示JVM允许分配的永久代的最大容量，必须以M为单位，大部分情况下这个参数默认为64M

* -Xnoclassgc

    表示关闭JVM对类的垃圾回收

* -XX:+TraceClassLoading

    表示查看类的加载信息

* -XX:+TraceClassUnLoading

    表示查看类的卸载信息

* -XX:NewRatio=4

    表示设置年轻代：老年代的大小比值为1：4，这意味着年轻代占整个堆的1/5

* -XX:SurvivorRatio=8

    表示设置2个Survivor区：1个Eden区的大小比值为2:8，这意味着Survivor区占整个年轻代的1/5，这个参数默认为8

* -Xmn20M

    表示设置年轻代的大小为20M

* -XX:+HeapDumpOnOutOfMemoryError

    表示可以让虚拟机在出现内存溢出异常时Dump出当前的堆内存转储快照

* -XX:+UseG1GC

    表示让JVM使用G1垃圾收集器

* -XX:+PrintGCDetails

    表示在控制台上打印出GC具体细节

* -XX:+PrintGC

    表示在控制台上打印出GC信息

* -XX:PretenureSizeThreshold=3145728

    表示对象大于3145728（3M）时直接进入老年代分配，这里只能以字节作为单位

* -XX:MaxTenuringThreshold=1

    表示对象年龄大于1，自动进入老年代

* -XX:CompileThreshold=1000

    表示一个方法被调用1000次之后，会被认为是热点代码，并触发即时编译

* -XX:+PrintHeapAtGC

    表示可以看到每次GC前后堆内存布局

* -XX:+PrintTLAB

    表示可以看到TLAB的使用情况

* -XX:+UseSpining

    开启自旋锁

（24）-XX:PreBlockSpin

更改自旋锁的自旋次数，使用这个参数必须先开启自旋锁


## 虚拟机工具

### jps

* jps(java process status)

* 本地虚拟机唯一id lvmid local virtual machine id

* jps -l 可以查看主类

* jps -m 进程所接受的输入参数

* jps -v 进程锁接受的vm参数

### jstat

* 监控虚拟机运行信息

* 类装载, 内存, 垃圾收集, jit编译的信息

### jinfo

* 实时查看和调整虚拟机参数

### jmap

* jmap -dump:format=b,file=/asf/a.bin pid

### jhat(jvm heap analysis tool)

### jstack

* 生成线程快照

    jstack -l pid

## 可视化虚拟机工具

### jConsole

* 内存监控

* 线程监控

* 死锁监控

### VisualVM

* 首页: https://visualvm.github.io/index.html

* 插件地址: https://visualvm.github.io/pluginscenters.html


## 性能调优

* 知识 + 工具 + 数据 + 经验

* 案例1

    频繁发生Full GC, 堆内存设置的过大, 而且大内存对象非常多, 所以会触发Full GC, 导致每次GC时间过长, 出现卡顿, 通过部署多个web容器, 减少每个web容器的堆内存来解决这个问题

* 案例2

    不定期内存溢出, 把内存加大也无济于事. 导出内存快照信息, 没有任何信息, 内存监控正常. 因为使用了NIO的堆外内存, 所以监控不到内存信息

* 案例3

    连接过度, 中间增加MQ

 
    
    