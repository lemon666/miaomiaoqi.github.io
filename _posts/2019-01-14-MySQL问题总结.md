---
layout: post
title:  "MySQL问题总结"
date:   2018-01-14 11:24:42
categories: RDBMS
tags: MySQL
author: miaoqi
---

* content
{:toc}


# MySQL索引与字段的关系

* 在做Quartz的练习时, 需要创建Quartz需要用到的表, 但是在执行SQL的过程中报出如下错误

	**Error : Specified key was too long; max key length is 767 bytes**

	这句话的意思是索引的最大长度为767字节（byte), 而我得索引列长度超过了767字节, 所以报出上述的错误, 接下来我们具体分析一下这个错误

* 首先看一下建表语句

	```
	CREATE TABLE QRTZ_JOB_DETAILS(
	    SCHED_NAME VARCHAR(120) NOT NULL,
	    JOB_NAME VARCHAR(200) NOT NULL,
	    JOB_GROUP VARCHAR(200) NOT NULL,
	    DESCRIPTION VARCHAR(250) NULL,
	    JOB_CLASS_NAME VARCHAR(250) NOT NULL,
	    IS_DURABLE VARCHAR(1) NOT NULL,
	    IS_NONCONCURRENT VARCHAR(1) NOT NULL,
	    IS_UPDATE_DATA VARCHAR(1) NOT NULL,
	    REQUESTS_RECOVERY VARCHAR(1) NOT NULL,
	    JOB_DATA BLOB NULL,
		PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)
	)ENGINE=InnoDB;
	```

	我们可以看到这个建表语句创建了一个复合索引**PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)**, 我创建数据库的时候使用的是utf8mb4字符集, **一个字符会占用4个字节**, 而3个字段的长度是120 + 200 + 200 = 520, 复合索引的长度是2080字节, 单个索引的长度分别是480, 800, 800字节

* **经过查阅得知, MySQL在创建单个字段索引时, 主要的限制是字段长度, 如果单个字段长度不超过767字节, 不会出现问题但复合索引的情况与单字段索引有所不同. 复合索引中除了单字段长度不能超过767字节外, 索引中所有字段长度的总合不能超过3072字节. **

## 测试单列索引的情况

* 首先修改创建表的语句如下

	```
	CREATE TABLE QRTZ_JOB_DETAILS(
	    SCHED_NAME VARCHAR(120) NOT NULL,
	    JOB_NAME VARCHAR(200) NOT NULL,
	    JOB_GROUP VARCHAR(200) NOT NULL,
	    DESCRIPTION VARCHAR(250) NULL,
	    JOB_CLASS_NAME VARCHAR(250) NOT NULL,
	    IS_DURABLE VARCHAR(1) NOT NULL,
	    IS_NONCONCURRENT VARCHAR(1) NOT NULL,
	    IS_UPDATE_DATA VARCHAR(1) NOT NULL,
	    REQUESTS_RECOVERY VARCHAR(1) NOT NULL,
	    JOB_DATA BLOB NULL
	)ENGINE=InnoDB;
	```

* **首先我们为SCHED_NAME添加主键索引**

	```
	MariaDB [quartz_db]> ALTER TABLE `QRTZ_JOB_DETAILS` ADD PRIMARY KEY `idx_details_sn` (SCHED_NAME) COMMENT '单一varchar字段的索引, 不指定索引前缀的长度';
	Query OK, 0 rows affected (0.009 sec)
	Records: 0  Duplicates: 0  Warnings: 0
	```

	可以看到语句执行成功了, 因为SCHED_NAME的长度是120个字符, 1个字符占用4字节, 4 * 120 = 480 < 767可以创建成功

* **接下来我们为JOB_NAME添加主键索引**

	```
	MariaDB [quartz_db]> ALTER TABLE `QRTZ_JOB_DETAILS` ADD PRIMARY KEY `idx_details_jn` (JOB_NAME) COMMENT '单一varchar字段的索引, 不指定索引前缀的长度';
	ERROR 1071 (42000): Specified key was too long; max key length is 767 bytes
	```

	可以看到语句并没有执行成功, 而是说索引列太长了, 不能超过767个字节, 因为JOB_NAME字段时200个字符, 1个字符占用4字节, 4 * 200 = 800, 所以创建失败

* **接下来我们为JOB_NAME添加前缀主键索引**

	```
	MariaDB [quartz_db]> ALTER TABLE `QRTZ_JOB_DETAILS` ADD PRIMARY KEY `pre_idx_details_jn` (JOB_NAME(190)) COMMENT '单一varchar字段的索引, 指定索引前缀的长度为190个字符';
	Query OK, 0 rows affected (0.010 sec)
	Records: 0  Duplicates: 0  Warnings: 0
	```

	这次我们依旧是使用JOB_NAME字段创建索引, **但是在创建索引的时候指定了索引前缀**, 即只使用JOB_NAME列的前190个字符进行索引, 190 * 4 = 760 < 767, 所以创建成功

## 测试复合索引的情况

* 为了方便测试, 我们在添加几个字段

	```
	ALTER TABLE QRTZ_JOB_DETAILS ADD COLUMN t1 VARCHAR(150);
	ALTER TABLE QRTZ_JOB_DETAILS ADD COLUMN t2 VARCHAR(150);
	ALTER TABLE QRTZ_JOB_DETAILS ADD COLUMN t3 VARCHAR(150);
	ALTER TABLE QRTZ_JOB_DETAILS ADD COLUMN t4 VARCHAR(150);
	ALTER TABLE QRTZ_JOB_DETAILS ADD COLUMN t5 VARCHAR(150);
	```

* **首先我们为SCHED_NAME, t1, t2, t3创建复合主键索引**

	```
	MariaDB [quartz_db]> ALTER TABLE QRTZ_JOB_DETAILS ADD PRIMARY KEY idx_details_snt1t2t3(SCHED_NAME, t1, t2, t3);
	Query OK, 0 rows affected (0.026 sec)
	Records: 0  Duplicates: 0  Warnings: 0
	```

	可以看到语句执行成功了, 因为SCHED_NAME的长度是120个字符, 1个字符占用4字节, 4 * 120 = 480 < 767可以创建成功, 4列的字符数分别是, 120, 150, 150, 150, 均满足单列字节不超过767的限制, 总的字节数是 (120 + 150 + 150 + 150) * 4 = 2280 < 3072, 也满足总长度不超过3072字节

* **接下来我们为JOB_NAME, t1, t2, t3创建复合主键索引**

	```
	MariaDB [quartz_db]> ALTER TABLE QRTZ_JOB_DETAILS ADD PRIMARY KEY idx_details_snt1t2t3(JOB_NAME, t1, t2, t3);
	ERROR 1071 (42000): Specified key was too long; max key length is 767 bytes
	```

	这次添加失败了, 因为JOB_NAME是200个字符, 200 * 4 = 800 > 767, 复合索引中的某一列的字节数超过限制, 索引创建失败

* 接下来我们为SCHED_NAME, t1, t2, t3, t4, t5创建复合主键索引

	```
	MariaDB [quartz_db]> ALTER TABLE QRTZ_JOB_DETAILS ADD PRIMARY KEY idx_details_snt1t2t3(JOB_NAME, t1, t2, t3, t4, t5);
	ERROR 1071 (42000): Specified key was too long; max key length is 767 bytes
	```

	显然这次也会失败了, 虽然SCHED_NAME, t1, t2, t3, t4, t5的单列长度均没有超出767的长度限制, 但是总的长度 120 + 150 + 150 + 150 + 150 + 150 = 870 * 4 = 3480 > 3072, 所以超出了总长度的限制

## 总结

* 通过上面一系列的试验, 我们明确知道MySQL创建索引时, 单字段索引的字段长度不能超过767字节, 超过时需要指定索引前缀；创建复合索引时, 单字段长度不能超过767字节, 且索引中所有字段的总长度不能超过3072字节, **违反这些约束时需要删减字段或是为长度较大的字段指定索引前缀或者修改字符集**. 在MySQL 5.6.28中, 字符类型的长度指的是字符数, 而不是字节数, 每个字符占用的字节数和使用的字符集相关



# MySQL存储emoji表情

- 在存储用户昵称时遇到如下错误

	```
	java.sql.SQLException: Incorrect string value: ‘\xF0\x9F\x92\x94’ for colum n ‘name’ at row 1 
	```

	使用mysql数据库的时候, 如果字符集是UTF-8并且在java服务器上, 当存储emoji表情的时候, 会抛出以上异常（比如微信开发获取用户昵称, 有的用户的昵称用的是emoji的图像)

	这是由于mysql字符集不支持的异常导致的, **在mysql中的utf-8字符集最多只支持3个字节的存储, 如果一个字符的utf8编码占用4个字节(最常见的就是ios中的emoji表情字符), 那么在写入数据库时就会报错**Ï

	mysql从5.5.3版本开始, 才支持4字节的utf8编码, 编码名称为utf8mb4（mb4的意思是max bytes 4), 这种编码方式最多用4个字节存储一个字符. 

	因此, 要解决上述异常的发生, 需要使用utf8mb4编码. 

	解决数据库编码后, 还需要解决客户端Connection连接对象使用的编码问题. 

## 解决方式(三种)

1. 从数据库层面进行解决（mysql支持utf8mb4的版本是5.5.3+, 必须升级到较新版本)

	1. 修改database, table, column字符集

		```
		ALTER DATABASE database_name CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci; 
		ALTER TABLE table_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; 
		ALTER TABLE table_name CHANGE column_name VARCHAR(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
		```

	1. 修改mysql配置文件my.cnf

		```
		[client] 
		default-character-set = utf8mb4 
		[mysql] 
		default-character-set = utf8mb4 
		[mysqld] 
		character-set-client-handshake = FALSE 
		character-set-server = utf8mb4 
		collation-server = utf8mb4_unicode_ci 
		init_connect=’SET NAMES utf8mb4’
		```

	1. 用的是java服务器, 升级或者确保mysql connection版本高于5.1.13否则仍然不能试用utf8mb4 

	1. 服务器端的db配置文件

		```
		jdbc.driverClassName=com.mysql.jdbc.Driver 
		jdbc.url=jdbc:mysql://localhost:3306/database?useUnicode=true&characterEncoding=utf8&autoReconnect=true&rewriteBatchedStatements=TRUE 
		jdbc.username=root 
		jdbc.password=password
		```

		如果升级了mysql-connector, 其中的characterEncoding=utf8可以自动被识别为utf8mb4（兼容原来的utf8), 而 autoReconnection（当数据库连接异常中断时, 是否自动重新连接？默认为false)强烈建议配上, 忽略这个属性, 可能导致缓存缘故, 没有读取到DB最新的配置, 导致一直无法试用utf8mb4字符集；

1. 修改数据库连接池配置

	- 如果项目中使用了DataSource数据源, 只需要对数据源进行相关配置即可, 这里以apache的DBCP数据源为例讲解, 在spring框架下配置如下：

		```
		<!-- 数据源 -->
		<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource">
			<property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
			<property name="url" value="jdbc:mysql://${${data-source.prefix}.data-source.host-name}:3306/${${data-source.prefix}.data-source.db-name}?characterEncoding=utf8&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;maxReconnects=10&amp;allowMultiQueries=true" />
			<property name="username" value="${${data-source.prefix}.data-source.username}" />
			<property name="password" value="${${data-source.prefix}.data-source.password}" />
			<property name="maxActive" value="150" />
			<property name="maxIdle" value="2" />
			<property name="testOnBorrow" value="true" />
			<property name="testOnReturn" value="true" />
			<property name="testWhileIdle" value="true" />
			<property name="validationQuery" value="select 1" />
			<!-- 此配置用于在创建Connection对象时执行指定的初始化sql -->
			<property name="connectionInitSqls">
				<list>
					<value>set names 'utf8mb4'</value>
				</list>
			</property>
		</bean>
		```

	- 在springcloud项目中进行配置

		```
		spring:
		  datasource:
		    connection-init-sqls: set names 'utf8mb4'
		```

	- 该设置的解释引用自mysql参考手册:

		```
		SET NAMES 'charset_name'
		
		SET NAMES显示客户端发送的SQL语句中使用什么字符集. 
		
		因此, SET NAMES 'utf8mb4'语句告诉服务器：“将来从这个客户端传来的信息采用字符集utf8mb4”. 它还为服务器发送回客户端的结果指定了字符集. （例如, 如果你使用一个SELECT语句, 它表示列值使用了什么字符集. )
		
		SET NAMES 'x'语句与这三个语句等价：
		
		mysql> SET character_set_client = x;
		
		mysql> SET character_set_results = x;
		
		mysql> SET character_set_connection = x;
		```

1. 从应用层的方面进行解决 

	1. 在获得数据之后往数据库存之前先进行编码:

		```
		URLEncoder.encode(nickName, “utf-8”);
		```

	1. 当从数据库中取出准备显示的时候进行解码, 

		```
		URLDecoder.decode(nickname, “utf-8”); 
		```

	从应用层进行解决的时候建议不要在对象getter, setter方法中直接编码, 因为放入对象的时候setter方法将nickname进行编码, 当插入数据库的时候相当于从对象中调用getter方法将你参考取出这就将之前setter编码过的nickname又重新解码了, 等于未对Nickname进行任何操作. 依然会出现以上问题. 



# Mysql中自增字段(AUTO_INCREMENT)的一些常识

- 在系统开发过程中, 我们经常要用到唯一编号. 使用过mysql的人都应该知道, mysql有一个定义列为自增的属性：AUTO_INCREMENT. 

- 指定了AUTO_INCREMENT的列必须要建索引, 不然会报错, 索引可以为主键索引, 当然也可以为非主键索引. **（不一定要做主键）**

	```
	mysql> create table user (id int auto_increment);
	ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key
	```

- 下面的定义把user表的主键定义为了name, 而非自增的id字段

	```
	mysql> create table user (id int auto_increment,name varchar(20) primary key,key(id)); 
	Query OK, 0 rows affected (0.01 sec)
	```

## 指定了auto_increment的列

- 如果把一个NULL插入到一个AUTO_INCREMENT数据列里去, MySQL将自动生成下一个序列编号. 编号从1开始, 并1为基数递增. 

- 当插入记录时, 没有为AUTO_INCREMENT明确指定值, 则等同插入NULL值. 

	```
	mysql> insert into user (id,name) values (null,'test');
	Query OK, 1 row affected (0.00 sec)
	    
	mysql> select * from user;
	+----+------+
	| id | name |
	+----+------+
	|  1 | test |
	+----+------+
	1 row in set (0.00 sec)
	```

	上面语句等同于下面语句：

	```
	insert into user (name) values ('test');
	```

- 当插入记录时, 如果为AUTO_INCREMENT字段明确指定了一个数值, 则会出现两种情况：

	- **如果插入的值与已有的编号重复, 则会出现出 错信息, 因为AUTO_INCREMENT数据列的值必须是唯一的**
	- **如果插入的值大于已编号的值, 则会把该插入到数据列中, 并使在下一个编号将从这个新值开始递增. **

	**总结一句话就是auto_increment会从最后一次insert语句开始递增**

	- **如果在小于AUTO_INCREMENT字段上插入一个小于AUTO_INCREMENT的值, 比如当前AUTO_INCREMENT是50, 我插入一个47的值, 那再往后插入的值还是从50开始的, 并不会受之前的插入操作影响**

- 当更新AUTO_INCREMENT字段时, 根据存储引擎的不同, 会出现两种情况:

	- **对于MyISAM表, 如果用UPDATE命令更新自增列, 如果列值与已有的值重复, 则会出错. 如果大于已有值, 则下一个编号从该值开始递增****
	- **对于Innodb表, update auto_increment字段, 可能会导致发生报错, 如果将一个id更新为12, 当前AUTO_INCREMEN是10并不会发生变化, Innodb表继续插入记录, 当主键插入到12时会发生报错, 但只会报错一次, 跳过12之后会正常插入**

- 被delete语句删除的id值, 除非sql中将id重新插入, 否则前面空余的id不会复用. 

	- **当前AUTO_INCREMENT=30, delete掉id为10的记录, 下一次插入会是31, 并不会复用空余的10**

- truncate table user 该语句会引起auto_increment的变化, 从头开始. 

- 修改AUTO_INCREMENT字段的起始值

	- **可用alter table table_name AUTO_INCREMENT=n命令来重设自增的起始值. **
	- **但是如果设置的n比目前的数值小的话, 执行的sql不会报错, 但是不会生效! MyISAM和Innodb均是如此. **

# MySQL插入语句insert ignore, insert和replace区别

我们先把结论贴出来

| 指令          | 已存在       | 不存在 | 不存在                                                  |
| ------------- | ------------ | ------ | ------------------------------------------------------- |
| insert        | 报错         | 插入   | insert into names(name, age) values(“小明”, 23);        |
| insert ignore | 忽略         | 插入   | insert ignore into names(name, age) values(“小明”, 24); |
| replace       | 先删除再插入 | 插入   | replace into names(name, age) values(“小明”, 25);       |

表要求: **有PrimaryKey，或者unique索引** 

结果: **表id都会自增**

## 创建测试环境

创建表

```
CREATE TABLE names(
    id INT(10) PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) UNIQUE,
    age INT(10)
)
```

插入数据

```
mysql> insert into names(name, age) values("小明", 24);
mysql> insert into names(name, age) values("大红", 24);
mysql> insert into names(name, age) values("大壮", 24);
mysql> insert into names(name, age) values("秀英", 24);

mysql> select * from names;
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  1 | 小明   |   24 |
|  2 | 大红   |   24 |
|  3 | 大壮   |   24 |
|  4 | 秀英   |   24 |
+----+--------+------+
```

## 测试Insert

插入已存在, id会自增，但是插入不成功，会报错

```
mysql> insert into names(name, age) values("小明", 23);

ERROR 1062 (23000): Duplicate entry '小明' for key 'name'
```

提示我们插入失败, 因为'name'字段冲突了

## 测试replace

**已存在替换，删除原来的记录，添加新的记录**

```
mysql> replace into names(name, age) values("小明", 23);
Query OK, 2 rows affected (0.00 sec)

mysql> select * from names;
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  2 | 大红   |   24 |
|  3 | 大壮   |   24 |
|  4 | 秀英   |   24 |
|  6 | 小明   |   23 |
+----+--------+------+
```

id为1的记录被删除了, 新增的记录id是6, name是小名, replace会先删除已经存在的记录, 在创建新的记录, 而id为6是之前insert时id会自增

**不存在替换，添加新的记录**

```
mysql> replace into names(name, age) values("大名", 23);
Query OK, 1 row affected (0.00 sec)

mysql> select * from names;
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  2 | 大红   |   24 |
|  3 | 大壮   |   24 |
|  4 | 秀英   |   24 |
|  6 | 小明   |   23 |
|  7 | 大名   |   23 |
+----+--------+------+
```

这次没有重复的记录, 直接添加id为7的记录

## insert ignore

**插入已存在，忽略新插入的记录，id会自增，不会报错**

```
mysql> insert ignore into names(name, age) values("大壮", 25);
Query OK, 0 rows affected, 1 warning (0.00 sec)
```

大壮是已经存在的记录, 但是并没有报错, 而是忽略这一条记录, 当我们进行批量插入的时候, 也可以使用insert ingore避免主键冲突对其他插入语句的影响

**插入不存在，添加新的记录**

```
mysql> insert ignore into names(name, age) values("壮壮", 25);
Query OK, 1 row affected (0.01 sec)

mysql> select * from  names;
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  2 | 大红   |   24 |
|  3 | 大壮   |   24 |
|  4 | 秀英   |   24 |
|  6 | 小明   |   23 |
|  7 | 大名   |   23 |
|  9 | 壮壮   |   25 |
+----+--------+------+
```

这次没有重复的记录, 壮壮可以直接插入进来, 并且id自增了