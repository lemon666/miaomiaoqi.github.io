---
layout: post
title:  "Redis常见问题"
date:   2018-06-14 15:12:38
categories: NoSql
tags: Redis
author: miaoqi
---

* content
{:toc}

## 缓存雪崩

### 定义

由于缓存层承载着大量请求，有效的保护了存储层，但是如果缓存层由于某些原因整体不能提供服务，于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况

### 解决方法

* 保证缓存层服务高可用性, 例如Redis Sentinel 和 Redis Cluster 都实现了高可用

* 赖隔离组件为后端限流并降级, 对重要的资源(如 Redis、 MySQL、 Hbase、外部接口)都进行隔离, 让每种资源都单独运行在自己的线程池中

* 对不同的数据使用不同的失效时间，甚至对相同的数据、不同的请求使用不同的失效时间，例如，我们要缓存user数据，会对每个用户的数据设置不同的缓存过期时间，可以定义一个基础时间，假设10秒，然后加上一个两秒以内的随机数，过期时间为10～12秒，就会避免缓存雪崩。避免同一时间缓存全部失效

## 缓存穿透

### 定义

缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中

缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义

### 造成缓存穿透的原因

* 业务自身代码或者数据出现问题

* 一些恶意攻击、爬虫等造成大量空命中

### 解决方法

* 缓存空对象, 空值做缓存, 再次接收到同样的查询请求时，若命中缓存并且值为空，就会直接返回，不会透传到数据库，避免缓存击穿, 即缓存层中存了更多的键, 这就需要更多的内存空间, 可以对其设置一个较短的过期时间, 让其自动清除, 优点是实时性高, 代码维护简单. 当然，有时恶意袭击者可以猜到我们使用了这种方案，每次都会使用不同的参数来查询，这就需要我们对输入的参数进行过滤，例如，如果我们使用ID进行查询，则可以对ID的格式进行分析，如果不符合产生ID的规则，就直接拒绝，或者在ID上放入时间信息，根据时间信息判断ID是否合法，或者是否是我们曾经生成的ID，这样可以拦截一定的无效请求。

* 布隆过滤器拦截, 如果布隆过滤器认为某个键不存在, 那么就不会访问存储层, 适用于数据命中不高, 数据相对固定实时性低（通常是数据集较大）的应用场景, 代码维护较为复杂，但是缓存空间占用少

## 缓存并发

### 定义

缓存并发的问题通常发生在高并发的场景下，当一个缓存key过期时，因为访问这个缓存key 的请求量较大，多个请求同时发现缓存过期，因此多个请求会同时访问数据库来查询最新数据，并且回写缓存，这样会造成应用和数据库的负载增加，性能降低，由于并发较高，甚至会导致数据库被压死。

### 解决方法

* 分布式锁

    使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。

* 本地锁

    与分布式锁类似，我们通过本地锁的方式来限制只有一个线程去数据库中查询数据，而其他线程只需等待，等前面的线程查询到数据后再访问缓存。但是，这种方法只能限制一个服务节点只有一个线程去数据库中查询，如果一个服务有多个节点，则还会有多个数据库查询操作，也就是说在节点数量较多的情况下并没有完全解决缓存并发的问题。

* 软过期

    软过期指对缓存中的数据设置失效时间，就是不使用缓存服务提供的过期时间，而是业务层在数据中存储过期时间信息，由业务程序判断是否过期并更新，在发现了数据即将过期时，将缓存的时效延长，程序可以派遣一个线程去数据库中获取最新的数据，其他线程这时看到延长了的过期时间，就会继续使用旧数据，等派遣的线程获取最新数据后再更新缓存。

    也可以通过异步更新服务来更新设置软过期的缓存，这样应用层就不用关心缓存并发的问题了。

## redis和数据库双写一致性问题

### 定义

一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存。

### 解决方法

* 首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。

    
    
    
    
    
    
    
    
    
    