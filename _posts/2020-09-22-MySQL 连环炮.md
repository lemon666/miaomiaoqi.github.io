---
layout: post
title: MySQL 连环炮
categories: [RDBMS]
description: 
keywords: 
---

* content
{:toc}


## 说下 mysql 的索引有哪些吧, 聚簇和非聚簇索引又是什么

索引按照数据结构来说主要包含B+树和Hash索引. 

假设我们有张表, 结构如下:

```sql
create table user(
  id int(11) not null,
  age int(11) not null,
  primary key(id),
  key(age)
);
```

B+树是左小右大的顺序存储结构, 节点只包含id索引列, 而叶子节点包含索引列和数据, 这种数据和索引在一起存储的索引方式叫做聚簇索引, 一张表只能有一个聚簇索引. 假设没有定义主键, InnoDB会选择一个唯一的非空索引代替, 如果没有的话则会隐式定义一个主键作为聚簇索引. 

![http://www.milky.show/images/databases/mysql/lianhuan_1.png](http://www.milky.show/images/databases/mysql/lianhuan_1.png)

这是主键聚簇索引存储的结构, 那么非聚簇索引的结构是什么样子呢？非聚簇索引(二级索引)保存的是主键id值, 这一点和myisam保存的是数据地址是不同的. 

![http://www.milky.show/images/databases/mysql/lianhuan_2.png](http://www.milky.show/images/databases/mysql/lianhuan_2.png)

最终, 我们一张图看看InnoDB和Myisam聚簇和非聚簇索引的区别

![http://www.milky.show/images/databases/mysql/lianhuan_3.png](http://www.milky.show/images/databases/mysql/lianhuan_3.png)



## 什么是覆盖索引和回表吗

覆盖索引指的是在一次查询中, 如果一个索引包含或者说覆盖所有需要查询的字段的值, 我们就称之为覆盖索引, 而不再需要回表查询. 

而要确定一个查询是否是覆盖索引, 我们只需要explain sql语句看Extra的结果是否是“Using index”即可. 

以上面的user表来举例, 我们再增加一个name字段, 然后做一些查询试试. 

```mysql
explain select * from user where age=1; # 查询的 name 无法从索引数据获取, 需要回表
explain select id,age from user where age=1; # 可以直接从索引获取
```

## 锁的类型有哪些呢

mysql锁分为**共享锁**和**排他锁**, 也叫做读锁和写锁. 

读锁是共享的, 可以通过lock in share mode实现, 这时候只能读不能写. 

写锁是排他的, 它会阻塞其他的写锁和读锁. 从颗粒度来区分, 可以分为**表锁**和**行锁**两种. 

表锁会锁定整张表并且阻塞其他用户对该表的所有读写操作, 比如alter修改表结构的时候会锁表. 

行锁又可以分为**乐观锁**和**悲观锁**, 悲观锁可以通过for update实现, 乐观锁则通过版本号实现. 

## 你能说下事务的基本特性和隔离级别吗

事务基本特性ACID分别是:

**原子性**指的是一个事务中的操作要么全部成功, 要么全部失败. 

**一致性**指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态. 比如A转账给B100块钱, 假设中间sql执行过程中系统崩溃A也不会损失100块, 因为事务没有提交, 修改也就不会保存到数据库. 

**隔离性**指的是一个事务的修改在最终提交前, 对其他事务是不可见的. 

**持久性**指的是一旦事务提交, 所做的修改就会永久保存到数据库中. 

而隔离性有4个隔离级别, 分别是:

**read uncommit** 读未提交, 可能会读到其他事务未提交的数据, 也叫做脏读. 

用户本来应该读取到id=1的用户age应该是10, 结果读取到了其他事务还没有提交的事务, 结果读取结果age=20, 这就是脏读. 

![http://www.milky.show/images/databases/mysql/lianhuan_4.png](http://www.milky.show/images/databases/mysql/lianhuan_4.png)

**read commit** 读已提交, 两次读取结果不一致, 叫做不可重复读. 

不可重复读解决了脏读的问题, 他只会读取已经提交的事务. 

用户开启事务读取id=1用户, 查询到age=10, 再次读取发现结果=20, 在同一个事务里同一个查询读取到不同的结果叫做不可重复读. 

![http://www.milky.show/images/databases/mysql/lianhuan_5.png](http://www.milky.show/images/databases/mysql/lianhuan_5.png)

**repeatable read** 可重复复读, 这是mysql的默认级别, 就是每次读取结果都一样, 但是有可能产生幻读. 

**serializable** 串行, 一般是不会使用的, 他会给每一行读取的数据加锁, 会导致大量超时和锁竞争的问题. 

## ACID 靠什么保证的

A原子性由undo log日志保证, 它记录了需要回滚的日志信息, 事务回滚时撤销已经执行成功的sql

C一致性一般由代码层面来保证

I隔离性由MVCC来保证

D持久性由内存+redo log来保证, mysql修改数据同时在内存和redo log记录这次操作, 事务提交的时候通过redo log刷盘, 宕机的时候可以从redo log恢复



## 事务ACID的实现

事务需要满足ACID特性，那在数据库中，它是如何实现的？我们接下来的内容将一一介绍。

### 原子性

在InnoDB存储引擎中，重做日志都是以512字节进行存储的，称为重做日志块。若一个页中产生的重做日志数量大于512字节，那么需要分割为多个重做日志块进行存储。由于重做日志块的大小与磁盘扇区大小一样，都是512字节，因此重做日志的写入可以保证事务的原子性。重做日志块大小为512字节，但其中包含的有效存储为492字节，重做日志文件头占12字节，日志尾占8字节。

### 一致性

通过数据库的 undo log 撤销日志，来保证事务的一致性。
为了完成事务的回滚操作，在对数据库进行修改时，InnoDB存储引擎不但会产生redo log,还会产生一定量的undo logo。undo log是逻辑日志，只是将数据库逻辑地恢复到原来的样子，保证了事务的一致性（从一个状态转换为下一个一致性状态）。

### 隔离性

其实我们在[《MySQL InnoDB引擎 MVCC并发控制》](http://blog.csdn.net/tb3039450/article/details/66472579)中谈到了事务的隔离级别，但没有谈到怎样实现隔离性。我们提到了要消除幻读，一般的数据库系统需要保证串行化的事务隔离级别，而MySQL InnoDB在可重复读的事务隔离级别下消除了幻读，功劳应该归于Next-key Lock锁。这个具体详述在[《MySQL InnoDB中的行锁 Next-Key Lock消除幻读》](http://blog.csdn.net/tb3039450/article/details/66475638)。那说了半天事务隔离级别，隔离性到底是如何实现的？其实在上面我们已经谈到了，是锁机制+MVCC。我们**通过 MVCC 使得事务隔离级别达到了可重复读，使用锁机制消除了幻读，实现了事务隔离**。需要注意的是，在使用分布式事务时，InnoDB存储引擎的事务隔离级别必须设置为串行化。

### 持久性

重做日志由两部分组成：重做日志缓冲（内存）和重做日志文件（物理存储）。当事务提交（commit）时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务提交操作完成才算完成。redo log重做日志基本上都是顺序写的。为了确保每次日志都写入重做日志文件，在每次将重做日志缓存写入重做日志文件后，InnoDB存储引擎都需要调用一次fsync（文件同步）操作。当然MySQL提供一些参数来调整缓冲刷新到文件的策略，在这里就不细讲了。

### redo 和 undo 的区别

redo 恢复提交事务修改的页操作，undo 回滚行记录到某个特定版本。
redo 通常是物理日志，记录的是页的物理修改操作。undo是逻辑日志，根据每行记录进行记录。

### undo误解

通常对undo的误解是undo用于将数据库物理地恢复到执行语句或事务之前的样子。事实上，NO!!!

举个栗子：一个事务在修改当前一个页中某几条记录，同时还有别的事务在对同一个页中另几条记录进行修改。因此，不能将一个页回滚到事务开始的样子，因为这样会影响其他事务正在进行的工作。所以，在上面我们说道undo log是逻辑日志。

### undo作用

除了回滚操作，undo的另一个作用是MVCC，在InnoDB存储引擎中MVCC的实现是通过undo来完成。当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读。
undo log会产生redo log，undo操作需要持久性保护。



## 什么是幻读, 什么是MVCC

MVCC全称Mutli Version Concurreny Control,多版本并发控制，也可称之为非锁定一致性读；它通过行的多版本控制方式来读取当前执行时间数据库中的行数据。实质上使用的是快照数据。

消除锁的开销: 这个较好理解，如果要保证数据的一致性，最简单的方式就是对操作数据进行加锁，但是加锁不可避免的会有锁开销。所以，如果有能避免进行加锁的方式当然是最好的。

在InnoDB事务隔离级别**“读已提交”**与**“可重复读”**下 ,InnoDB存储引擎使用MVCC机制（非锁定一致性读）。在**“读已提交”**事务隔离级别下，对于快照数据，MVCC读总是**读取被锁定行的最新的快照数据**。而**“可重复读”**读到的总是读取**事务开始时的行数据版本**。

我们每行数实际上隐藏了两列, 创建时间版本号, 过期(删除)时间版本号, 每开始一个新的事务, 版本号都会自动递增. 

还是拿上面的user表举例子, 假设我们插入两条数据, 他们实际上应该长这样. 

| id   | name | create_version | delete_version |
| ---- | ---- | -------------- | -------------- |
| 1    | 张三 | 1              |                |
| 2    | 李四 | 2              |                |

这时候假设小明去执行查询, 此时current_version=3

```mysql
select * from user where id<=3;
```

同时, 小红在这时候开启事务去修改id=1的记录, current_version=4

```mysql
update user set name='张三三' where id=1;
```

执行成功后的结果是这样的

| id   | name   | create_version | delete_version |
| ---- | ------ | -------------- | -------------- |
| 1    | 张三   | 1              |                |
| 2    | 李四   | 2              |                |
| 1    | 张三三 | 4              |                |

如果这时候还有小黑在删除id=2的数据, current_version=5, 执行后结果是这样的. 

| id   | name   | create_version | delete_version |
| ---- | ------ | -------------- | -------------- |
| 1    | 张三   | 1              |                |
| 2    | 李四   | 2              | 5              |
| 1    | 张三三 | 4              |                |

由于MVCC的原理是查找创建版本小于或等于当前事务版本, 删除版本为空或者大于当前事务版本, 小明的真实的查询应该是这样

```mysql
select * from user where id<=3 and create_version<=3 and (delete_version>3 or delete_version is null);
```

所以小明最后查询到的id=1的名字还是'张三', 并且id=2的记录也能查询到. 这样做是**为了保证事务读取的数据是在事务开始前就已经存在的, 要么是事务自己插入或者修改的**. 

明白MVCC原理, 我们来说什么是幻读就简单多了. 举一个常见的场景, 用户注册时, 我们先查询用户名是否存在, 不存在就插入, 假定用户名是唯一索引. 

1.  小明开启事务current_version=6查询名字为'王五'的记录, 发现不存在. 
2.  小红开启事务current_version=7插入一条数据, 结果是这样:

| id   | Name | create_version | delete_version |
| ---- | ---- | -------------- | -------------- |
| 1    | 张三 | 1              |                |
| 2    | 李四 | 2              |                |
| 3    | 王五 | 7              |                |

1.  小明执行插入名字'王五'的记录, 发现唯一索引冲突, 无法插入, 这就是幻读. 



## 什么是间隙锁

间隙锁是可重复读级别下才会有的锁, 结合MVCC和间隙锁可以解决幻读的问题. 我们还是以user举例, 假设现在user表有几条记录

| id   | Age  |
| ---- | ---- |
| 1    | 10   |
| 2    | 20   |
| 3    | 30   |

当我们执行:

```mysql
begin;
select * from user where age=20 for update;

begin;
insert into user(age) values(10); #成功
insert into user(age) values(11); #失败
insert into user(age) values(20); #失败
insert into user(age) values(21); #失败
insert into user(age) values(30); #失败
```

只有10可以插入成功, 那么因为表的间隙mysql自动帮我们生成了区间(左开右闭)

```mysql
(negative infinity, 10],(10,20],(20,30],(30,positive infinity)
```

由于20存在记录, 所以(10,20], (20,30]区间都被锁定了无法插入、删除. 

如果查询21呢？就会根据21定位到(20,30)的区间(都是开区间). 

需要注意的是唯一索引是不会有间隙索引的. 



## 数据量级多大？分库分表怎么做的?

首先分库分表分为垂直和水平两个方式, 一般来说我们拆分的顺序是先垂直后水平. 

**垂直分库**

基于现在微服务拆分来说, 都是已经做到了垂直分库了

![http://www.milky.show/images/databases/mysql/lianhuan_6.png](http://www.milky.show/images/databases/mysql/lianhuan_6.png)

**垂直分表**

如果表字段比较多, 将不常用的、数据较大的等等做拆分

![http://www.milky.show/images/databases/mysql/lianhuan_7.png](http://www.milky.show/images/databases/mysql/lianhuan_7.png)

**水平分表**

首先根据业务场景来决定使用什么字段作为分表字段(sharding_key), 比如我们现在日订单 1000 万, 我们大部分的场景来源于 C 端, 我们可以用 user_id 作为sharding_key, 数据查询支持到最近 3 个月的订单, 超过 3 个月的做归档处理, 那么 3 个月的数据量就是9亿, 可以分 1024 张表, 那么每张表的数据大概就在 100 万左右. 

比如用户 id 为 100, 那我们都经过hash(100), 然后对 1024 取模, 就可以落到对应的表上了. 



## 分表后的 ID 怎么保证唯一性的呢？

因为我们主键默认都是自增的, 那么分表之后的主键在不同表就肯定会有冲突了. 有几个办法考虑:

1.  设定步长, 比如 1-1024 张表我们分别设定 1-1024 的基础步长, 这样主键落到不同的表就不会冲突了. 
2.  分布式 ID, 自己实现一套分布式 ID 生成算法或者使用开源的比如雪花算法这种
3.  分表后不使用主键作为查询依据, 而是每张表单独新增一个字段作为唯一主键使用, 比如订单表订单号是唯一的, 不管最终落在哪张表都基于订单号作为查询依据, 更新也一样. 

## 分表后非 sharding_key 的查询怎么处理

1.  可以做一个mapping表, 比如这时候商家要查询订单列表怎么办呢？不带user_id查询的话你总不能扫全表吧？所以我们可以做一个映射关系表, 保存商家和用户的关系, 查询的时候先通过商家查询到用户列表, 再通过user_id去查询. 
2.  打宽表, 一般而言, 商户端对数据实时性要求并不是很高, 比如查询订单列表, 可以把订单表同步到离线(实时)数仓, 再基于数仓去做成一张宽表, 再基于其他如es提供查询服务. 
3.  数据量不是很大的话, 比如后台的一些查询之类的, 也可以通过多线程扫表, 然后再聚合结果的方式来做. 或者异步的形式也是可以的. 

```java
List<Callable<List<User>>> taskList = Lists.newArrayList();
for (int shardingIndex = 0; shardingIndex < 1024; shardingIndex++) {
    taskList.add(() -> (userMapper.getProcessingAccountList(shardingIndex)));
}
List<ThirdAccountInfo> list = null;
try {
    list = taskExecutor.executeTask(taskList);
} catch (Exception e) {
    //do something
}

public class TaskExecutor {
    public <T> List<T> executeTask(Collection<? extends Callable<T>> tasks) throws Exception {
        List<T> result = Lists.newArrayList();
        List<Future<T>> futures = ExecutorUtil.invokeAll(tasks);
        for (Future<T> future : futures) {
            result.add(future.get());
        }
        return result;
    }
}
```

## mysql 主从同步怎么做的

首先先了解 mysql 主从同步的原理

1.  master 提交完事务后, 写入 binlog
2.  slave 连接到 master, 获取 binlog
3.  master 创建 dump 线程, 推送 binglog 到 slave
4.  slave 启动一个IO线程读取同步过来的 master 的 binlog, 记录到 relay log 中继日志中
5.  slave 再开启一个 sql 线程读取 relay log 事件并在 slave 执行, 完成同步
6.  slave 记录自己的 binglog

![http://www.milky.show/images/databases/mysql/lianhuan_8.png](http://www.milky.show/images/databases/mysql/lianhuan_8.png)

由于 mysql 默认的复制方式是异步的, 主库把日志发送给从库后不关心从库是否已经处理, 这样会产生一个问题就是假设主库挂了, 从库处理失败了, 这时候从库升为主库后, 日志就丢失了. 由此产生两个概念. 

**全同步复制**

主库写入 binlog 后强制同步日志到从库, 所有的从库都执行完成后才返回给客户端, 但是很显然这个方式的话性能会受到严重影响. 

**半同步复制**

和全同步不同的是, 半同步复制的逻辑是这样, 从库写入日志成功后返回 ACK 确认给主库, 主库收到至少一个从库的确认就认为写操作完成. 

## 主从的延迟怎么解决呢

这个问题貌似真的是个无解的问题, 只能是说自己来判断了, 需要走主库的强制走主库查询. 











