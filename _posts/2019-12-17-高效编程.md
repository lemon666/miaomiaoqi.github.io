---
layout: post
title:  "高效编程"
date:   2019-12-17 17:38:04
categories: Java
tags: Grammar
author: miaoqi
---

* content
{:toc}
## 函数式编程

### 函数编程演化历程

1. 将业务逻辑直接写死在代码里
2. 将单一维度的条件作为参数传入方法中. 方法内部根据参数进行业务逻辑实现
3. 将多个维度的条件作为参数传入方法中, 业务实现需要根据不同的参数处理不同逻辑
4. 将业务逻辑封装为一个实体类, 方法接受实体类作为参数, 方法内部调用实体类的处理逻辑
5. 调用方法时不在创建实体类, 而是使用匿名内部类的形式替代
6. 使用 Lambda 表达式替代匿名内部类的形式, 作为方法的参数, 真正实现判断逻辑参数化传递

### Lambda 表达式简介

Java8 引入函数式编程风格

可以理解为一种匿名内部类的代替

通过行为参数化传递代码

### Lambda 表达式的形式

(parameters) -> expression

(parameters) -> {statement;}

* 形式一: 没有参数

    ```java
    () -> System.out.println("Hello World")
    ```

* 形式二: 只有一个参数, 小括号可以省略

    ```java
    name -> System.out.println("Hello World" + name + "!")
    ```

* 形式三: 没有参数, 逻辑复杂, 花括号不能省略

    ```java
    () -> {
    	System.out.println("Hello");
    	System.out.println("World");
    }
    ```

* 形式四: 包含两个参数的方法, 逻辑简单, 花括号可以省略

    ```java
    BinaryOperator<Long> functionAdd = (x, y) -> x + y;
    Long result = functionAdd.apply(1L, 2L);
    ```

* 形式五: 对参数显示声明

    ```java
    BinaryOperator<Long> functionAdd = (Long x, Long y) -> x + y;
    Long result = functionAdd.apply(1L, 2L);
    ```

### 函数式接口

接口中只有一个抽象方法

Java8 的函数式接口注解: @FunctionInterface

### 常用函数式接口与使用

|        接口         |  参数  | 返回类型 |                             描述                             |
| :-----------------: | :----: | :------: | :----------------------------------------------------------: |
|   Predicate\<T\>    |   T    | boolean  |      用于判断一个对象是否满足条件, 比如一个人是否为男性      |
|    Consumer\<T\>    |   T    |   void   | 用于接收一个对象进行处理但没有返回, 比如接收一个人并打印他的名字 |
|  Function\<T, R\>   |   T    |    R     |                 转换一个对象为不同类型的对象                 |
|    Supplier\<T\>    |  None  |    T     |                         提供一个对象                         |
| UnaryOperator\<T\>  |   T    |    T     |                  接收对象并返回同类型的对象                  |
| BinaryOperator\<T\> | (T, T) |    T     |         接收两个同类型的对象, 并返回一个原类型的对象         |

### 方法引用

调用特定方法的 Lambda 表达式的一种快捷写法,  可以让你重复使用现有的方法定义, 并像 Lambda 表达式一样传递他们

类名调用静态方法, 参数都会作为方法的参数传递

```java
/**
 * (args) -> ClassName.staticMethod(args);
 * ClassName::staticMethod;
 */
public void test1() {
    Consumer<String> consumer1 = (String number) -> Integer.parseInt(number);

    Consumer<String> consumer2 = Integer::parseInt;
}
```

类名调用非静态方法, 第一个传入的参数调用方法, 剩余参数作为参数传递

```java
/**
 * (args) -> args.instanceMethod();
 * ClassName::instanceMethod;
 */
public void test2() {
    Consumer<String> consumer1 = (String str) -> str.length();

    Consumer<String> consumer2 = String::length;
}
```

实例对象调用非静态方法, 参数都会作为方法的参数传递

```java
/**
 * (args) -> object.instanceMethod(args);
 * object::instanceMethod;
 */
public void test3() {
    StringBuilder stringBuilder = new StringBuilder();

    Consumer<String> consumer1 = (String str) -> stringBuilder.append(str);

    Consumer<String> consumer2 = stringBuilder::append;
}
```



## 流式编程

JDK1.8 引入的新成员, 以声明式方式处理集合数据

将基础操作链接起来, 完成复杂的数据处理流水线

提供透明的并行处理

### 流与集合的区别

时间与空间

只能遍历一次

外部迭代与内部迭代

### 流的组成

Data -> filter -> sorted -> map -> collect

数据源 -> 中间操作 -> 终端操作

### 流的操作分类

* 中间操作(Intermediate)
    * 无状态操作(filter/map/peek) 只针对当前数据进行操作, 不需要顺序, 会立刻往后执行
    * 有状态操作(dictinct/sorted/limit) 所有数据的基础上进行操作, 会等待数据聚合起来
* 终端操作(Terminal)
    * 非短路操作(forEach/collect/count) 每个数据都需要执行一遍
    * 短路操作(anyMatch/findFirst/findAnt) 满足条件就不会继续执行了

| 中间操作(无状态) | 中间操作(有状态) |   终端操作(短路)    | 终端操作(非短路) |
| :--------------: | :--------------: | :-----------------: | :--------------: |
|   过滤(filter)   |  去重(distinct)  | 所有匹配(allMatch)  |  遍历(forEach)   |
|    映射(map)     |    跳过(skip)    | 任意匹配(anyMatch)  |   归约(reduce)   |
| 扁平化(flatMap)  |   截断(limit)    |  不匹配(noneMatch)  |   最大值(max)    |
|    遍历(peek)    |   排序(sorted)   | 查找首个(findFirst) |  聚合(collect)   |
|                  |                  |  查找任意(findAny)  |   最小值(min)    |
|                  |                  |                     |   计数(count)    |

### 流的构建

由值创建流

由数组创建流

由文件生成流

由函数生成流(无限流)



### 收集器

将流中的元素累积成一个结果

作用于终端操作 `collect()` 上

collect(是一个终端方法) / Collector(接口, 类似 Collection) / Collectors(工具类, 类似 Collections)

#### 内置收集器的功能

将流元素归约和汇总为一个值

将流元素分组

将流元素分区



## 资源关闭

### 垃圾回收(GC)的特点

垃圾回收机制只负责回收堆内存的资源, 不会回收任何**物理资源**

程序无法精确控制垃圾回收动作的具体发生时间

在垃圾回收之前, 总会先调用它的 finalize 方法

### 常见需要手动释放的物力资源

文件/流资源

套接字资源

数据库连接资源

直接内存资源

### 物理资源可以不手动释放吗?

资源被长时间无效占用

超过最大限制后, 将无资源可用

导致系统无法正常运行

### 传统方式关闭流资源

JDK1.7 之前, 实现利用基础 I/O 流完成文件的拷贝功能

### TWR 方式关闭流资源

JDK1.7 之后, 实现利用基础 I/O 流完成文件拷贝的功能

Java7 引入的新特性

优雅关闭资源

一种 Java 语法糖

多资源自动关闭

实现 AutoCloseable 接口

避免异常屏蔽

### 资源关闭的特殊情况

资源对象被 return 的情况下, 由调用方关闭, 如果在被调用方关闭了, 那调用方就不能使用该资源了

ByteArrayInputStream 等不需要检查关闭的资源对象, close 方法中实际上没有任何操作

使用 Socket 获取的 InputStream 和 OutputStream 对象不需要关闭, socket 的相关流应该调用 socket 的 shutdown 方法



## Google Guava工具集

Guava 工程包含了若干被 Google 的 Java 项目广泛依赖的核心库, 例如: 集合, 缓存, 原生类型支持, 并发库, 通用注解, 字符串处理, I/O 等

所有这些工具每天都在被 Google 工程师应用在产品服务中

### 使用和避免 NULL(Optional)

大多数情况下, 使用 null 表明的是**某种缺失**情况

Guava 引入了 Optional<T> 表名可能为 null 的 T 类型引用. Optional 实例可能包含非 null 的引用(**引用存在**), 也可能什么都不包括(**引用缺失**)

正是受到 Guava 的启发, Java8 将 Optional 类作为一个新特性引入 Java8 的类库

### 不可变集合



## 线程池

## 实用工具

## 验证框架

## 开发工具

## 自测工具

## 检查工具

## Java 总结

### 类加载过程(以 Person 类为例 Person p = new Person())

1. 静态方法区为 Person 类开辟一个空间
2. Person 的静态成员变量加载进该空间
3. Person 类的静态成员变量默认初始化
4. Person 类的静态成员变量显示初始化
5. Person 类的静态方法加载进该空间
6. 非静态方法区为 Person 类开辟一个空间
7. Person 类的非静态方法(构造方法, 普通方法) 加载进该空间
8. 栈内存中声明变量`p`
9. 堆内存中为 new Person() 开辟一个空间
10. 非静态成员变量默认初始化
11. 调用 Person() 的构造方法
12. 默认调用父类的构造方法
13. 非静态成员变量显示初始化
14. 执行非静态构造代码块
15. 构造函数继续向下执行
16. 将栈内存中的变量`p`指向堆内存中的`new Person()`

### 常用 List 集合初始化方式

1. **先创建 List 在赋值**

    标准方式, 先创建集合对象, 然后逐个调用`add`方法初始化. 用起来比较繁琐, 不太方便

    ```java
    List<Integer> list = new ArrayList<>();
    list.add(1);
    list.add(2);
    list.add(3);
    ```

2. **使用`{{}}`双大括号初始化**

    使用匿名内部类完成初始化. 外层的`{}`定义了一个ArrayList的匿名内部类, 内层的`{}`定义了一个实例初始化的非静态构造代码块. **有内存泄露风险**

    ```java
    List<Integer> list = new ArrayList(){
    	{
    		add(1);
    		add(2);
    		add(3);
    	}
    }
    ```

3. **使用Arrays.asList**

    使用 Arrays 的静态方法 `asList` 初始化. **返回的 list 集合是不可变的**

    ```java
    List<Integer> list = Arrays.asList(1, 2, 3);
    ```

4. **使用 Stream (JDK8 以上)**

    使用 JDK8 引入的 Stream 的 of 方法生成一个 stream 对象, 调用 `collect` 方法进行收集, 形成一个 List 集合

    ```java
    List<Integer> list = Stream.of(1, 2, 3).collect(Collectors.toList());
    ```

5. **使用Google Guava(需要引入 Guava 工具包)**

    借助 Google Guava 工具集中的 `Lists` 工具类初始化. 需要引入 Guava 才能使用

    ```java
    List<Integer> list = Lists.newArrayList(1, 2, 3);
    ```

6. **使用Lists(JDK9 以上)**

    使用 JDK9 引入的 `Lists` 完成初始化

    ```java
    List<Integer> list = Lists.of(1, 2, 3);
    ```

    