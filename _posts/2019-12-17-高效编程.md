---
layout: post
title: "高效编程"
categories: [Java]
description:
keywords:
---

* content
{:toc}
## 函数式编程

### 函数编程演化历程

1. 将业务逻辑直接写死在代码里
2. 将单一维度的条件作为参数传入方法中. 方法内部根据参数进行业务逻辑实现
3. 将多个维度的条件作为参数传入方法中, 业务实现需要根据不同的参数处理不同逻辑
4. 将业务逻辑封装为一个实体类, 方法接受实体类作为参数, 方法内部调用实体类的处理逻辑
5. 调用方法时不在创建实体类, 而是使用匿名内部类的形式替代
6. 使用 Lambda 表达式替代匿名内部类的形式, 作为方法的参数, 真正实现判断逻辑参数化传递

### Lambda 表达式简介

Java8 引入函数式编程风格

可以理解为一种匿名内部类的代替

通过行为参数化传递代码

### Lambda 表达式的形式

(parameters) -> expression

(parameters) -> {statement;}

* 形式一: 没有参数

    ```java
    () -> System.out.println("Hello World")
    ```

* 形式二: 只有一个参数, 小括号可以省略

    ```java
    name -> System.out.println("Hello World" + name + "!")
    ```

* 形式三: 没有参数, 逻辑复杂, 花括号不能省略

    ```java
    () -> {
    	System.out.println("Hello");
    	System.out.println("World");
    }
    ```

* 形式四: 包含两个参数的方法, 逻辑简单, 花括号可以省略

    ```java
    BinaryOperator<Long> functionAdd = (x, y) -> x + y;
    Long result = functionAdd.apply(1L, 2L);
    ```

* 形式五: 对参数显示声明

    ```java
    BinaryOperator<Long> functionAdd = (Long x, Long y) -> x + y;
    Long result = functionAdd.apply(1L, 2L);
    ```

### 函数式接口

接口中只有一个抽象方法

Java8 的函数式接口注解: @FunctionInterface

### 常用函数式接口与使用

|        接口         |  参数  | 返回类型 |                             描述                             |
| :-----------------: | :----: | :------: | :----------------------------------------------------------: |
|   Predicate\<T\>    |   T    | boolean  |      用于判断一个对象是否满足条件, 比如一个人是否为男性      |
|    Consumer\<T\>    |   T    |   void   | 用于接收一个对象进行处理但没有返回, 比如接收一个人并打印他的名字 |
|  Function\<T, R\>   |   T    |    R     |                 转换一个对象为不同类型的对象                 |
|    Supplier\<T\>    |  None  |    T     |                         提供一个对象                         |
| UnaryOperator\<T\>  |   T    |    T     |                  接收对象并返回同类型的对象                  |
| BinaryOperator\<T\> | (T, T) |    T     |         接收两个同类型的对象, 并返回一个原类型的对象         |

### 方法引用

调用特定方法的 Lambda 表达式的一种快捷写法,  可以让你重复使用现有的方法定义, 并像 Lambda 表达式一样传递他们

类名调用静态方法, 参数都会作为方法的参数传递

```java
/**
 * (args) -> ClassName.staticMethod(args);
 * ClassName::staticMethod;
 */
public void test1() {
    Consumer<String> consumer1 = (String number) -> Integer.parseInt(number);

    Consumer<String> consumer2 = Integer::parseInt;
}
```

类名调用非静态方法, 第一个传入的参数调用方法, 剩余参数作为参数传递

```java
/**
 * (args) -> args.instanceMethod();
 * ClassName::instanceMethod;
 */
public void test2() {
    Consumer<String> consumer1 = (String str) -> str.length();

    Consumer<String> consumer2 = String::length;
}
```

实例对象调用非静态方法, 参数都会作为方法的参数传递

```java
/**
 * (args) -> object.instanceMethod(args);
 * object::instanceMethod;
 */
public void test3() {
    StringBuilder stringBuilder = new StringBuilder();

    Consumer<String> consumer1 = (String str) -> stringBuilder.append(str);

    Consumer<String> consumer2 = stringBuilder::append;
}
```



## 流式编程

JDK1.8 引入的新成员, 以声明式方式处理集合数据

将基础操作链接起来, 完成复杂的数据处理流水线

提供透明的并行处理

### 流与集合的区别

时间与空间

只能遍历一次

外部迭代与内部迭代

### 流的组成

Data -> filter -> sorted -> map -> collect

数据源 -> 中间操作 -> 终端操作

### 流的操作分类

* 中间操作(Intermediate)
    * 无状态操作(filter/map/peek) 只针对当前数据进行操作, 不需要顺序, 会立刻往后执行
    * 有状态操作(dictinct/sorted/limit) 所有数据的基础上进行操作, 会等待数据聚合起来
* 终端操作(Terminal)
    * 非短路操作(forEach/collect/count) 每个数据都需要执行一遍
    * 短路操作(anyMatch/findFirst/findAnt) 满足条件就不会继续执行了

| 中间操作(无状态) | 中间操作(有状态) |   终端操作(短路)    | 终端操作(非短路) |
| :--------------: | :--------------: | :-----------------: | :--------------: |
|   过滤(filter)   |  去重(distinct)  | 所有匹配(allMatch)  |  遍历(forEach)   |
|    映射(map)     |    跳过(skip)    | 任意匹配(anyMatch)  |   归约(reduce)   |
| 扁平化(flatMap)  |   截断(limit)    |  不匹配(noneMatch)  |   最大值(max)    |
|    遍历(peek)    |   排序(sorted)   | 查找首个(findFirst) |  聚合(collect)   |
|                  |                  |  查找任意(findAny)  |   最小值(min)    |
|                  |                  |                     |   计数(count)    |

### 流的构建

由值创建流

由数组创建流

由文件生成流

由函数生成流(无限流)



### 收集器

将流中的元素累积成一个结果

作用于终端操作 `collect()` 上

**collect(是一个终端方法) / Collector(收集器接口, 类似 Collection) / Collectors(工具类, 类似 Collections)**

#### 内置收集器的功能

将流元素归约和汇总为一个值

将流元素分组

将流元素分区



## 资源关闭

### 垃圾回收(GC)的特点

垃圾回收机制只负责回收堆内存的资源, 不会回收任何**物理资源**

程序无法精确控制垃圾回收动作的具体发生时间

在垃圾回收之前, 总会先调用它的 finalize 方法

### 常见需要手动释放的物力资源

文件/流资源

套接字资源

数据库连接资源

直接内存资源

### 物理资源可以不手动释放吗?

资源被长时间无效占用

超过最大限制后, 将无资源可用

导致系统无法正常运行

### 传统方式关闭流资源

JDK1.7 之前, 实现利用基础 I/O 流完成文件的拷贝功能

### TWR 方式关闭流资源

JDK1.7 之后, 实现利用基础 I/O 流完成文件拷贝的功能

Java7 引入的新特性

优雅关闭资源

一种 Java 语法糖

多资源自动关闭

实现 AutoCloseable 接口

避免异常屏蔽

### 资源关闭的特殊情况

资源对象被 return 的情况下, 由调用方关闭, 如果在被调用方关闭了, 那调用方就不能使用该资源了

ByteArrayInputStream 等不需要检查关闭的资源对象, close 方法中实际上没有任何操作

使用 Socket 获取的 InputStream 和 OutputStream 对象不需要关闭, socket 的相关流应该调用 socket 的 shutdown 方法



## Google Guava工具集

Guava 工程包含了若干被 Google 的 Java 项目广泛依赖的核心库, 例如: 集合, 缓存, 原生类型支持, 并发库, 通用注解, 字符串处理, I/O 等

所有这些工具每天都在被 Google 工程师应用在产品服务中

### 使用和避免 NULL(Optional)

大多数情况下, 使用 null 表明的是**某种缺失**情况

Guava 引入了 Optional\<T\> 表名可能为 null 的 T 类型引用. Optional 实例可能包含非 null 的引用(**引用存在**), 也可能什么都不包括(**引用缺失**)

**正是受到 Guava 的启发, Java8 将 Optional 类作为一个新特性引入 Java8 的类库**

### 不可变集合

创建对象的**不可变拷贝**是一项很好的**防御性编程**技巧

Guava 为所有 **JDK 标准集合**类型和 **Guava 新集合**类型都提供了**简单易用**的不可变版本

#### 不可变对象的优点

当对象被不可信的库调用时, 不可变形式是安全的

不可变对象被多个线程调用时, 不存在竞态条件问题

不可变集合不需要考虑变化, 因此可以节省时间和空间

不可变对象因为有固定不变, 可以作为常量来安全使用

#### JDK 提供的 unmodifiableXxx 方法

笨重而且累赘

不安全

低效

#### Guava 不可变集合的三种创建方式

copyOf 方法: ImmutableSet.copy(set), ImmutableList, ImmutableMap

of 方法: ImmutableSet.of("a", "b", "c")

Builder 工具: ImmutableSet.builder().build()

### 新集合类型

Guava 引入了很多 JDK 没有的, 但明显有用的新集合类型. 这些类型是为了和 JDK 集合框架共存, 而没有往 JDK 集合抽象中硬塞其他概念

#### MultiSet

**没有元素顺序限制的 ArrayList(E), 是 List 和 Set 的结合**

add(E): 添加单个给定元素

iterator(): 返回一个迭代器, 包含 MultiSet 所有元素(包括重复元素)

size(): 返回所有元素的总个数(包括重复元素)

**以 Map<E, Integer\> 的角度来看, 键为元素, 值为计数**

count(Object): 返回给定元素的计数

entrySet(): 返回 Set<MultiSet.Entry\<E\>\>, 和 Map 的 entrySet 类似

elementSet(): 返回所有不重复元素的 Set\<E\>, 和 Map 的 keySet 类似

**Multiset 与 Map 的区别**

元素计数只能是正数, Map 的值能是负数, 而 Multiset 的值是为了计数, 一定是正数

multiset.size() 返回集合大小

multiset.iterator() 会迭代重复元素

multiset 支持直接设置元素的计数

没有元素, multiset.count(E) 为 0, 传统 map 会返回 null

**多种 Multiset 的实现**

HashMultiset

TreeMultiset

LinkedHashMultiset

ConcurrenthashMultiset

ImmutableMultiset

### 集合工具类

Guava 为集合类提供了许多工具方法, 这也是 Guava 最流行和成熟的部分之一

常见的工具类如: Lists, Sets, Maps 等

### I/O 工具类

**对字节流/字符流提供的工具方法**

ByteStreams: 提供对 InputStream / OutputStream 的操作

CharStreams: 提供对 Reader/Writer 的操作

**对源(Source)与汇(Sink)的抽象**

源就是一切可读的: ByteSource/CharSource

汇就是一切可写的: ByteSink/CharSink

## 线程池

事先创建若干个可执行的线程放入一个容器中, 需要的时候从池中获取线程不用自行创建, 使用完毕不需要销毁线程而是放回池中, 从而减少创建和销毁线程对象的开销

### 线程池的好处

降低资源消耗

提高响应速度

提高线程的可管理性

### 线程池的核心参数

```java
/**
 * 线程池核心参数
 *
 * @param corePoolSize 核心线程数量
 * @param maximumPoolSize 最大线程数量
 * @param keepAliveTime 线程空闲后的存活时间
 * @param unit keepAliveTime 参数的时间单位
 * @param workQueue 用于存放任务的阻塞队列
 * @param threadFactory 线程工厂类, 用来创建线程
 * @param handler 当队列和最大线程都满了之后的饱和策略
 */
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {}
```

### 线程池的处理流程

![http://www.miaomiaoqi.cn/images/imooc/996/996_1.png](http://www.miaomiaoqi.cn/images/imooc/996/996_1.png)

### 线程池可选择的阻塞队列

**阻塞插入: 当队列满时, 会阻塞插入数据的线程, 直到队列不满**

**阻塞移除: 当队列空时, 会阻塞获取数据的线程, 直到队列非空**

* 无界队列: 队列无限长, 可以一直插入元素
* 有界队列: 
* 同步移交队列: 不存入元素的阻塞队列, 每个插入操作必须等待另一个线程调用移除操作才能成功, 否则插入一直阻塞

### 线程池可选择的饱和策略

AbortPolicy: 终止策略(默认)

DiscardPolicy: 抛弃策略

DiscardOldestPolicy: 抛弃旧任务策略

CallerRunsPolicy: 调用者运行策略

### 线程池的执行示意图

![http://www.miaomiaoqi.cn/images/imooc/996/996_2.png](http://www.miaomiaoqi.cn/images/imooc/996/996_2.png)

### 常用线程池

**Executors.newCachedThreadPool**

```java
// 线程数量无限线程池, 使用时一定要小心, 因为会无限创建线程
public static ExecutorService newCachedThreadPool() {
  return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                60L, TimeUnit.SECONDS,
                                new SynchronousQueue<Runnable>());
}
```

**Executors.newFixedThreadPool**

```java
// 线程数量固定线程池, 线程数被固定住了, 但是队列是无限的, 使用时也要小心
public static ExecutorService newFixedThreadPool(int nThreads) {
  return new ThreadPoolExecutor(nThreads, nThreads,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>());
}
```

**Executors.newSingleThreadExecutor**

```java
// 单一线程的线程池, 线程数只有 1 个, 但是队列是无限的, 要小心使用
public static ExecutorService newSingleThreadExecutor() {
  return new FinalizableDelegatedExecutorService
    (new ThreadPoolExecutor(1, 1,
                            0L, TimeUnit.MILLISECONDS,
                            new LinkedBlockingQueue<Runnable>()));
}
```

### 向线程池提交任务

submit 方法, 有返回值, 可抛出异常

execute 方法, 无返回值, 不可抛出异常

### 线程池的状态

![http://www.miaomiaoqi.cn/images/imooc/996/996_3.png](http://www.miaomiaoqi.cn/images/imooc/996/996_3.png)

## 实用工具Lombok

### Lombok实现原理

注解的两种解析方式

* 运行时解析, 如 Spring 的切面注解, 通过反射运行时生成
* 编译时解析, 这种方式就是 Lombok 的原理

### Lombok 插件安装

```
idea -> preferences -> plugins -> lombok
```

### Lombok 的优缺点

|                优点                |             缺点             |
| :--------------------------------: | :--------------------------: |
| 通过注解自动生成代码, 提高开发效率 | 降低了源代码的可读性和完整性 |
|      代码简洁, 只关注相关属性      |     加大对问题排查的难度     |
|  新增属性后, 无需刻意修改相关方法  |   需要 IDE 相关插件的支持    |



## 验证框架

### 分层验证与 JavaBean 验证

**分层验证**

![http://www.miaomiaoqi.cn/images/imooc/996/996_4.png](http://www.miaomiaoqi.cn/images/imooc/996/996_4.png)

验证逻辑写在每一层上, 验证逻辑重复性很大, 很多重复性代码分散在不同的地方

**JavaBean 验证模型**

![http://www.miaomiaoqi.cn/images/imooc/996/996_5.png](http://www.miaomiaoqi.cn/images/imooc/996/996_5.png)

将验证逻辑通过注解约束在一个模型上, 使验证逻辑从业务代码中分离出来

### Bean Validation 简介

Bean Validaation 为 JavaBean 验证定义了相应的元数据模型和 API

### JCP 和 JSR

JCP(Java Community Process) 成立于 1998 年, 是使有兴趣的各方参与定义 Java 的特征和未来版本的**正式过程**

JCP 使用 JSR(Java 规范请求, Java Specification Requests)作为正式规范文档, 描述被提议加入到 Java 体系中的规范和技术

JSR303: Bean Validation 1.0

JSR349: Bean Validation 1.1

JSR380: Bean Validation 2.0

### Bean Validation 与 Hibernate Validator 与 Spring Validation

Bean Validation 只是一个规范, 相当于接口, 而 Hibernate Validator 是规范的实现, 由 Hibernate 团队开发但与 Hibernate 本身没有关系

Bean Validation 1.0 参考实现: Hibernate Validator 4.3.1 Final

Bean Validation 1.1 参考实现: Hibernate Validator 5.1.1 Final

Bean Validation 2.0 参考实现: Hibernate Validator 6.0.1 Final

**Spring Validation 在 Hibernate Validator 的基础上, 对其进行了二次封装, 以满足在 Spring 环境中更简单, 高效的对数据进行验证**

### 常用约束注解

空值校验类: @Null, @NotNull, @NotEmpty, @NotBlank 等

范围校验类: @Min, @Size, @Digits, @Future, @Negative 等

其他校验类: @Email, @URL, @AssertTrue, @Pattern 等

### 中级验证

级联验证: 使用 `@Valid` 注解可以验证级联对象

分组验证: 验证时指定 group, 可以指定多个 group, 但顺序是属性的顺序

组序列: **使用 `@GroupSequence` 同时对多个分组进行验证并且是有序的**

### 高级验证

**高级验证利用反射进行校验, 配合 AOP 使用效果更好, Spring 的 Controller 就是用类似的方法进行校验的**

校验参数: 使用 @Valid 注解

校验返回值: 

校验构造方法: 

### **自定义验证注解**

定义 @interface Phone 注解

实现约束验证器 PhoneValidator.java

声明 @Phone 约束验证

执行手机号约束验证流程

## 检查工具

### 静态代码分析

静态代码分析是指无需运行被测试代码, 仅通过分析或检查程序的语法, 结构, 过程, 接口等来检查程序的正确性, 找出代码隐藏的错误和缺陷, 如参数不匹配, 有歧义的嵌套语句, 错误的递归, 非法计算, 可能出现的空指针引用等等

### 主流 Java 静态分析工具

#### CheckStyle

检查源文件, 主要关注格式

#### FindBugs

基于 Bug Patterns 概念, 检查 .class 文件中的潜在 Bug

#### PMD

基于静态规则集, 检查源文件中的潜在问题

### IDEA 相关插件及使用方式

IDEA 提供了 QAPlug 插件, 可以使用以上 3 种方式进行校验

### SonarQube

SonarQube 是一个用于代码质量管理的开源平台, 用于管理代码的质量. 支持七个维度, 二十几种编程语言

通过自动代码审查工具, 可以检测代码中的错误, 漏洞和代码异味. 可以与您现有的工作流集成, 以实现跨项目分支和请求的连续代码检查

