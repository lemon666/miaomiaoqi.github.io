---
layout: post
title: jvm
categories: [Java]
description: 
keywords: 
---

* content
{:toc}


## 什么是 JVM

Java Virtual Machine - Java 程序的运行环境(java 二进制字节码的运行环境)

### 好处

一次编写, 到处运行

自动内存管理, 垃圾回收功能

![http://www.milky.show/images/java/jvm/jvm_1.png](http://www.milky.show/images/java/jvm/jvm_1.png)



## JVM 内存结构

### 程序计数器

![http://www.milky.show/images/java/jvm/jvm_2.png](http://www.milky.show/images/java/jvm/jvm_2.png)

#### 定义

Program Counter Register 程序计数器（寄存器）

*   作用，是记住下一条jvm指令的执行地址, 底层硬件是使用寄存器, 因为读取地址是一个非常频繁的操作

*   特点

    *   是线程私有的, 因为 CPU 可以在多个线程之间切换执行, 所以程序计数器只记录当前线程的指令地址

    *   不会存在内存溢出

#### 作用

![http://www.milky.show/images/java/jvm/jvm_3.png](http://www.milky.show/images/java/jvm/jvm_3.png)

java 源代码翻译成二进制字节码, 解释器解析字节码翻译成机器码, CPU 读取机器码执行指令, 当执行完这一条指令后, 解释器会从程序计数器中读取下一条指令的地址执行



### 虚拟机栈

![http://www.milky.show/images/java/jvm/jvm_4.png](http://www.milky.show/images/java/jvm/jvm_4.png)

Java Virtual Machine Stacks （Java 虚拟机栈）

每个线程运行时所需的内存, 称为虚拟机栈

每个栈由多个栈桢(Frame)组成, 对应着每次方法调用时所占用的内存

每个线程只能有一个活动栈桢, 对应着当前正在执行的那个方法

#### 栈桢

每个方法运行时需要的内存, 一个栈对应多个栈桢, 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

![http://www.milky.show/images/java/jvm/jvm_5.png](http://www.milky.show/images/java/jvm/jvm_5.png)



#### 问题辨析

1.  垃圾回收是否涉及栈内存？

    不涉及

2.  栈内存分配越大越好吗？

    -Xss1024 参数, Linux 默认 1024K, 栈内存不是越大越好, 栈内存是属于线程的, 物理内存是固定的, 栈内存越大, 可用线程越少, 效率反而低, 一般采用系统默认就可以

3.  方法内的局部变量是否线程安全？

    如果方法内**局部变量**没有逃离方法的作用访问，它是线程安全的

    如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全

#### 栈内存溢出

栈帧过多导致栈内存溢出, 例如无限的递归

栈帧过大导致栈内存溢出, 一般不会出现

#### 线程运行诊断

**案例 1: CPU 使用率过高**

*   使用 top 定位哪个进程对 cpu 的占用过高
*   ps H -eo pid,tid,%cpu | grep 进程id （用ps命令进一步定位是哪个线程引起的cpu占用过高）
*   jstack 进程id
    *   可以根据线程id 找到有问题的线程，进一步定位到问题代码的源码行号, 此处需要将第 2 步的线程 id 转为 16 进制

**案例 2: 程序运行很长时间没结果**

*   有可能发生了死锁, 使用 jstack 命令定位

### 本地方法栈

![http://www.milky.show/images/java/jvm/jvm_6.png](http://www.milky.show/images/java/jvm/jvm_6.png)

不是由 java 代码编写的程序, 底层由 c 语言运行的代码, 比如 Object 的 clone() 方法

### 堆

![http://www.milky.show/images/java/jvm/jvm_7.png](http://www.milky.show/images/java/jvm/jvm_7.png)

Heap 堆

*   通过 new 关键字，创建对象都会使用堆内存

特点

*   它是线程共享的，堆中对象都需要考虑线程安全的问题

*   有垃圾回收机制

#### 堆内存诊断

jps 工具: 查看当前系统中有哪些 java 进程

jmap 工具: 查看堆内存占用情况 jmap - heap 进程id

jconsole 工具: 图形界面的，多功能的监测工具，可以连续监测

jvisualvm 工具: 可视化展示虚拟机内容, 可以生成堆内存的快照



### 方法区

![http://www.milky.show/images/java/jvm/jvm_8.png](http://www.milky.show/images/java/jvm/jvm_8.png)

[JVM规范-方法区定义](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html)

#### 组成

![http://www.milky.show/images/java/jvm/jvm_9.png](http://www.milky.show/images/java/jvm/jvm_9.png)

#### 方法区内存溢出

1.8 以前会导致永久代内存溢出

```java
* 演示永久代内存溢出 java.lang.OutOfMemoryError: PermGen space
* -XX:MaxPermSize=8m
```

1.8 之后会导致元空间内存溢出

```java
* 演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace
* -XX:MaxMetaspaceSize=8m
```



#### 常量池

常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息



#### 运行时常量池

运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址



#### StringTable

StringTable 是运行时常量池的组成部分, 俗称"串池"

javap -v Demo1.class 可以反编译查看字节码文件内容



#### StringTable 特性

常量池中的字符串仅是符号，第一次用到时才变为对象

利用串池的机制，来避免重复创建字符串对象

字符串变量拼接的原理是 StringBuilder （1.8）

字符串常量拼接的原理是编译期优化

可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池

*   1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串池中的对象返回

*   1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份，放入串池， 会把串池中的对象返回



#### StringTable 面试题

```java
String s1 = "a"; // 用到时会放入到串池中
String s2 = "b"; // 串池
String s3 = "ab"; // 串池
String s4 = s1 + s2; // new StringBuilder().toString() 放入到堆中
String s5 = "a" + "b"; // javac 在编译期间的优化, s5 的结果已经在编译时确定为 ab, 所以 s5 会从串池中查找 "ab", 因为 s3 已经将 "ab" 放入到串池中, 所以 s5 直接引用串池中的 "ab"
String s6 = s4.intern();

// 问
System.out.println(s3 == s4); // s3 在串池中, s4 在堆中, 所以 false
System.out.println(s3 == s5); // s3 和 s5 均引用串池中的 "ab" 所以 true
System.out.println(s3 == s6);

String x2 = new String("c") + new String("d");
String x1 = "cd";
x2.intern();

// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢
System.out.println(x1 == x2);
```





### 直接内存



