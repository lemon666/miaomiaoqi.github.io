---
layout: post
title: "Redis持久化"
categories: [NoSql]
description:
keywords:
---

* content
{:toc}

## RDB快照

* 把内存中的数据来一份一模一样的放在硬盘中, 会丢失掉最后一部分存储的数据, 适合大规模的数据恢复, 对数据完整性和一致性要求不高, 默认是这种方式

* Redis会单独创建(fork)一个子进程来进行持久化, 会先将数据写入到一个临时文件中, 待持久化过程结束后, 再用这个临时文件替换上次持久化的文件, 整个过程中, 主进程不进行任何IO操作, 这就确保了极高的性能

* 隐患:

    若当前的进程数据量庞大, fork之后数据量*2, 会造成服务器压力过大

* save 900 1: 900秒内1次操作会备份

* save 60 10000: 60秒内10000次操作会备份

* save "": 不备份

## AOF保存命令日志(Append Only File)

* 把每一条对redis的**写操作**命令, 保存到类似日志文件中文件采用Redis协议的格式来保存, 新命令会追加到文件末尾, 也支持每秒同步(默认)和不同步, 在数据恢复时按照从前到后的顺序再将指令都执行一遍. 配置文件中appendonly yes开启aof持久化

* 因为采用了追加方式，如果不做任何处理的话，AOF文件会变得越来越大，为此，redis提供了AOF文件重写（rewrite）机制，即当AOF文件的大小超过所设定的阈值时，redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。举个例子或许更形象，假如我们调用了100次INCR指令，在AOF文件中就要存储100条指令，但这明显是很低效的，完全可以把这100条指令合并成一条SET指令，这就是重写机制的原理。**在进行AOF重写时，仍然是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响AOF文件的可用性**

* AOF方式的另一个好处，我们通过一个“场景再现”来说明。某同学在操作redis时，不小心执行了FLUSHALL，导致redis内存中的数据全部被清空了，这是很悲剧的事情。不过这也不是世界末日，只要redis配置了AOF持久化方式，且AOF文件还没有被重写（rewrite），我们就可以用最快的速度暂停redis并编辑AOF文件，将最后一行的FLUSHALL命令删除，然后重启redis，就可以恢复redis的所有数据到FLUSHALL之前的状态了。是不是很神奇，这就是AOF持久化方式的好处之一。但是如果AOF文件已经被重写了，那就无法通过这种方法来恢复数据了。

* 重写策略的参数设置：

        auto-aof-rewrite-percentage 100

    当前的AOF文件大小超过上一次重写时的AOF文件大小的百分之多少时，会再次进行重写，如果之前没有重写过，则以启动时的AOF文件大小为依据。

        auto-aof-rewrite-min-size 64mb

    限制了允许重写的最小AOF文件大小，通常在AOF文件很小的时候，即使其中有些冗余的命令也是可以忽略的。

* 如果运气比较差，AOF文件出现了被写坏的情况，也不必过分担忧，redis并不会贸然加载这个有问题的AOF文件，而是报错退出。这时可以通过以下步骤来修复出错的文件：

    1. 备份被写坏的AOF文件
    2. 运行redis-check-aof –fix进行修复
    3. 用diff -u来看下两个文件的差异，确认问题点
    4. 重启redis，加载修复后的AOF文件

* 虽然优点多多，但AOF方式也同样存在缺陷，比如在同样数据规模的情况下，AOF文件要比RDB文件的体积大。而且，AOF方式的恢复速度也要慢于RDB方式。

## 使用建议

* 如果只做缓存, 可以不使用任何持久化方式

* 如果两个持久化方案同时开启, 优先采用aof方式, 因为aof保存的数据要比rdb完整

* 建议同时开启rdb和aof, rdb适合备份数据库, 因为aof在不断变化, 不好备份, 可以快速重启, 作为以防万一的手段

## 备份

* RDB 文件一旦被创建， 就不会进行任何修改。 当服务器要创建一个新的 RDB 文件时， 它先将文件的内容保存在一个临时文件里面， 当临时文件写入完毕时， 程序才使用 rename(2) 原子地用临时文件替换原来的 RDB 文件。这也就是说， 无论何时， 复制 RDB 文件都是绝对安全的。创建一个定期任务（cron job）， 每小时将一个 RDB 文件备份到一个文件夹， 并且每天将一个 RDB 文件备份到另一个文件夹。
        
