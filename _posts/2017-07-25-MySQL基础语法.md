---
layout: post
title: "MySQL 学习"
categories: [RDBMS]
description: mysql基础语法
keywords: rdbms, mysql
---

* content
{:toc}
## 基础操作

### 数据库操作

创建数据库

```mysql
create database web08; --默认字符集
create database web08_01 character set gbk; --指定字符集
```

查看数据库

```mysql
show databases;
```

查看数据库结构

```mysql
show create database web08_01;
```

查看正在使用的库

```mysql
select database();
```

删除一个库

```mysql
drop database web08_01;
```

使用库

```mysql
use web08;
```

导出整个库

```mysql
mysqldump -u 用户名 -p 数据库名 > 导出的文件名
```


### 表操作

创建表
```mysql
create table 表名{
    字段名 类型(长度) [约束],
    字段名 类型(长度) [约束]
};
      
create table user(
    uid int(32) primary key auto_increment,
    uname varchar(32),
    upassword varchar(32)
);
      
主键约束: primary key 要求被修饰的字段: 唯一和非空
唯一约束: unique 要求被修饰的字段: 唯一
非空约束: not null 要求被修饰的字段: 非空
```

查看表列表

```mysql
show tables;
```

查看表结构

```mysql
desc user;
```

删除表

```mysql
drop table user;
```

修改表

```mysql
alter table user add column uinfo varchar(32) not null; --增加一列

alter table user modify uinfo varchar(50) not null; -- 修改列的长度, 类型, 约束

alter table user change 旧列名 新列名 类型(长度) 约束; -- 修改列名, 类型, 约束

alter table user drop 列名; -- 删除列

rename table 表名 to 新表名; -- 修改表名

alter table 表名 character set 字符集 -- 修改表的字符集
```

查看当前表的编码

```mysql
show create table tbl_user;
```

导出一个表

```bash
mysqldump -u 用户名 -p 数据库名 表名> 导出的文件名
```

导入

```bash
在 mysql命令行界面 source 目标sql文件
```

插入记录

```mysql
insert into 表(列名1, 列名2, 列名3, ...) values(值1, 值2, 值3);

insert into 表 values(值1, 值2, 值3...);
```

更新记录

```mysql
update 表名 set 字段名=值, 字段名=值 where = 条件
```

删除记录

```mysql
delete from 表名 where = 条件
```

从现有表新建表

```mysql
create table new_table_name from select [*|column1,column2] from table_name [where]
```

### 查询

准备工作
```mysql
create table product(    
    pid int primary key auto_increment,   
    pname varchar(20),   
    price double,   
    pdate timestamp,
    cid varchar(32)
)
```

自动增长列：auto_increment

1.  必须整型(int) 
2.  必须是主键

```mysql
insert into product values (null,'谭妮平',0.01,null,1);
insert into product values (null,'李士雪',38,null,1);
insert into product values (null,'左慈',-998,null,1);
insert into product values (null,'黄迎',99999,null,2);
insert into product values (null,'南国强',99998,null,2);
insert into product values (null,'士兵',1,null,2);
insert into product values (null,'李士兵',698,null,3);
insert into product values (null,'士兵',1,null,3);
```

简单查询

1.  查询所有商品

    ```mysql
    select * from product;
    ```

2.  查询商品名和商品价格

    ```mysql
    select pname, price from product;
    ```

3.  查询所有商品信息使用表别名

    ```mysql
    select * from product as p; --as可以省略
    ```

4.  查询商品名，使用列别名

    ```mysql
    select pname as name from product; --as可以省略
    ```

5.  去掉重复值(按照价格)

    ```mysql
    select distinct price from product;
    ```

6.  将所有的商品的价格+10进行显示

    ```mysql
    select price + 10 from product;
    ```

条件查询

1.  查询商品名称为"左慈"的商品信息

    ```mysql
    select * from product where pname = '左慈';
    ```

2.  查询价格>60元的所有商品信息

    ```mysql
    select * from product where price > 60;
    ```

3.  查询商品名称含有"士"字的商品信息

    ```mysql
    select * from product where pname like '%士%';
    ```

4.  查询商品id在(3,6,9)范围内的所有商品信息

    ```mysql
    select * from product where pid in (3, 6, 9);
    ```

5.  查询商品名称含有"士"字并且id=6的商品

    ```mysql
    select * from product where pname like '%士%' and pid = 6;
    ```

排序(asc/desc)

1.  查询所有的商品，按价格进行排序(升序、降序)

    ```mysql
    select * from product order by price asc;
    ```

2.  查询名称有"士"的商品信息并且按照价格降序排序

    ```mysql
    select * from product where pname like '%士%' order by price desc, pid desc;
    ```

聚合

1. 获得所有商品的价格的总和

  ```mysql
  select sum(price) from product;
  ```

2. 获得所有商品的平均价格
    
    ```mysql
    select avg(price) from product;
    ```
    
3. 获得所有商品的个数
    
    ```mysql
    select count(*) from product;
    ```

分组

1.  根据cid字段分组，分组后统计商品的个数。

    ```mysql
    select count(*) from product group by cid;
    ```

2.  根据cid分组，分组统计每组商品的平均价格，并且平均价格大于20000元。

    ```mysql
    select avg(price) from product group by cid having avg(price) > 20000;
    ```

外键

1.  添加

    ```mysql
    alter table product add foreign key [constraint] [constraint_name] (从表外键字段名) references 主表(主表的主键)
    ```

多表查询

1. 交叉连接查询(基本不会使用, 得到的是两个表的乘积)

    ```mysql
    select * from A,B;
    ```

2. 内连接查询(使用 inner join --inner可以省略)

    隐士内连接: `select * from A,B where 条件`

    显示内连接: `select * from A inner join B on 条件`

3. 外连接查询(使用 outer join --outer可以省略)
    
  左外连接: `select * from A left outer join B on 条件`

    右外连接: `select * from A right outer join B on 条件`
    
4. 全连接 full outer join(oracle中)

5. 联合查询

     union:去重,排序,效率低

     union all:不去重,不排序,效率高

<img src="http://www.milky.show/images/mysql/1.png" alt="http://www.milky.show/images/mysql/1.png" style="zoom:67%;" />复制现有表

```mysql
create table new_table select * from old_table;
```


### 完整性约束

主键约束: 主键是表里一个或多个用于实现记录唯一性的字段

```mysql
create table table_name(
    id int primary key,
    name varchar(20)
);

create table table_name(
    id int,
    name varchar(20),
    primary key(id)
);
```

唯一性约束: 唯一性要求表里的某个字段的值在每条记录里是唯一的

```mysql
create table table_name(
    id int primary key,
    name varchar(20),
    cellphone varchar(11) unique
);
```

外键约束: 外键是从表里的一个字段, 引用主表里的主键

```mysql
create table tb_emp(
    id int primary key,
    dept_id int,
    constraint fk_emp_dept_id foreign_key(dept_id) references tb_dept(id)
);
```


### 服务操作

启动服务端(mac)

```bash
mysql.server start
```

停止服务端(mac)

```bash
mysql.server stop
```

启动客户端(mac)

```bash
mysql -uroot -p
```

启动服务端(Linux)

```bash
service mysqld start
```

停止服务端(Linux)

```bash
service mysqld stop
```

### 权限操作

授权操作

```mysql
grant all privileges on databasename.tablename to 'username'@'addr' identified by 'password';

将所有库的所有表的增删改查权限授权给miaomiaoqi用户在localhost登录时, 并且密码是miaoqi
grant select,delete,update,INSERT on *.* to 'miaomiaoqi'@'localhost' identified by 'miaoqi';
```

```mysql
grant all PRIVILEGES on *.* to 'miaomiaoqi'@'localhost' identified by 'miaoqi';
```

查看权限

```mysql
show grants;

show grants for username;

select * from mysql.user;
```



### 特殊sql

补充自增主键

```mysql
alter table `表名` add column `列名` int not null auto_increment primary key comment '主键' first;
```

中文字段排序

```mysql
ORDER BY CONVERT(column USING gbk) ASC
```

## 悲观锁

数据库层面加个排它锁, 性能低

```mysql
select * from account for update;
try {
    // process business logic
    commit();
} catch (Exception e) {
    rollback();
}
```

## 乐观锁

程序员手动控制(CAS机制)

```mysql
int version = select version from tb_xxx where id = 1;
boolean success = update tb_xxx set name = 'bbb' where id = 1 and version = 1.0
if (!success) {
    try...again
}
```

## 函数

### DATE_FORMAT

日期格式化函数

```mysql
SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s') FROM DUAL;
```

### INSTR

判断 fo 是否在 foobarbar 中

```mysql
SELECT INSTR('foobarbar', 'fo') FROM DUAL;
```

### GROUP_CONCAT

我们在写统计 sql 的时候, 有时候需要根据某个字段进行 group by 操作, 当我们进行 group by 操作后, 多条数据会合并成一条, 这时候想要展示出其他字段的值, 就可以使用 group_concat 函数, 假设有如下数据

username	score
zhangsan	10
zhangsan	20
zhangsan	30
lisi			50

根据 username 进行group by 多条数据就会合成一条

```mysql
select * from tbl group by username;
```

执行结果如下:

username	score

zhangsan	10

lisi			50

如果我们想要看下zhangsan和lisi的全部得分怎么办呢? group_concat函数就出场了, 修改sql如下

```mysql
select username, group_concat(score) from tbl group by username;
```

执行结果如下:

username	group_concat(score)

zhangsan	10, 20, 30

lisi			50

到此group_concat的用法就介绍完了

**group_concat 存在的问题**

在做项目中, 遇到了一个很奇葩的问题, 应该给用户返钱, 但总是漏掉一些用户, 通过查看日志发现, group_concat 后的数据少了一部分, 通过查找发现 mysql 的 group_concat 默认连接长度为 1024 字符, 也就是说如果超过 1024 字符, 它只会显示这么多, 其余部分会被截取丢掉, 导致我们漏掉了数据

* 解决办法一

    修改连接的配置

    ```
    SET GLOBAL group_concat_max_len=102400;
    SET SESSION group_concat_max_len=102400; 
    ```

* 解决办法二

    修改 mysql 配置文件, 在 mysql 配置文件中添加如下这句，修改配置文件后记得需要重启 mysql 服务

    ```
    group_concat_max_len = 102400
    ```

虽然上面的办法可以解决问题, 但是使用函数终究性能不会太好, 所以我决定以后避免使用 group_concat 函数, 而是通过关键列进行简单的索引查找, 在应用层中进行分组, 这样可以避免一些不可预知的问题, 也可以减少 mysql 的压力



## 主从一致 binlog

binlog 是用来实现 mysql 主从的重要文件

主库负责写, 从库负责读, 主库会启动一个线程, 将写操作写到日志文件 binlog 中, 从库会启动一个 IO 线程负责从日志文件中读取操作记录, SQL 线程负责执行操作记录进行同步

如何保持一致性: 减少数据库压力

binlog 是记录所有数据库表结构变更（例如CREATE、ALTER TABLE…）以及表数据修改（INSERT、UPDATE、DELETE…）的二进制日志

binlog 不会记录 SELECT 和 SHOW 这类操作，因为这类操作对数据本身并没有修改，但你可以通过查询通用日志来查看 MySQL 执行过的所有语句。

**多说一句，如果 update 操作没有造成数据变化，也是会记入binlog。**

### 误解

binlog只是一类记录操作内容的日志文件

因为binlog称之为二进制日志，很多研发会把这个二进制日志和我们平时在代码里写的代码日志联系在一起。因为我们的代码日志，只有一类记录操作容的文件，并不包含索引文件。然而，这个二进制日志包括两类文件：

* 索引文件（文件名后缀为.index）用于记录哪些日志文件正在被使用
* 日志文件（文件名后缀为.00000*）记录数据库所有的DDL和DML(除了数据查询语句)语句事件

假设文件my.cnf中有这么三条配置

```
log_bin：on 打开binlog日志

log_bin_basename：bin文件路径及名前缀（/var/log/mysql/mysql-bin）

log_bin_index：bin文件index（/var/log/mysql/mysql-bin.index）
```

那么你会在文件目录/var/log/mysql/下面发现两个文件mysql-bin.000001和mysql-bin.index。
mysql-bin.index就是我们所说的索引文件，打开瞅瞅，内容是下面这样,记录哪些文件是日志文件。

```
./mysql-bin.000001
```

那么说到日志文件。在innodb里其实又可以分为两部分，一部分在缓存中，一部分在磁盘上。这里业内有一个词叫做刷盘，就是指将缓存中的日志刷到磁盘上。跟刷盘有关的参数有两个个:sync_binlog和binlog_cache_size。这两个参数作用如下

```
binlog_cache_size: 二进制日志缓存部分的大小，默认值32k

sync_binlog=[N]: 表示写缓冲多少次，刷一次盘,默认值为0
```

注意两点:

* binlog_cache_size设过大，会造成内存浪费。binlog_cache_size设置过小，会频繁将缓冲日志写入临时文件。具体怎么设，有兴趣自行查询，我觉得研发大大根本没机会去设这个值的，了解即可。
* sync_binlog=0:表示刷新binlog时间点由操作系统自身来决定，操作系统自身会每隔一段时间就会刷新缓存数据到磁盘，这个性能最好。sync_binlog=1，代表每次事务提交时就会刷新binlog到磁盘。sync_binlog=N,代表每N个事务提交会进行一次binlog刷新。

另外，这里存在一个一致性问题，sync_binlog=N，数据库在操作系统宕机的时候，可能数据并没有同步到磁盘，于是再次重启数据库，会带来数据丢失问题。 
当sync_binlog=1，事务在Commit的时候，数据写入binlog，但是还没写入事务日志(redo log和undo log)。此时宕机，重启数据库，数据被回滚。但是binlog里已经记录，这里存在不一致问题。这个事务日志和binlog一致性的问题，大家可以查询mysql的内部XA协议，该协议就是解决这个一致性问题的。

**binlog是InnoDb独有的**

binlog是以事件形式记录的，这句话通俗点说，就是binlog的内容都是一个个的事件。这块具体的我会在下一篇讲，这篇记住binlog的内容就是一个个事件就行。
注意了，这里的用词，是一个个事件，而不是事务。大家应该知道Innodb和mysiam最显著的区别就是一个支持事务，一个不支持事务。
因此你可以说，binlog是基于事务来记录二进制日志，比如sync_binlog=1,每提交一次事务，就写入binlog。你却不能说binlog是事务日志，binlog不仅记录innodb日志，在myisam中，也一样存在binlog。

### 数据库常用语句

| sql 语句                                                | 含义                                                         |
| :------------------------------------------------------ | :----------------------------------------------------------- |
| show variables like 'bin_log';                          | 查看是否开启 binlog                                          |
| show variables like 'binlog_format';                    | 查看 binlog 格式                                             |
| show master logs;                                       | 查看所有的 binlog 日志列表                                   |
| show master status;                                     | 查看最后一个 Binlog 日志的编号名称, 及最后一个事件结束的位置(pos) |
| flush logs;                                             | 刷新 Binlog, 此刻开始产生一个新编号的 Binlog 文件            |
| reset master;                                           | 清空所有的 Binlog 日志                                       |
| show binlog events;                                     | 查看第一个 Binlog 日志                                       |
| show binlog events in 'binlog.000030'                   | 查看指定的 Binlog 日志                                       |
| show binlog events in 'binlog.000030' from 931;         | 从指定位置开始, 查看指定 Binlog 日志                         |
| show binlog events in 'binlog.000030' from 931 limit 2; | 从指定位置开始, 查看指定 Binlog 日志, 限制查询的条数         |

**Binlog 的 Event_type**

query_event: 与数据操作无关, begin, drop table, truncate table 等

table_map_event: 记录下一个操作所对应的表信息, 存储了数据库名和表名

xid_event: 标记事务提交

write_rows_event: 插入数据, 即 insert 操作

update_rows_event: 更新数据, 即 update 操作

delete_rows_event: 删除数据, 即 delete 操作

### 用途

#### 复制

主库有一个单独的log dump线程，将binlog传给从库
从库有两个线程，一个I/O线程，一个SQL线程，I/O线程读取主库传过来的binlog内容并写入到relay log,SQL线程从relay log里面读取内容，写入从库的数据库, 这也是主从的原理。

#### 恢复

这里网上有大把的文章指导你，如何利用binlog日志恢复数据库数据。如果你真的觉得自己很有时间，就自己去创建个库，然后删了，再去恢复一下数据，练练手吧。

#### 审计

 用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击

### 常识

#### binlog常见格式

| format    | 定义                       | 优点                           | 缺点                                                         |
| --------- | -------------------------- | ------------------------------ | ------------------------------------------------------------ |
| Statement | 记录的是修改SQL语句        | 日志文件小, 解决IO, 提高性能   | 准确性差, 对一些系统函数不能准确复制或不能复制, 如now(), uuid()等 |
| row       | 记录的是每行实际数据的变更 | 准确性强, 能准确复制数据的变更 | 日志文件大, 较大的网络IO和磁盘IO                             |
| mixed     | statement和row模式的混合   | 准确性强, 文件大小合适         | 有可能发生主从不一致问题                                     |

**业内目前推荐使用的是row模式**，准确性高，虽然说文件大，但是现在有SSD和万兆光纤网络，这些磁盘IO和网络IO都是可以接受的。那么，大家一定想问，为什么不推荐使用mixed模式，理由如下, 假设master有两条记录，而slave只有一条记录。

<img src="http://www.milky.show/images/mysql/binlog_1.png" alt="http://www.milky.show/images/mysql/binlog_1.png" style="zoom:67%;" />

当在master上更新一条从库不存在的记录时，也就是id=2的记录，你会发现master是可以执行成功的。而slave拿到这个SQL后，也会照常执行，不报任何异常，只是更新操作不影响行数而已。并且你执行命令show slave status，查看输出，你会发现没有异常。但是，如果你是row模式，由于这行根本不存在，是会报1062错误的。

#### 怎查看binlog

binlog本身是一类二进制文件。二进制文件更省空间，写入速度更快，是无法直接打开来查看的。

因此mysql提供了命令mysqlbinlog进行查看。

* 一般的statement格式的二进制文件，用下面命令就可以

    ```
    mysqlbinlog mysql-bin.000001
    ```

* 如果是row格式，加上-v或者-vv参数就行，如

    ```
    mysqlbinlog -vv mysql-bin.000001
    ```

#### 怎么删binlog

删binlog的方法很多，有三种是常见的

* 使用`reset master`,该命令将会删除所有日志，并让日志文件重新从000001开始。

* 使用命令

    ```
    PURGE { BINARY | MASTER } LOGS { TO 'log_name' | BEFORE datetime_expr }
    ```

    例如

    ```
    purge master logs to "binlog_name.00000X" 
    ```

    将会清空00000X之前的所有日志文件

* 使用`expire_logs_days=N`选项指定过了多少天日志自动过期清空。

#### binlog常见参数

常见参数，列举如下，有个印象就好。

| 参数名                                       | 含义                                           |
| -------------------------------------------- | ---------------------------------------------- |
| log_bin = {on \| off\| base_name}            | 指定是否启用记录二进制日志或者指定一个日志路径 |
| Sql_log_bin = {on \| off}                    | 指定是否启用记录二进制日志                     |
| expire_logs_days                             | 指定自动删除二进制日志的时间, 即日志过期时间   |
| log_bin_index                                | 指定mysql-bin.index文件的路径                  |
| binlong_format = {mixed \| row \| statement} | 指定二进制日志基于什么模式记录                 |
| max_binlog_size                              | 指定二进制日志文件最大值                       |
| binlog_cache_size                            | 指定事物日志缓存区大小                         |
| max_binlog_cache_size                        | 指定二进制日志缓存最大大小                     |
| sync_binlog = {0 \| n}                       | 指定写缓冲多少次, 刷一次盘                     |

### 开源工具监听 binlog

```xml
<!-- binlog 监听与解析: https://github.com/shyiko/mysql-binlog-connector-java -->
<dependency>
    <groupId>com.github.shyiko</groupId>
    <artifactId>mysql-binlog-connector-java</artifactId>
    <version>0.13.0</version>
</dependency>
```

```java
public class BinlogServiceTest {
    public static void main(String[] args) throws IOException {
        BinaryLogClient client = new BinaryLogClient("127.0.0.1", 3306, "root", "miaoqi");
        // client.setBinlogFilename();
        // client.setBinlogPosition();
        client.registerEventListener(event -> {
            EventData data = event.getData();
            if (data instanceof UpdateRowsEventData) {
                // update ad_unit_keyword set keyword = '奔驰' where keyword = '标志';
                System.out.println("Update---------------");
                System.out.println(data.toString());
            } else if (data instanceof WriteRowsEventData) {
                // insert into `ad_unit_keyword`(`unit_id`, `keyword`) values(10, '标志');
                System.out.println("Write----------------");
                System.out.println(data.toString());
            } else if (data instanceof DeleteRowsEventData) {
                System.out.println("Delete---------------");
                System.out.println(data.toString());
            }
        });
        client.connect();
    }
}
```

**binlog 文件会监听数据库中所有的变化, 所以我们可以自定义一份模板文件, 指定我们想要监听的内容**

```json
{
  "database": "advertisement",
  "tableList": [
    {
      "tableName": "ad_plan",
      "level": 2,
      "insert": [
        {"column": "id"},
        {"column": "user_id"},
        {"column": "plan_status"},
        {"column": "start_date"},
        {"column": "end_date"}
      ],
      "update": [
        {"column": "id"},
        {"column": "user_id"},
        {"column": "plan_status"},
        {"column": "start_date"},
        {"column": "end_date"}
      ],
      "delete": [
        {"column": "id"}
      ]
    },
    {
      "tableName": "ad_unit",
      "level": 3,
      "insert": [
        {"column": "id"},
        {"column": "unit_status"},
        {"column": "position_type"},
        {"column": "plan_id"}
      ],
      "update": [
        {"column": "id"},
        {"column": "unit_status"},
        {"column": "position_type"},
        {"column": "plan_id"}
      ],
      "delete": [
        {"column": "id"}
      ]
    },
    {
      "tableName": "ad_creative",
      "level": 2,
      "insert": [
        {"column": "id"},
        {"column": "type"},
        {"column": "material_type"},
        {"column": "height"},
        {"column": "width"},
        {"column": "audit_status"},
        {"column": "url"}
      ],
      "update": [
        {"column": "id"},
        {"column": "type"},
        {"column": "material_type"},
        {"column": "height"},
        {"column": "width"},
        {"column": "audit_status"},
        {"column": "url"}
      ],
      "delete": [
        {"column": "id"}
      ]
    },
    {
      "tableName": "creative_unit",
      "level": 3,
      "insert": [
        {"column": "creative_id"},
        {"column": "unit_id"}
      ],
      "update": [
      ],
      "delete": [
        {"column": "creative_id"},
        {"column": "unit_id"}
      ]
    },
    {
      "tableName": "ad_unit_district",
      "level": 4,
      "insert": [
        {"column": "unit_id"},
        {"column": "province"},
        {"column": "city"}
      ],
      "update": [
      ],
      "delete": [
        {"column": "unit_id"},
        {"column": "province"},
        {"column": "city"}
      ]
    },
    {
      "tableName": "ad_unit_it",
      "level": 4,
      "insert": [
        {"column": "unit_id"},
        {"column": "it_tag"}
      ],
      "update": [
      ],
      "delete": [
        {"column": "unit_id"},
        {"column": "it_tag"}
      ]
    },
    {
      "tableName": "ad_unit_keyword",
      "level": 4,
      "insert": [
        {"column": "unit_id"},
        {"column": "keyword"}
      ],
      "update": [
      ],
      "delete": [
        {"column": "unit_id"},
        {"column": "keyword"}
      ]
    }
  ]
}
```

**查看表信息**

```sql
select table_schema, table_name, column_name, ordinal_position from information_schema.columns where table_schema = 'advertisement' and table_name = 'ad_unit_keyword';
```



## MySQL 遇到的问题

### MySQL索引与字段的关系

在做Quartz的练习时, 需要创建Quartz需要用到的表, 但是在执行SQL的过程中报出如下错误

**Error : Specified key was too long; max key length is 767 bytes**

这句话的意思是索引的最大长度为767字节（byte), 而我得索引列长度超过了767字节, 所以报出上述的错误, 接下来我们具体分析一下这个错误

首先看一下建表语句

```mysql
CREATE TABLE QRTZ_JOB_DETAILS(
    SCHED_NAME VARCHAR(120) NOT NULL,
    JOB_NAME VARCHAR(200) NOT NULL,
    JOB_GROUP VARCHAR(200) NOT NULL,
    DESCRIPTION VARCHAR(250) NULL,
    JOB_CLASS_NAME VARCHAR(250) NOT NULL,
    IS_DURABLE VARCHAR(1) NOT NULL,
    IS_NONCONCURRENT VARCHAR(1) NOT NULL,
    IS_UPDATE_DATA VARCHAR(1) NOT NULL,
    REQUESTS_RECOVERY VARCHAR(1) NOT NULL,
    JOB_DATA BLOB NULL,
	PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)
)ENGINE=InnoDB;
```

我们可以看到这个建表语句创建了一个复合索引**PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)**, 我创建数据库的时候使用的是utf8mb4字符集, **一个字符会占用4个字节**, 而3个字段的长度是120 + 200 + 200 = 520, 复合索引的长度是2080字节, 单个索引的长度分别是480, 800, 800字节

**经过查阅得知, MySQL在创建单个字段索引时, 主要的限制是字段长度, 如果单个字段长度不超过767字节, 不会出现问题但复合索引的情况与单字段索引有所不同. 复合索引中除了单字段长度不能超过767字节外, 索引中所有字段长度的总合不能超过3072字节. **

#### 测试单列索引的情况

首先修改创建表的语句如下

```mysql
CREATE TABLE QRTZ_JOB_DETAILS(
    SCHED_NAME VARCHAR(120) NOT NULL,
    JOB_NAME VARCHAR(200) NOT NULL,
    JOB_GROUP VARCHAR(200) NOT NULL,
    DESCRIPTION VARCHAR(250) NULL,
    JOB_CLASS_NAME VARCHAR(250) NOT NULL,
    IS_DURABLE VARCHAR(1) NOT NULL,
    IS_NONCONCURRENT VARCHAR(1) NOT NULL,
    IS_UPDATE_DATA VARCHAR(1) NOT NULL,
    REQUESTS_RECOVERY VARCHAR(1) NOT NULL,
    JOB_DATA BLOB NULL
)ENGINE=InnoDB;
```

**首先我们为 SCHED_NAME 添加主键索引**

```mysql
MariaDB [quartz_db]> ALTER TABLE `QRTZ_JOB_DETAILS` ADD PRIMARY KEY `idx_details_sn` (SCHED_NAME) COMMENT '单一varchar字段的索引, 不指定索引前缀的长度';
Query OK, 0 rows affected (0.009 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

可以看到语句执行成功了, 因为SCHED_NAME的长度是120个字符, 1个字符占用4字节, 4 * 120 = 480 < 767可以创建成功

**接下来我们为 JOB_NAME 添加主键索引**

```mysql
MariaDB [quartz_db]> ALTER TABLE `QRTZ_JOB_DETAILS` ADD PRIMARY KEY `idx_details_jn` (JOB_NAME) COMMENT '单一varchar字段的索引, 不指定索引前缀的长度';
ERROR 1071 (42000): Specified key was too long; max key length is 767 bytes
```

可以看到语句并没有执行成功, 而是说索引列太长了, 不能超过 767 个字节, 因为 JOB_NAME 字段时200个字符, 1 个字符占用4字节, 4 * 200 = 800, 所以创建失败

**接下来我们为JOB_NAME添加前缀主键索引**

```mysql
MariaDB [quartz_db]> ALTER TABLE `QRTZ_JOB_DETAILS` ADD PRIMARY KEY `pre_idx_details_jn` (JOB_NAME(190)) COMMENT '单一varchar字段的索引, 指定索引前缀的长度为190个字符';
Query OK, 0 rows affected (0.010 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

这次我们依旧是使用 JOB_NAME 字段创建索引, **但是在创建索引的时候指定了索引前缀**, 即只使用 JOB_NAME 列的前190个字符进行索引, 190 * 4 = 760 < 767, 所以创建成功

#### 测试复合索引的情况

为了方便测试, 我们在添加几个字段

```mysql
ALTER TABLE QRTZ_JOB_DETAILS ADD COLUMN t1 VARCHAR(150);
ALTER TABLE QRTZ_JOB_DETAILS ADD COLUMN t2 VARCHAR(150);
ALTER TABLE QRTZ_JOB_DETAILS ADD COLUMN t3 VARCHAR(150);
ALTER TABLE QRTZ_JOB_DETAILS ADD COLUMN t4 VARCHAR(150);
ALTER TABLE QRTZ_JOB_DETAILS ADD COLUMN t5 VARCHAR(150);
```

**首先我们为SCHED_NAME, t1, t2, t3创建复合主键索引**

```mysql
MariaDB [quartz_db]> ALTER TABLE QRTZ_JOB_DETAILS ADD PRIMARY KEY idx_details_snt1t2t3(SCHED_NAME, t1, t2, t3);
Query OK, 0 rows affected (0.026 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

可以看到语句执行成功了, 因为SCHED_NAME的长度是120个字符, 1个字符占用4字节, 4 * 120 = 480 < 767可以创建成功, 4列的字符数分别是, 120, 150, 150, 150, 均满足单列字节不超过767的限制, 总的字节数是 (120 + 150 + 150 + 150) * 4 = 2280 < 3072, 也满足总长度不超过3072字节

**接下来我们为JOB_NAME, t1, t2, t3创建复合主键索引**

```mysql
MariaDB [quartz_db]> ALTER TABLE QRTZ_JOB_DETAILS ADD PRIMARY KEY idx_details_snt1t2t3(JOB_NAME, t1, t2, t3);
ERROR 1071 (42000): Specified key was too long; max key length is 767 bytes
```

这次添加失败了, 因为JOB_NAME是200个字符, 200 * 4 = 800 > 767, 复合索引中的某一列的字节数超过限制, 索引创建失败

接下来我们为SCHED_NAME, t1, t2, t3, t4, t5创建复合主键索引

```mysql
MariaDB [quartz_db]> ALTER TABLE QRTZ_JOB_DETAILS ADD PRIMARY KEY idx_details_snt1t2t3(JOB_NAME, t1, t2, t3, t4, t5);
ERROR 1071 (42000): Specified key was too long; max key length is 767 bytes
```

显然这次也会失败了, 虽然SCHED_NAME, t1, t2, t3, t4, t5的单列长度均没有超出767的长度限制, 但是总的长度 120 + 150 + 150 + 150 + 150 + 150 = 870 * 4 = 3480 > 3072, 所以超出了总长度的限制

#### 总结

通过上面一系列的试验, 我们明确知道MySQL创建索引时, 单字段索引的字段长度不能超过767字节, 超过时需要指定索引前缀；创建复合索引时, 单字段长度不能超过767字节, 且索引中所有字段的总长度不能超过3072字节, **违反这些约束时需要删减字段或是为长度较大的字段指定索引前缀或者修改字符集**. 在MySQL 5.6.28中, 字符类型的长度指的是字符数, 而不是字节数, 每个字符占用的字节数和使用的字符集相关



### MySQL存储emoji表情

在存储用户昵称时遇到如下错误

```mysql
java.sql.SQLException: Incorrect string value: ‘\xF0\x9F\x92\x94’ for colum n ‘name’ at row 1 
```

使用mysql数据库的时候, 如果字符集是UTF-8并且在java服务器上, 当存储emoji表情的时候, 会抛出以上异常（比如微信开发获取用户昵称, 有的用户的昵称用的是emoji的图像)

这是由于mysql字符集不支持的异常导致的, **在mysql中的utf-8字符集最多只支持3个字节的存储, 如果一个字符的utf8编码占用4个字节(最常见的就是ios中的emoji表情字符), 那么在写入数据库时就会报错**Ï

mysql从5.5.3版本开始, 才支持4字节的utf8编码, 编码名称为utf8mb4（mb4的意思是max bytes 4), 这种编码方式最多用4个字节存储一个字符. 

因此, 要解决上述异常的发生, 需要使用utf8mb4编码. 

解决数据库编码后, 还需要解决客户端Connection连接对象使用的编码问题. 

#### 解决方式(三种)

从数据库层面进行解决（mysql支持utf8mb4的版本是5.5.3+, 必须升级到较新版本)

1. 修改database, table, column字符集

    ```mysql
    ALTER DATABASE database_name CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci; 
    ALTER TABLE table_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; 
    ALTER TABLE table_name CHANGE column_name VARCHAR(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
    ```

1. 修改mysql配置文件my.cnf

    ```mysql
    [client] 
    default-character-set = utf8mb4 
    [mysql] 
    default-character-set = utf8mb4 
    [mysqld] 
    character-set-client-handshake = FALSE 
    character-set-server = utf8mb4 
    collation-server = utf8mb4_unicode_ci 
    init_connect=’SET NAMES utf8mb4’
    ```

1. 用的是java服务器, 升级或者确保mysql connection版本高于5.1.13否则仍然不能试用utf8mb4 

1. 服务器端的db配置文件

    ```properties
    jdbc.driverClassName=com.mysql.jdbc.Driver 
    jdbc.url=jdbc:mysql://localhost:3306/database?useUnicode=true&characterEncoding=utf8&autoReconnect=true&rewriteBatchedStatements=TRUE 
    jdbc.username=root 
    jdbc.password=password
    ```

    如果升级了mysql-connector, 其中的characterEncoding=utf8可以自动被识别为utf8mb4（兼容原来的utf8), 而 autoReconnection（当数据库连接异常中断时, 是否自动重新连接？默认为false)强烈建议配上, 忽略这个属性, 可能导致缓存缘故, 没有读取到DB最新的配置, 导致一直无法试用utf8mb4字符集；

修改数据库连接池配置

- 如果项目中使用了DataSource数据源, 只需要对数据源进行相关配置即可, 这里以apache的DBCP数据源为例讲解, 在spring框架下配置如下：

    ```xml
    <!-- 数据源 -->
    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource">
    	<property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
    	<property name="url" value="jdbc:mysql://${${data-source.prefix}.data-source.host-name}:3306/${${data-source.prefix}.data-source.db-name}?characterEncoding=utf8&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;maxReconnects=10&amp;allowMultiQueries=true" />
    	<property name="username" value="${${data-source.prefix}.data-source.username}" />
    	<property name="password" value="${${data-source.prefix}.data-source.password}" />
    	<property name="maxActive" value="150" />
    	<property name="maxIdle" value="2" />
    	<property name="testOnBorrow" value="true" />
    	<property name="testOnReturn" value="true" />
    	<property name="testWhileIdle" value="true" />
    	<property name="validationQuery" value="select 1" />
    	<!-- 此配置用于在创建Connection对象时执行指定的初始化sql -->
    	<property name="connectionInitSqls">
    		<list>
    			<value>set names 'utf8mb4'</value>
    		</list>
    	</property>
    </bean>
    ```

- 在springcloud项目中进行配置

    ```yaml
    spring:
      datasource:
        connection-init-sqls: set names 'utf8mb4'
    ```

- 该设置的解释引用自mysql参考手册:

    ```mysql
    SET NAMES 'charset_name'
    
    SET NAMES显示客户端发送的SQL语句中使用什么字符集. 
    
    因此, SET NAMES 'utf8mb4'语句告诉服务器：“将来从这个客户端传来的信息采用字符集utf8mb4”. 它还为服务器发送回客户端的结果指定了字符集. （例如, 如果你使用一个SELECT语句, 它表示列值使用了什么字符集. )
    
    SET NAMES 'x'语句与这三个语句等价：
    
    mysql> SET character_set_client = x;
    
    mysql> SET character_set_results = x;
    
    mysql> SET character_set_connection = x;
    ```

从应用层的方面进行解决 

1. 在获得数据之后往数据库存之前先进行编码:

    ```java
    URLEncoder.encode(nickName, “utf-8”);
    ```

1. 当从数据库中取出准备显示的时候进行解码, 

    ```java
    URLDecoder.decode(nickname, “utf-8”); 
    ```

从应用层进行解决的时候建议不要在对象getter, setter方法中直接编码, 因为放入对象的时候setter方法将nickname进行编码, 当插入数据库的时候相当于从对象中调用getter方法将你参考取出这就将之前setter编码过的nickname又重新解码了, 等于未对Nickname进行任何操作. 依然会出现以上问题. 



### Mysql中自增字段(AUTO_INCREMENT)的一些常识

在系统开发过程中, 我们经常要用到唯一编号. 使用过mysql的人都应该知道, mysql有一个定义列为自增的属性：AUTO_INCREMENT. 

指定了AUTO_INCREMENT的列必须要建索引, 不然会报错, 索引可以为主键索引, 当然也可以为非主键索引. **（不一定要做主键）**

```mysql
mysql> create table user (id int auto_increment);
ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key
```

下面的定义把user表的主键定义为了name, 而非自增的id字段

```mysql
mysql> create table user (id int auto_increment,name varchar(20) primary key,key(id)); 
Query OK, 0 rows affected (0.01 sec)
```

#### 指定了auto_increment的列

- 如果把一个NULL插入到一个AUTO_INCREMENT数据列里去, MySQL将自动生成下一个序列编号. 编号从1开始, 并1为基数递增. 

- 当插入记录时, 没有为AUTO_INCREMENT明确指定值, 则等同插入NULL值. 

    ```mysql
    mysql> insert into user (id,name) values (null,'test');
    Query OK, 1 row affected (0.00 sec)
        
    mysql> select * from user;
    +----+------+
    | id | name |
    +----+------+
    |  1 | test |
    +----+------+
    1 row in set (0.00 sec)
    ```

    上面语句等同于下面语句：

    ```mysql
    insert into user (name) values ('test');
    ```

- 当插入记录时, 如果为AUTO_INCREMENT字段明确指定了一个数值, 则会出现两种情况：

    - **如果插入的值与已有的编号重复, 则会出现出 错信息, 因为AUTO_INCREMENT数据列的值必须是唯一的**
    - **如果插入的值大于已编号的值, 则会把该插入到数据列中, 并使在下一个编号将从这个新值开始递增. **

    **总结一句话就是auto_increment会从最后一次insert语句开始递增**

    - **如果在小于AUTO_INCREMENT字段上插入一个小于AUTO_INCREMENT的值, 比如当前AUTO_INCREMENT是50, 我插入一个47的值, 那再往后插入的值还是从50开始的, 并不会受之前的插入操作影响**

- 当更新AUTO_INCREMENT字段时, 根据存储引擎的不同, 会出现两种情况:

    - **对于MyISAM表, 如果用UPDATE命令更新自增列, 如果列值与已有的值重复, 则会出错. 如果大于已有值, 则下一个编号从该值开始递增****
    - **对于Innodb表, update auto_increment字段, 可能会导致发生报错, 如果将一个id更新为12, 当前AUTO_INCREMEN是10并不会发生变化, Innodb表继续插入记录, 当主键插入到12时会发生报错, 但只会报错一次, 跳过12之后会正常插入**

- 被delete语句删除的id值, 除非sql中将id重新插入, 否则前面空余的id不会复用. 

    - **当前AUTO_INCREMENT=30, delete掉id为10的记录, 下一次插入会是31, 并不会复用空余的10**

- truncate table user 该语句会引起auto_increment的变化, 从头开始. 

- 修改AUTO_INCREMENT字段的起始值

    - **可用alter table table_name AUTO_INCREMENT=n命令来重设自增的起始值. **
    - **但是如果设置的n比目前的数值小的话, 执行的sql不会报错, 但是不会生效! MyISAM和Innodb均是如此. **

### MySQL插入语句 insert ignore, insert 和 replace 区别

我们先把结论贴出来

| 指令          | 已存在       | 不存在 | 不存在                                                  |
| ------------- | ------------ | ------ | ------------------------------------------------------- |
| insert        | 报错         | 插入   | insert into names(name, age) values(“小明”, 23);        |
| insert ignore | 忽略         | 插入   | insert ignore into names(name, age) values(“小明”, 24); |
| replace       | 先删除再插入 | 插入   | replace into names(name, age) values(“小明”, 25);       |

表要求: **有PrimaryKey，或者unique索引** 

结果: **表id都会自增**

#### 创建测试环境

创建表

```mysql
CREATE TABLE names(
    id INT(10) PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) UNIQUE,
    age INT(10)
)
```

插入数据

```mysql
mysql> insert into names(name, age) values("小明", 24);
mysql> insert into names(name, age) values("大红", 24);
mysql> insert into names(name, age) values("大壮", 24);
mysql> insert into names(name, age) values("秀英", 24);

mysql> select * from names;
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  1 | 小明   |   24 |
|  2 | 大红   |   24 |
|  3 | 大壮   |   24 |
|  4 | 秀英   |   24 |
+----+--------+------+
```

#### 测试 Insert

插入已存在, id会自增，但是插入不成功，会报错

```
mysql> insert into names(name, age) values("小明", 23);

ERROR 1062 (23000): Duplicate entry '小明' for key 'name'
```

提示我们插入失败, 因为'name'字段冲突了

#### 测试 replace

**已存在替换，删除原来的记录，添加新的记录**

```mysql
mysql> replace into names(name, age) values("小明", 23);
Query OK, 2 rows affected (0.00 sec)

mysql> select * from names;
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  2 | 大红   |   24 |
|  3 | 大壮   |   24 |
|  4 | 秀英   |   24 |
|  6 | 小明   |   23 |
+----+--------+------+
```

id为1的记录被删除了, 新增的记录id是6, name是小名, replace会先删除已经存在的记录, 在创建新的记录, 而id为6是之前insert时id会自增

**不存在替换，添加新的记录**

```mysql
mysql> replace into names(name, age) values("大名", 23);
Query OK, 1 row affected (0.00 sec)

mysql> select * from names;
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  2 | 大红   |   24 |
|  3 | 大壮   |   24 |
|  4 | 秀英   |   24 |
|  6 | 小明   |   23 |
|  7 | 大名   |   23 |
+----+--------+------+
```

这次没有重复的记录, 直接添加id为7的记录

#### insert ignore

**插入已存在，忽略新插入的记录，id会自增，不会报错**

```mysql
mysql> insert ignore into names(name, age) values("大壮", 25);
Query OK, 0 rows affected, 1 warning (0.00 sec)
```

大壮是已经存在的记录, 但是并没有报错, 而是忽略这一条记录, 当我们进行批量插入的时候, 也可以使用insert ingore避免主键冲突对其他插入语句的影响

**插入不存在，添加新的记录**

```mysql
mysql> insert ignore into names(name, age) values("壮壮", 25);
Query OK, 1 row affected (0.01 sec)

mysql> select * from  names;
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  2 | 大红   |   24 |
|  3 | 大壮   |   24 |
|  4 | 秀英   |   24 |
|  6 | 小明   |   23 |
|  7 | 大名   |   23 |
|  9 | 壮壮   |   25 |
+----+--------+------+
```

这次没有重复的记录, 壮壮可以直接插入进来, 并且id自增了