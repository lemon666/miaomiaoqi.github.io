---
layout: post
title:  "Dubbo"
date:   2018-12-03 13:53:13
categories: Distributed
tags: Dubbo
author: miaoqi
---

* content
{:toc}

## Dubbo配置

### 启动检查服务

* dubbo消费者启动时会检查服务是否存在, 默认情况下如果不存在会报错, 可以关闭启动检查, 当服务调用时再去检查

	* 配置文件版, check属性设置为false, 启动时就不会检查了

		```
		<dubbo:reference interface="com.miaoqi.gmall.service.UserService" id="userService" check="false"/>
		
		<!--配置消费者的统一规则, reference的check都是false了-->
		<dubbo:consumer check="false"></dubbo:consumer>
		```

	* 注解版, @Reference注解的check属性设置为false

		```
		@Reference(check = false)
		```


### 超时配置&配置覆盖关系


* 由于网络或服务端不可靠，会导致调用出现一种不确定的中间状态（超时）。为了避免超时导致客户端资源（线程）挂起耗尽，必须设置超时时间。

    * Dubbo消费端

            全局超时配置
            <dubbo:consumer timeout="5000" />
            
            指定接口以及特定方法超时配置
            <dubbo:reference interface="com.foo.BarService" timeout="2000">
                <dubbo:method name="sayHello" timeout="3000" />
            </dubbo:reference>

    * Dubbo服务端

            全局超时配置
            <dubbo:provider timeout="5000" />
            
            指定接口以及特定方法超时配置
            <dubbo:provider interface="com.foo.BarService" timeout="2000">
                <dubbo:method name="sayHello" timeout="3000" />
            </dubbo:provider>

    * 配置原则

        1. 作服务的提供者，比服务使用方更清楚服务性能参数，如调用的超时时间，合理的重试次数，等等
        
        2. 在Provider配置后，Consumer不配置则会使用Provider的配置值，即Provider配置可以作为Consumer的缺省值。否则，Consumer会使用Consumer端的全局设置，这对于Provider不可控的，并且往往是不合理的

        配置的覆盖规则：
        
        1. **方法级优先于接口, 接口优先于全局**
        
        1. **消费者配置优先于提供者(前提是级别一样才是消费方优先)**

        ![http://www.miaomiaoqi.cn/images/dubbo/1.png](http://www.miaomiaoqi.cn/images/dubbo/1.png)

### 重试次数

* 失败自动切换，当出现失败，重试其它服务器，但重试会带来更长延迟。可通过 retries="2" 来设置重试次数**(不含第一次)**, 如果有多个提供者会依次尝试其他的提供者.

        <dubbo:service retries="2" />
        或
        <dubbo:reference retries="2" />
        或
        <dubbo:reference>
            <dubbo:method name="findFoo" retries="2" />
        </dubbo:reference>

### 多版本

* 当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。
可以按照以下的步骤进行版本迁移：

    1. 在低压力时间段，先升级一半提供者为新版本

    1. 再将所有消费者升级为新版本

    1. 然后将剩下的一半提供者升级为新版本

            老版本服务提供者配置：
            <dubbo:service interface="com.foo.BarService" version="1.0.0" />
         
            新版本服务提供者配置：
            <dubbo:service interface="com.foo.BarService" version="2.0.0" />
         
            老版本服务消费者配置：
            <dubbo:reference id="barService" interface="com.foo.BarService" version="1.0.0" />
         
            新版本服务消费者配置：
            <dubbo:reference id="barService" interface="com.foo.BarService" version="2.0.0" />
         
            如果不需要区分版本，可以按照以下的方式配置：
            <dubbo:reference id="barService" interface="com.foo.BarService" version="*" />

### 本地存根

* 本地保存一个对象, 可以实现类似本地代理层的功能

### SpringBoot与Dubbo整合的三种方式

1. 导入dubbo-starter, 在application.properties中配置属性, 使用@Service暴露服务, @Reference引用服务, @EnableDubbo开启注解版Dubbo

1. 保留dubbo的xml配置文件, 使用@ImportResource(location = "classpath:provider.xml")导入配置

1. 使用注解API的方式

    将每一个组件手动创建到容器中

        /**
         * dubbo.application.name=user-service-provider
         * 替代了dubbo的配置文件
         *
         * @author miaoqi
         * @date 2018/12/4
         * @param
         * @return
         */
        @Bean
        public ApplicationConfig applicationConfig() {
            ApplicationConfig applicationConfig = new ApplicationConfig();
            applicationConfig.setName("user-service-provider");
            return applicationConfig;
        }
        
        /**
         * dubbo.registry.address=127.0.0.1:2181
         * 替代了registry
         *
         * @author miaoqi
         * @date 2018/12/4
         * @param
         * @return
         */
        @Bean
        public RegistryConfig registryConfig() {
            RegistryConfig registryConfig = new RegistryConfig();
            registryConfig.setProtocol("zookeeper");
            registryConfig.setAddress("127.0.0.1:2181");
            return registryConfig;
        }
        
        /**
         * dubbo.protocol.name=dubbo
         * dubbo.protocol.port=20880
         * 配置dubbo通信规则
         *
         * @author miaoqi
         * @date 2018/12/4
         * @param
         * @return
         */
        @Bean
        public ProtocolConfig protocolConfig() {
            ProtocolConfig protocolConfig = new ProtocolConfig();
            protocolConfig.setName("dubbo");
            protocolConfig.setPort(20880);
            return protocolConfig;
        }
        
        /**
         * <dubbo:service interface="com.miaoqi.gmall.service.UserService"
         *        ref="userServiceImpl01" timeout="1000" version="1.0.0"/>
         * 创建服务
         *
         * @author miaoqi
         * @date 2018/12/4
         * @param
         * @return
         */
        @Bean
        public ServiceConfig<UserService> serviceConfig(UserService userService) {
            ServiceConfig<UserService> serviceConfig = new ServiceConfig<>();
            serviceConfig.setInterface("com.miaoqi.gmall.service.UserService");
            serviceConfig.setRef(userService);
            serviceConfig.setVersion("1.0.0");
        
            // 配置每一个method的信息
            MethodConfig methodConfig = new MethodConfig();
            methodConfig.setName("getUserAddressList");
            methodConfig.setTimeout(5000);
        
            // 将method的配置设置到service的配置中
            serviceConfig.setMethods(Collections.singletonList(methodConfig));
        
            // ProviderConfig
            // MonitorConfig
            return serviceConfig;
        }

    使用Dubbo扫描组件

        @EnableDubbo(scanBasePackages = "com.miaoqi.gmall")
        @SpringBootApplication
        public class BootUserServiceProviderApplication {
        
        	public static void main(String[] args) {
        		SpringApplication.run(BootUserServiceProviderApplication.class, args);
        	}
        }


## Dubbo高可用

### Zookeeper宕机与Dubbo直连

* zookeeper注册中心宕机，还可以消费dubbo暴露的服务
* 健壮性

    * 监控中心宕掉不影响使用，只是丢失部分采样数据

    * 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务

    * 注册中心对等集群，任意一台宕掉后，将自动切换到另一台

    * 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯

    * 服务提供者无状态，任意一台宕掉后，不影响使用

    * 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复
* Dubbo可以绕过Zookeeper直接建立连接, 通过在消费端指定url就可以实现, 即没有注册中心也可以使用Dubbo



### 负载均衡策略

* 在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。

* 负载均衡策略

	* **Random LoadBalance**

		随机，按权重设置随机概率。

		在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。

	* **RoundRobin LoadBalance**

		轮循，按公约后的权重设置轮循比率。

		存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。

	* **LeastActive LoadBalance**

		最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。

		使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。

	* **ConsistentHash LoadBalance**

		一致性 Hash，相同参数的请求总是发到同一提供者。

		当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。算法参见：http://en.wikipedia.org/wiki/Consistent_hashing

		缺省只对第一个参数 Hash，如果要修改，请配置 <dubbo:parameter key="hash.arguments" value="0,1" />缺省用 160 份虚拟节点，如果要修改，请配置 <dubbo:parameter key="hash.nodes" value="320" />​ 

