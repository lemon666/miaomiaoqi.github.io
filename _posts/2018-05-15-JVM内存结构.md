---
layout: post
title:  "JVM内存结构"
date:   2018-05-17 21:12:38
categories: Java
tags: JVM
author: miaoqi
---

* content
{:toc}

## 简介

* 我们都知道，Java代码是要运行在虚拟机上的，而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。

    其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。在《Java虚拟机规范（Java SE 8）》中描述了JVM运行时内存区域结构如下：

## JVM 内存结构

* Java 虚拟机的内存结构分为 5 个部分：

    * 程序计数器

    * Java 虚拟机栈

    * 本地方法栈

    * 堆

    * 方法区(JDK1.7中属于JVM虚拟机数据区, JDK1.8中移到了本地内存的元数据区中)

### JVM虚拟机数据区

#### 线程独占区

1. 程序计数器(PC寄存器)

    * 定义

        * 程序计数器是一块较小的内存空间，是当前线程正在执行的那条字节码指令的地址。若当前线程正在执行的是一个native方法，那么此时程序计数器为 Undefined。

    * 作用

        * 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。

        * 在多线程情况下，程序计数器记录的是当前线程执行的位置，从而当线程切换回来时，就知道上次线程执行到哪了。

    * 特点

        * 是一块较小的内存空间, 它可以看做是当前线程所执行的字节码的行号指示器

        * 线程私有，每条线程都有自己的程序计数器。
        
        * 生命周期：随着线程的创建而创建，随着线程的结束而销毁。
        
        * 是唯一一个不会出现 OutOfMemoryError的内存区域。

1. Java虚拟机栈

    * 定义

        * Java 虚拟机栈是描述 Java 方法运行过程的内存模型。

        * 每个方法执行都会创建一个栈桢, 伴随着方法从创建到执行完成. 用于存储局部变量表, 操作数栈, 动态链接, 方法出口等

            * 局部变量表
        
                * 存放编译期可知的各种基本数据类型, 引用类型, returnAddress类型
        
                * 局部变量表的内存空间在编译期完成分配, 当进入一个方法时, 这个方法需要在帧分配多少内存是固定的, 在方法运行期间是不会改变局部变量表的大小

        * 压栈出栈过程

            * 当方法运行过程中需要创建局部变量时，就将局部变量的值存入栈帧中的局部变量表中。

            * Java 虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当在这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。

            * 方法结束后，当前栈帧被移出，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧中操作数栈的操作数没有变化。

    * 特点

        * 局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。

        * Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。
        
        * StackOverFlowError 若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。
        
        * OutOfMemoryError 若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出 OutOfMemoryError 异常。
        
        * Java 虚拟机栈也是线程私有，随着线程创建而创建，随着线程的结束而销毁。所以 2 个线程就会有 2 个虚拟机栈，调用方法时各自开辟栈帧空间压入各自的虚拟机栈。某个线程抛出RuntimeException时, 如果没有处理该异常, 那么会一直向上抛给Java虚拟机, 只会导致当前线程停止, 并不会对其他线程有影响

    **出现 StackOverFlowError 时，内存空间可能还有很多。**

1. 本地方法栈(C栈)

    * 定义

        * 本地方法栈是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。

    * 栈帧变化过程

        * 本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。

            方法执行结束后，相应的栈帧也会出栈，并释放内存空间。也会抛出 StackOverFlowError 和 OutOfMemoryError 异常。

        **如果 Java 虚拟机本身不支持 Native 方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。**

#### 线程共享区

1. Java堆

    * 定义

        * 堆是用来存放对象的内存空间, 存放对象实例和数组, 几乎所有的对象都存储在堆中。

    * 特点

        * 线程共享，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。

        * 在虚拟机启动时创建。

        * 是垃圾回收的主要场所。

        * 区域划分

            * 新生代(Young区)
        
                * Eden区(8)
        
                * Survior区(1)
        
                    * From space区
        
                    * To Space区
    
                * 当扩展内存大于可用内存，抛OOM
        
            * 老年代(Old区)
    
                * Tenured Gen

    不同的区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性。

    堆的大小既可以固定也可以扩展，但对于主流的虚拟机，堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已无法再扩展时，就抛出 OutOfMemoryError 异常。

    **Java 堆所使用的内存不需要保证是连续的。而由于堆是被所有线程共享的，所以对它的访问需要注意同步问题，方法和对应的属性都需要保证一致性。**

1. 方法区(1.7的实现在堆中即永久代PermGen)

    * 定义

        * Java 虚拟机规范中定义方法区是堆的一个逻辑部分。方法区存放以下信息：

            * 已经被虚拟机加载的类信息
    
            * 常量池(JDK1.6中)
            
            * 静态变量
            
            * 即时编译器编译后的代码

    * 特点

        * 该区域是JDK1.7中的实现, JDK1.8中该区域被元数据区取代

        * 线程共享。 方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。

        * 永久代。 方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，把方法区称为“永久代”。
        
        * 内存回收效率低。 方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。
        
        * Java 虚拟机规范对方法区的要求比较宽松。 和堆一样，允许固定大小，也允许动态扩展，还允许不实现垃圾回收。

        * 这个区域回收目标主要是针对常量池的回收和对类型的卸载

        * 当内存申请大于实际可用内存，抛OOM。

1. 运行时常量池(JDK1.6属于方法区JDK1.7属于堆)

    * 方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码。常量就存放在运行时常量池中。

    * 当类被 Java 虚拟机加载后， .class 文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如 String 类的 intern() 方法就能在运行期间向常量池    中添加字符串常量。

### 本地内存

1. 元空间(Metaspace元数据区, JDK1.8的实现)

    * 该区域是JDK1.8中对方法区的实现, 取代了永久代

    * 元空间的本质和永久代类似, 都是对JVM规范方法区的实现, 元空间使用本地内存

    * 为什么要移除持久带而是用元数据区?

        大致就是说移除持久代也是为了和JRockit进行融合而做的努力，JRockit用户并不需要配置持久代（因为JRockit就没有持久代）。

        从内因来说，持久代大小受到-XX：PermSize和-XX：MaxPermSize两个参数的限制，而这两个参数又受到JVM设定的内存大小限制，这就导致在使用中可能会出现持久代内存溢出的问题，因此在Java 8及之后的版本中彻底移除了持久代而使用Metaspace来进行替代。

1. 直接内存(堆外内存)
    
    * 在 NIO 中引入了一种基于通道和缓冲的 IO 方式。它可以通过调用本地方法直接分配 Java 虚拟机之外的内存，然后通过一个存储在堆中的 DirectByteBuffer对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。

    * 直接内存的大小不受 Java 虚拟机控制，但既然是内存，当内存不足时就会抛出 OutOfMemoryError 异常。

    * 直接内存与堆内存比较

        * 直接内存申请空间耗费更高的性能

        * 直接内存读取 IO 的性能要优于普通的堆内存。
        
        * 直接内存作用链： 本地 IO -> 直接内存 -> 本地 IO
        
        * 堆内存作用链：本地 IO -> 直接内存 -> 非直接内存 -> 直接内存 -> 本地 IO

    **服务器管理员在配置虚拟机参数时，会根据实际内存设置 -Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现 OutOfMemoryError异常。**
    
    ![http://www.miaomiaoqi.cn/images/jvm/1.png](http://www.miaomiaoqi.cn/images/jvm/1.png)
    

## 总结

1. 以上是Java虚拟机规范，不同的虚拟机实现会各有不同，但是一般会遵守规范。

2. 规范中定义的方法区，只是一种概念上的区域，并说明了其应该具有什么功能。但是并没有规定这个区域到底应该处于何处。所以，对于不同的虚拟机实现来说，是有一定的自由度的。

3. 不同版本的方法区所处位置不同，上图中划分的是逻辑区域，并不是绝对意义上的物理区域。因为某些版本的JDK中方法区其实是在堆中实现的。

4. 运行时常量池用于存放编译期生成的各种字面量和符号应用。但是，Java语言并不要求常量只有在编译期才能产生。比如在运行期，String.intern也会把新的常量放入池中。

5. 除了以上介绍的JVM运行时内存外，还有一块内存区域可供使用，那就是直接内存。Java虚拟机规范并没有定义这块内存区域，所以他并不由JVM管理，是利用本地方法库直接在堆外申请的内存区域。

6. 堆和栈的数据划分也不是绝对的，如HotSpot的JIT会针对对象分配做相应的优化。

如上，做个总结，JVM内存结构，由Java虚拟机规范定义。描述的是Java程序执行过程中，由JVM管理的不同数据区域。各个区域有其特定的功能。


## 参考

[https://mp.weixin.qq.com/s/ZcjAbCgLtwvEo0S4gZxgnQ][1]

[1]: https://mp.weixin.qq.com/s/ZcjAbCgLtwvEo0S4gZxgnQ


    
    
    
    
    
    
    
    
    
    