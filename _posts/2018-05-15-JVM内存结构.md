---
layout: post
title:  "JVM内存结构"
date:   2018-05-17 21:12:38
categories: Java
tags: JVM
author: miaoqi
---

* content
{:toc}

## 简介

* 我们都知道，Java代码是要运行在虚拟机上的，而虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途。

    其中有些区域随着虚拟机进程的启动而存在，而有些区域则依赖用户线程的启动和结束而建立和销毁。在《Java虚拟机规范（Java SE 8）》中描述了JVM运行时内存区域结构如下：

### JVM虚拟机数据区(JDK1.7中是5块区域, JDK1.8中是4块, 方法区被提到了本地内存)

#### 线程独占区

1. 程序计数器(PC寄存器)

    * 程序计数器是一块较小的内存空间, 它可以看做是当前线程所执行的字节码的行号指示器

    * 程序计数器处于线程独占区

    * 如果线程执行的是Java方法, 这个计数器记录的是正在执行的虚拟机字节码指令的地址. 如果正在执行的是native方法, 这个计数器的值为undefined

    * 此区域是唯一一个在Java虚拟机规范中没有任何OutOfMemoryError情况的区域

1. Java虚拟机栈

    * 虚拟机栈描述的是Java方法执行的动态内存模型

    * 栈桢

        * 每个方法执行都会创建一个栈桢, 伴随着方法从创建到执行完成. 用于存储局部变量表, 操作数栈, 动态链接, 方法出口等

    * 局部变量表

        * 存放编译期可知的各种基本数据类型, 引用类型, returnAddress类型

        * 局部变量表的内存空间在编译期完成分配, 当进入一个方法时, 这个方法需要在帧分配多少内存是固定的, 在方法运行期间是不会改变局部变量表的大小

    * 两种异常情况

        * 若线程请求深度大于栈的深度，抛StackOverflowError

        * 若栈在动态扩展时无法请求足够内存，抛OutOfMemoryError

1. 本地方法栈

    * 虚拟机栈为虚拟机执行Java方法服务

    * 本地方法栈为虚拟机执行native方法服务

    * 会抛StackOverflowError和OOM

#### 线程共享区

1. Java堆

    * 存放对象实例和数组
    
    * 虚拟机启动时创建

    * 垃圾收集器管理的主要区域

    * 区域划分

        * 新生代(Young区)
    
            * Eden区(8)
    
            * Survior区(1)
    
                * From space区
    
                * To Space区

            * 当扩展内存大于可用内存，抛OOM
    
        * 老年代(Old区)

            * Tenured Gen

    * OutOfMemoryError

    * -Xmx -Xms

1. 方法区(永久代)

    * 该区域是JDK1.7中的实现, JDK1.8中该区域被元数据区取代

    * 存储虚拟机加载的类信息, 常量, 静态变量, 即时编译器编译后的代码等数据

        * 类的版本

        * 字段

        * 方法

        * 接口

    * 这个区域回收目标主要是针对常量池的回收和对类型的卸载

    * 当内存申请大于实际可用内存，抛OOM。

### 本地内存

1. 元空间(元数据区, JDK1.8的实现)

    * 该区域是JDK1.8中对方法区的实现, 取代了永久代

    * 元空间的本质和永久代类似, 都是对JVM规范方法区的实现, 元空间使用本地内存

1. 直接内存
    
    * NIO中使用到的, 可以分配堆外内存, 不受约于JVM限制, 可以提高性能

1. 运行时常量池(属于方法区)

    * 方法区内有一块内存存储运行时常量


## 总结

1. 以上是Java虚拟机规范，不同的虚拟机实现会各有不同，但是一般会遵守规范。

2. 规范中定义的方法区，只是一种概念上的区域，并说明了其应该具有什么功能。但是并没有规定这个区域到底应该处于何处。所以，对于不同的虚拟机实现来说，是有一定的自由度的。

3. 不同版本的方法区所处位置不同，上图中划分的是逻辑区域，并不是绝对意义上的物理区域。因为某些版本的JDK中方法区其实是在堆中实现的。

4. 运行时常量池用于存放编译期生成的各种字面量和符号应用。但是，Java语言并不要求常量只有在编译期才能产生。比如在运行期，String.intern也会把新的常量放入池中。

5. 除了以上介绍的JVM运行时内存外，还有一块内存区域可供使用，那就是直接内存。Java虚拟机规范并没有定义这块内存区域，所以他并不由JVM管理，是利用本地方法库直接在堆外申请的内存区域。

6. 堆和栈的数据划分也不是绝对的，如HotSpot的JIT会针对对象分配做相应的优化。

如上，做个总结，JVM内存结构，由Java虚拟机规范定义。描述的是Java程序执行过程中，由JVM管理的不同数据区域。各个区域有其特定的功能。


    
    
    
    
    
    
    
    
    
    