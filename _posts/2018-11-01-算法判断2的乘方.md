---
layout: post
title: "算法-判断 2 的乘方"
categories: [Algorithm]
description:
keywords:
---

* content
{:toc} 

## 题目

实现一个方法，判断一个正整数是否是 2 的乘方（比如 16 是 2 的 4 次方，返回 True；18 不是 2 的乘方，返回 False）。要求性能尽可能高。

## 解法一

创建一个中间变量 Temp，初始值是 1。然后进入一个循环，循环中每次让 Temp 和目标整数比较，如果相等，则说明目标整数是2 的乘方；如果不相等，则让 Temp 增大一倍，继续循环比较。当 Temp 大于目标整数时，说明目标整数不是 2 的乘方。

如果目标整数的大小是 N，则此方法的时间复杂度是O(LogN)

## 解法二

非常有趣也非常简单的解法。因为2的乘方都符合一个规律，即 N & N-1 等于 0，所以直接用这个规律判断即可。该算法时间复杂度是 O(1)

|十进制|二进制|是否2的乘方|
|---|---|---|
|8|1000B|是|
|16|10000B|是|
|32|100000B|是|
|64|1000000B|是|
|100|1100100B|否|

如果一个整数是 2 的乘方, 那么转成 2 进制的时候只有最高位是 1, 如果把这些二进制都减去 1 会有什么效果呢?

| 十进制 | 二进制 | N-1  | 是否 2 的乘方 |
| ------ | ------ | ----- | ------------ |
| 8    | 1000B | 111B | 是   |
| 16   | 10000B | 1111B | 是   |
| 32   | 100000B | 11111B | 是   |
| 64   | 1000000B | 111111B | 是   |
| 100  | 1100100B | 1100011B | 否   |

如果减去 1, 那么整个数减少一位, 其他位由 0 变成 1

如果这时候我们用 2 的乘方本身和它减一的结果进行按位与运算, 也就是 N & N-1

|十进制|二进制|N-1|N&N-1|是否2的乘方|
|---|---|---|---|---|
|8|1000B|111B|0|是|
|16|10000B|1111B|0|是|
|32|100000B|11111B|0|是|
|64|1000000B|111111B|0|是|
|100|1100100B|1100011B|1100000B|否|

0 与 1 的按位与的结果是 0, 所以凡是 2 的乘方和它本身减一相与, 即 N & N-1结果必然是 0





