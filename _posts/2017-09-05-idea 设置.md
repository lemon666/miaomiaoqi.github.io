---
layout: post
title: "IDEA 设置"
categories: [IDE]
description:
keywords:
---

* content
{:toc}


## IDEA 设置


* Keymap设置为Eclipse(Mac OS X)

    Preferences -> KeyMap -> 在MAC下将idea快捷键映射为Eclipse(Mac OS X), Windows下映射为Eclipse, Mac中的command对应Windows中的Ctrl, 所以本文中涉及到command的地方在Windows下全部改为Ctrl

* 界面主题

    Preferences -> Appearance & Behavior -> Appearance -> Theme

* 代码主题

    Preferences -> Editor -> Color Scheme -> General

* 修改主题包

    http://color-themes.com/?view=index下载主题

    File -> import setting -> 选择主题包

    Preferences -> Editor -> Color Scheme

* 单行注释位置

    Preferences -> Editor -> Code Style -> Java -> Code Generation -> Comment Code -> 去除复选框

* 左侧界面字体

    Preferences -> Appearance & Behavior -> Appearance -> 勾选Override

* 代码字体

    Preferences -> Editor -> Font -> Save As 创建Scheme调整字体

    Preferences -> Editor -> Color Scheme -> Color Scheme Font 关闭字体包的格式才能使上边的设置生效

* 背景颜色

    Preferences -> Editor -> Color Scheme -> General -> Text -> Default Text

* 代码加粗

    Preferences -> Editor -> Color Scheme -> General -> Text -> Default Text 勾选右侧 Bold

* 注释去掉下划线

    Preferences -> Editor -> Color Scheme -> Java -> Comments -> JavaDoc -> Tag -> 去除 Effects

* 去掉单词拼写检测

    Preferences -> Inspections -> Spelling -> Typo

* 方法签名提示

    Preferences -> Editor -> General -> Code Completion -> 勾选下边3个选项

    Preferences -> Editor -> General -> Appearance -> Show parameter name hints -> 确定是否勾选

* 隐藏缩进线

    Preferences -> Editor -> General -> Appearance -> Show indent guides

* 开启自动编译

    Preferences -> Build, Execution, Deployment -> Compiler -> 勾选Build project automatically

* 自动导包

    Preferences -> Editor -> General -> Auto Import

    勾选标注 Optimize 选项, IntelliJ IDEA 将在我们书写代码的时候自动帮我们优化导入的包, 比如自动去掉一些没有用到的包。

    勾选标注 Add unambiguous 选项, IntelliJ IDEA 将在我们书写代码的时候自动帮我们导入需要用到的包。但是对于那些同名的包, 还是需要手动Alt + Enter 进行导入的, IntelliJ IDEA 目前还无法智能到替我们做判断。

* 代码提示敏感度

    Preferences -> Editor -> General -> Code Completion -> 大小写敏感设置

* 根据语言设置代码风格

    Preferences -> Editor -> Code Style -> Java

* tab转为4个空格(根据公司设置)

    Preferences -> Editor -> Code Style -> Java -> 右侧设置

* 多个tab页换行显示

    Preferences -> Editor -> General -> Editor Tabs -> Show tabs in single row

* 设置代码检查等级

    这个在界面的右下角, 一个老头图标（打开代码文件才能看到）。那个可以拖动的控件就是设置代码检查等级的。

    Inspections 为最高等级检查, 可以检查单词拼写, 语法错误, 变量使用, 方法之间调用等。

    Syntax 可以检查单词拼写, 简单语法错误。

    None 不设置检查。

* 设置代码折叠

    Preferences -> Editor -> General -> Code Folding

* 光标移动查看javadoc

    Preferences -> Editor -> General -> Show quick documentation on mouse move

* 显示行号

    Preferences -> Editor -> General -> Appearance -> 勾选 Show line numbers

* 代码自动换行

    Preferences -> Editor -> Code Style -> 勾选Wrap on typing

* 编码设置

    Preferences -> Editor -> File Encodings

* 隐藏默认生成文件

    Preferences -> Editor -> File Types -> 下方输入要忽略的文件格式用;分割

    *.idea;*.settings;*.project;*.classpath;*.gitignore;*.iml;

* 配置Maven

    Preferences -> Build, Execution, Deployment -> Build Tools -> Maven

    File -> Other Settings -> Default Settings

* 配置tomcat

    Preferences -> Build, Execution, Deployment -> Application Servers -> 点击加号配置tomcat

    部署项目:
    屏幕右上方 -> Edit Configurations -> 点击加号添加Tomcat Server -> Local
    Server选项卡配置tomcat
    Deployment选项卡配置项目

    VM options: -Dfile.encoding=UTF-8: 解决中文乱码

* 类注释:

    Preferences -> Editor -> File and Code Templates -> Includes -> File Header

    直接在右边的文件框里编辑你说需要注释的东西, 然后应用保存之后,当你创建类的时候就会自动生成注释。

* 修改过的文件加*

    Preferences -> Editor -> General -> Editor Tabs -> 勾选Mark modified(*)

* 自动编译

    Preferences -> Build, Execution, Deployment -> Compiler -> 勾选 Build project automatically

* 方法注释:

    Preferences -> Editor -> Live Templates点击右边上面那个绿色的+号, 选择Template Group双击, 然后弹出一个窗口, 随便添加一个名字. 建议将注释的模板名字设为*
    点击一下刚刚你添加的那个名字（我这是Java）, 然后点击右边上面那个绿色的+号, 选择LiveTemplate双击, 填写信息

* 设置Live Templates

    增加自己的Template, 如下是我的配置:

    ```java
    *:
    *
     * $VAR1$
     *
     * @author miaoqi
     * @date $date$
     * 
    $param$
     *       
     * @return $VAR2$
     */$END$
    
    ac:
    /**
     * $VAR1$
     *
     * @author miaoqi
     * @date $date$
     */$END$
    
    af:
    /**
     * $VAR1$
     */$END$
      
    al:
    /*
     * $VAR1$
     */$END$
       
    am:
    /**
     * $VAR1$
     *
     * @author miaoqi
     * @date $date$
     *
     * @return $VAR2$
     */$END$
       
    au:
    @Autowired
    
    co:
    @Component
    
    con:
    @RestController
    @Slf4j
    
    de:
    @DeleteMapping
    
    deu:
    @DeleteMapping("/$VAR1$")$END$
    
    for:
    for(int $INDEX$ = 0; $INDEX$ < $LIMIT$; $INDEX$++) {
        $END$
    }
    
    fora:
    for(int $INDEX$ = 0; $INDEX$ < $ARRAY$.length; $INDEX$++) {
        $ELEMENT_TYPE$ $VAR$ = $ARRAY$[$INDEX$];
        $END$
    }
    
    fore:
    for ($ELEMENT_TYPE$ $VAR$ : $ITERABLE_TYPE$) {
      $END$
    }
    
    forit:
    for($ITER_TYPE$ $ITER$ = $COLLECTION$.iterator(); $ITER$.hasNext(); ) {
    		$ELEMENT_TYPE$ $VAR$ =$CAST$ $ITER$.next();
    		$END$
    }
    
    forli:
    for (int $INDEX$ = 0; $INDEX$ < $LIST$.size(); $INDEX$++) {
      $ELEMENT_TYPE$ $VAR$ = $CAST$ $LIST$.get($INDEX$);
      $END$
    }
    
    ge:
    @GetMapping
    
    geu:
    @GetMapping("/$VAR1$")$END$
    
    if:
    if ($VAR1$) {
        $END$
    }
    
    ife:
    if ($VAR1$) {
        $END$
    } else {
    }
    
    ld:
    LoggerUtil.debug(logger, "$VAR1$", $VAR2$);$END$
    
    le:
    LoggerUtil.error(logger, "$VAR1$", $VAR2$);$END$
    
    li:
    LoggerUtil.info(logger, "$VAR1$", $VAR2$);$END$
    
    logger:
    private static final Logger logger = LoggerFactory.getLogger($VAR1$.class);$END$
    
    lw:
    LoggerUtil.warn(logger, "$VAR1$", $VAR2$);$END$
    
    main:
    public static void main(String[] args){
        $END$
    }
    
    mcp:
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.0</version>
                <configuration>
                    <target>1.8</target>
                    <source>1.8</source>
                </configuration>
            </plugin>
        </plugins>
    </build>
    
    pi:
    private Integer $VAR1$;
    
    $END$
      
    pic:
    /**
     * $VAR1$
     */
    private Integer $VAR2$;
    
    $END$
      
    pl:
    private Long $VAR1$;
    
    $END$
      
    plc:
    /**
     * $VAR1$
     */
    private Long $VAR2$;
    
    $END$
      
    po:
    @PostMapping
    
    pou:
    @PostMapping("/$VAR1$")$END$
    
    poj:
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @ToString
    
    ps:
    private String $VAR1$;
    
    $END$
      
    psc:
    /**
     * $VAR1$
     */
    private String $VAR2$;
    
    $END$
      
    psfi:
    public static final int $VAR1$ = $VAR2$;$END$
      
    psfic:
    /**
     * $VAR1$
     */
    public static final int $VAR2$ = $VAR3$;$END$
      
    psfs:
    public static final String $VAR1$ = "$VAR2$";$END$
      
    psfsc:
    /**
     * $VAR1$
     */
    public static final String $VAR2$ = "$VAR3$";$END$
      
    pu:
    @PutMapping
    
    puu:
    @PutMapping("/$VAR1$")$END$
      
    ser:
    @Service
    @Slf4j
    
    swi:
    switch ($VAR1$) {
        case "$END$":
            break;
        default:
            break;
    }
    
    syso:
    System.out.println($VAR1$);$END$
      
    te:
    @Test
    
    thr:
    throw new $VAR1$;$END$
    
    whit:
    while($ITER$.hasNext()){
        $TYPE$ $VAR$ = $CAST$ $ITER$.next();
        $END$
    
    ```

