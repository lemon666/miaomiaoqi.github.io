---
layout: post
title: "MySQL 学习"
categories: [RDBMS]
description: mysql基础语法
keywords: rdbms, mysql
---

* content
{:toc}
## 基础操作

### 数据库操作

创建数据库

```mysql
create database web08; --默认字符集
create database web08_01 character set gbk; --指定字符集
```

查看数据库

```mysql
show databases;
```

查看数据库结构

```mysql
show create database web08_01;
```

查看正在使用的库

```mysql
select database();
```

删除一个库

```mysql
drop database web08_01;
```

使用库

```mysql
use web08;
```

导出整个库

```mysql
mysqldump -u 用户名 -p 数据库名 > 导出的文件名
```


### 表操作

创建表
```mysql
create table 表名{
    字段名 类型(长度) [约束],
    字段名 类型(长度) [约束]
};
      
create table user(
    uid int(32) primary key auto_increment,
    uname varchar(32),
    upassword varchar(32)
);
      
主键约束: primary key 要求被修饰的字段: 唯一和非空
唯一约束: unique 要求被修饰的字段: 唯一
非空约束: not null 要求被修饰的字段: 非空
```

查看表列表

```mysql
show tables;
```

查看表结构

```mysql
desc user;
```

删除表

```mysql
drop table user;
```

修改表

```mysql
alter table user add column uinfo varchar(32) not null; --增加一列

alter table user modify uinfo varchar(50) not null; -- 修改列的长度, 类型, 约束

alter table user change 旧列名 新列名 类型(长度) 约束; -- 修改列名, 类型, 约束

alter table user drop 列名; -- 删除列

rename table 表名 to 新表名; -- 修改表名

alter table 表名 character set 字符集 -- 修改表的字符集
```

查看当前表的编码

```mysql
show create table tbl_user;
```

导出一个表

```bash
mysqldump -u 用户名 -p 数据库名 表名> 导出的文件名
```

导入

```bash
在 mysql命令行界面 source 目标sql文件
```

插入记录

```mysql
insert into 表(列名1, 列名2, 列名3, ...) values(值1, 值2, 值3);

insert into 表 values(值1, 值2, 值3...);
```

更新记录

```mysql
update 表名 set 字段名=值, 字段名=值 where = 条件
```

删除记录

```mysql
delete from 表名 where = 条件
```

从现有表新建表

```mysql
create table new_table_name from select [*|column1,column2] from table_name [where]
```

### 查询

准备工作
```mysql
create table product(    
    pid int primary key auto_increment,   
    pname varchar(20),   
    price double,   
    pdate timestamp,
    cid varchar(32)
)
```

自动增长列:auto_increment

1.  必须整型(int) 
2.  必须是主键

```mysql
insert into product values (null,'谭妮平',0.01,null,1);
insert into product values (null,'李士雪',38,null,1);
insert into product values (null,'左慈',-998,null,1);
insert into product values (null,'黄迎',99999,null,2);
insert into product values (null,'南国强',99998,null,2);
insert into product values (null,'士兵',1,null,2);
insert into product values (null,'李士兵',698,null,3);
insert into product values (null,'士兵',1,null,3);
```

简单查询

1.  查询所有商品

    ```mysql
    select * from product;
    ```

2.  查询商品名和商品价格

    ```mysql
    select pname, price from product;
    ```

3.  查询所有商品信息使用表别名

    ```mysql
    select * from product as p; --as可以省略
    ```

4.  查询商品名, 使用列别名

    ```mysql
    select pname as name from product; --as可以省略
    ```

5.  去掉重复值(按照价格)

    ```mysql
    select distinct price from product;
    ```

6.  将所有的商品的价格+10进行显示

    ```mysql
    select price + 10 from product;
    ```

条件查询

1.  查询商品名称为"左慈"的商品信息

    ```mysql
    select * from product where pname = '左慈';
    ```

2.  查询价格>60元的所有商品信息

    ```mysql
    select * from product where price > 60;
    ```

3.  查询商品名称含有"士"字的商品信息

    ```mysql
    select * from product where pname like '%士%';
    ```

4.  查询商品id在(3,6,9)范围内的所有商品信息

    ```mysql
    select * from product where pid in (3, 6, 9);
    ```

5.  查询商品名称含有"士"字并且id=6的商品

    ```mysql
    select * from product where pname like '%士%' and pid = 6;
    ```

排序(asc/desc)

1.  查询所有的商品, 按价格进行排序(升序, 降序)

    ```mysql
    select * from product order by price asc;
    ```

2.  查询名称有"士"的商品信息并且按照价格降序排序

    ```mysql
    select * from product where pname like '%士%' order by price desc, pid desc;
    ```

聚合

1. 获得所有商品的价格的总和

  ```mysql
  select sum(price) from product;
  ```

2. 获得所有商品的平均价格
   
    ```mysql
    select avg(price) from product;
    ```
    
3. 获得所有商品的个数
   
    ```mysql
    select count(*) from product;
    ```

分组

1.  根据cid字段分组, 分组后统计商品的个数.

    ```mysql
    select count(*) from product group by cid;
    ```

2.  根据cid分组, 分组统计每组商品的平均价格, 并且平均价格大于20000元.

    ```mysql
    select avg(price) from product group by cid having avg(price) > 20000;
    ```

外键

1.  添加

    ```mysql
    alter table product add foreign key [constraint] [constraint_name] (从表外键字段名) references 主表(主表的主键)
    ```

多表查询

1. 交叉连接查询(基本不会使用, 得到的是两个表的乘积)

    ```mysql
    select * from A,B;
    ```

2. 内连接查询(使用 inner join --inner可以省略)

    隐士内连接: `select * from A,B where 条件`

    显示内连接: `select * from A inner join B on 条件`

3. 外连接查询(使用 outer join --outer可以省略)
   

  左外连接: `select * from A left outer join B on 条件`

    右外连接: `select * from A right outer join B on 条件`

4. 全连接 full outer join(oracle中)

5. 联合查询

     union:去重,排序,效率低

     union all:不去重,不排序,效率高

<img src="http://www.milky.show/images/mysql/1.png" alt="http://www.milky.show/images/mysql/1.png" style="zoom:67%;" />复制现有表

```mysql
create table new_table select * from old_table;
```


### 完整性约束

主键约束: 主键是表里一个或多个用于实现记录唯一性的字段

```mysql
create table table_name(
    id int primary key,
    name varchar(20)
);

create table table_name(
    id int,
    name varchar(20),
    primary key(id)
);
```

唯一性约束: 唯一性要求表里的某个字段的值在每条记录里是唯一的

```mysql
create table table_name(
    id int primary key,
    name varchar(20),
    cellphone varchar(11) unique
);
```

外键约束: 外键是从表里的一个字段, 引用主表里的主键

```mysql
create table tb_emp(
    id int primary key,
    dept_id int,
    constraint fk_emp_dept_id foreign_key(dept_id) references tb_dept(id)
);
```


### 服务操作

启动服务端(mac)

```bash
mysql.server start
```

停止服务端(mac)

```bash
mysql.server stop
```

启动客户端(mac)

```bash
mysql -uroot -p
```

启动服务端(Linux)

```bash
service mysqld start
```

停止服务端(Linux)

```bash
service mysqld stop
```

### 权限操作

授权操作

```mysql
grant all privileges on databasename.tablename to 'username'@'addr' identified by 'password';

将所有库的所有表的增删改查权限授权给miaomiaoqi用户在localhost登录时, 并且密码是miaoqi
grant select,delete,update,INSERT on *.* to 'miaomiaoqi'@'localhost' identified by 'miaoqi';
```

```mysql
grant all PRIVILEGES on *.* to 'miaomiaoqi'@'localhost' identified by 'miaoqi';
```

查看权限

```mysql
show grants;

show grants for username;

select * from mysql.user;
```



### 特殊sql

补充自增主键

```mysql
alter table `表名` add column `列名` int not null auto_increment primary key comment '主键' first;
```

中文字段排序

```mysql
ORDER BY CONVERT(column USING gbk) ASC
```

## 锁

### 悲观锁

数据库层面加个排它锁, 性能低

```mysql
select * from account for update;
try {
    // process business logic
    commit();
} catch (Exception e) {
    rollback();
}
```

### 乐观锁

程序员手动控制(CAS机制)

```mysql
int version = select version from tb_xxx where id = 1;
boolean success = update tb_xxx set name = 'bbb' where id = 1 and version = 1.0
if (!success) {
    try...again
}
```

## 函数

### DATE_FORMAT

日期格式化函数

```mysql
SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s') FROM DUAL;
```

### INSTR

判断 fo 是否在 foobarbar 中

```mysql
SELECT INSTR('foobarbar', 'fo') FROM DUAL;
```

### GROUP_CONCAT

我们在写统计 sql 的时候, 有时候需要根据某个字段进行 group by 操作, 当我们进行 group by 操作后, 多条数据会合并成一条, 这时候想要展示出其他字段的值, 就可以使用 group_concat 函数, 假设有如下数据

username	score
zhangsan	10
zhangsan	20
zhangsan	30
lisi			50

根据 username 进行group by 多条数据就会合成一条

```mysql
select * from tbl group by username;
```

执行结果如下:

username	score

zhangsan	10

lisi			50

如果我们想要看下zhangsan和lisi的全部得分怎么办呢? group_concat函数就出场了, 修改sql如下

```mysql
select username, group_concat(score) from tbl group by username;
```

执行结果如下:

username	group_concat(score)

zhangsan	10, 20, 30

lisi			50

到此group_concat的用法就介绍完了

**group_concat 存在的问题**

在做项目中, 遇到了一个很奇葩的问题, 应该给用户返钱, 但总是漏掉一些用户, 通过查看日志发现, group_concat 后的数据少了一部分, 通过查找发现 mysql 的 group_concat 默认连接长度为 1024 字符, 也就是说如果超过 1024 字符, 它只会显示这么多, 其余部分会被截取丢掉, 导致我们漏掉了数据

* 解决办法一

    修改连接的配置

    ```
    SET GLOBAL group_concat_max_len=102400;
    SET SESSION group_concat_max_len=102400; 
    ```

* 解决办法二

    修改 mysql 配置文件, 在 mysql 配置文件中添加如下这句, 修改配置文件后记得需要重启 mysql 服务

    ```
    group_concat_max_len = 102400
    ```

虽然上面的办法可以解决问题, 但是使用函数终究性能不会太好, 所以我决定以后避免使用 group_concat 函数, 而是通过关键列进行简单的索引查找, 在应用层中进行分组, 这样可以避免一些不可预知的问题, 也可以减少 mysql 的压力



## 主从一致 binlog

binlog 是用来实现 mysql 主从的重要文件

主库负责写, 从库负责读, 主库会启动一个线程, 将写操作写到日志文件 binlog 中, 从库会启动一个 IO 线程负责从日志文件中读取操作记录, SQL 线程负责执行操作记录进行同步

如何保持一致性: 减少数据库压力

binlog 是记录所有数据库表结构变更(例如CREATE, ALTER TABLE…)以及表数据修改(INSERT, UPDATE, DELETE…)的二进制日志

binlog 不会记录 SELECT 和 SHOW 这类操作, 因为这类操作对数据本身并没有修改, 但你可以通过查询通用日志来查看 MySQL 执行过的所有语句.

**多说一句, 如果 update 操作没有造成数据变化, 也是会记入binlog.**

### 误解

binlog只是一类记录操作内容的日志文件

因为binlog称之为二进制日志, 很多研发会把这个二进制日志和我们平时在代码里写的代码日志联系在一起.因为我们的代码日志, 只有一类记录操作容的文件, 并不包含索引文件.然而, 这个二进制日志包括两类文件:

* 索引文件(文件名后缀为.index)用于记录哪些日志文件正在被使用
* 日志文件(文件名后缀为.00000*)记录数据库所有的DDL和DML(除了数据查询语句)语句事件

假设文件my.cnf中有这么三条配置

```
log_bin:on 打开binlog日志

log_bin_basename:bin文件路径及名前缀(/var/log/mysql/mysql-bin)

log_bin_index:bin文件index(/var/log/mysql/mysql-bin.index)
```

那么你会在文件目录/var/log/mysql/下面发现两个文件mysql-bin.000001和mysql-bin.index.
mysql-bin.index就是我们所说的索引文件, 打开瞅瞅, 内容是下面这样,记录哪些文件是日志文件.

```
./mysql-bin.000001
```

那么说到日志文件.在innodb里其实又可以分为两部分, 一部分在缓存中, 一部分在磁盘上.这里业内有一个词叫做刷盘, 就是指将缓存中的日志刷到磁盘上.跟刷盘有关的参数有两个个:sync_binlog和binlog_cache_size.这两个参数作用如下

```
binlog_cache_size: 二进制日志缓存部分的大小, 默认值32k

sync_binlog=[N]: 表示写缓冲多少次, 刷一次盘,默认值为0
```

注意两点:

* binlog_cache_size设过大, 会造成内存浪费.binlog_cache_size设置过小, 会频繁将缓冲日志写入临时文件.具体怎么设, 有兴趣自行查询, 我觉得研发大大根本没机会去设这个值的, 了解即可.
* sync_binlog=0:表示刷新binlog时间点由操作系统自身来决定, 操作系统自身会每隔一段时间就会刷新缓存数据到磁盘, 这个性能最好.sync_binlog=1, 代表每次事务提交时就会刷新binlog到磁盘.sync_binlog=N,代表每N个事务提交会进行一次binlog刷新.

另外, 这里存在一个一致性问题, sync_binlog=N, 数据库在操作系统宕机的时候, 可能数据并没有同步到磁盘, 于是再次重启数据库, 会带来数据丢失问题. 
当sync_binlog=1, 事务在Commit的时候, 数据写入binlog, 但是还没写入事务日志(redo log和undo log).此时宕机, 重启数据库, 数据被回滚.但是binlog里已经记录, 这里存在不一致问题.这个事务日志和binlog一致性的问题, 大家可以查询mysql的内部XA协议, 该协议就是解决这个一致性问题的.

**binlog是InnoDb独有的**

binlog是以事件形式记录的, 这句话通俗点说, 就是binlog的内容都是一个个的事件.这块具体的我会在下一篇讲, 这篇记住binlog的内容就是一个个事件就行.
注意了, 这里的用词, 是一个个事件, 而不是事务.大家应该知道Innodb和mysiam最显著的区别就是一个支持事务, 一个不支持事务.
因此你可以说, binlog是基于事务来记录二进制日志, 比如sync_binlog=1,每提交一次事务, 就写入binlog.你却不能说binlog是事务日志, binlog不仅记录innodb日志, 在myisam中, 也一样存在binlog.

### 数据库常用语句

| sql 语句                                                | 含义                                                         |
| :------------------------------------------------------ | :----------------------------------------------------------- |
| show variables like 'bin_log';                          | 查看是否开启 binlog                                          |
| show variables like 'binlog_format';                    | 查看 binlog 格式                                             |
| show master logs;                                       | 查看所有的 binlog 日志列表                                   |
| show master status;                                     | 查看最后一个 Binlog 日志的编号名称, 及最后一个事件结束的位置(pos) |
| flush logs;                                             | 刷新 Binlog, 此刻开始产生一个新编号的 Binlog 文件            |
| reset master;                                           | 清空所有的 Binlog 日志                                       |
| show binlog events;                                     | 查看第一个 Binlog 日志                                       |
| show binlog events in 'binlog.000030'                   | 查看指定的 Binlog 日志                                       |
| show binlog events in 'binlog.000030' from 931;         | 从指定位置开始, 查看指定 Binlog 日志                         |
| show binlog events in 'binlog.000030' from 931 limit 2; | 从指定位置开始, 查看指定 Binlog 日志, 限制查询的条数         |

**Binlog 的 Event_type**

query_event: 与数据操作无关, begin, drop table, truncate table 等

table_map_event: 记录下一个操作所对应的表信息, 存储了数据库名和表名

xid_event: 标记事务提交

write_rows_event: 插入数据, 即 insert 操作

update_rows_event: 更新数据, 即 update 操作

delete_rows_event: 删除数据, 即 delete 操作

### 用途

#### 复制

主库有一个单独的log dump线程, 将binlog传给从库
从库有两个线程, 一个I/O线程, 一个SQL线程, I/O线程读取主库传过来的binlog内容并写入到relay log,SQL线程从relay log里面读取内容, 写入从库的数据库, 这也是主从的原理.

#### 恢复

这里网上有大把的文章指导你, 如何利用binlog日志恢复数据库数据.如果你真的觉得自己很有时间, 就自己去创建个库, 然后删了, 再去恢复一下数据, 练练手吧.

#### 审计

 用户可以通过二进制日志中的信息来进行审计, 判断是否有对数据库进行注入攻击

### 常识

#### binlog常见格式

| format    | 定义                       | 优点                           | 缺点                                                         |
| --------- | -------------------------- | ------------------------------ | ------------------------------------------------------------ |
| Statement | 记录的是修改SQL语句        | 日志文件小, 解决IO, 提高性能   | 准确性差, 对一些系统函数不能准确复制或不能复制, 如now(), uuid()等 |
| row       | 记录的是每行实际数据的变更 | 准确性强, 能准确复制数据的变更 | 日志文件大, 较大的网络IO和磁盘IO                             |
| mixed     | statement和row模式的混合   | 准确性强, 文件大小合适         | 有可能发生主从不一致问题                                     |

**业内目前推荐使用的是row模式**, 准确性高, 虽然说文件大, 但是现在有SSD和万兆光纤网络, 这些磁盘IO和网络IO都是可以接受的.那么, 大家一定想问, 为什么不推荐使用mixed模式, 理由如下, 假设master有两条记录, 而slave只有一条记录.

<img src="http://www.milky.show/images/mysql/binlog_1.png" alt="http://www.milky.show/images/mysql/binlog_1.png" style="zoom:67%;" />

当在master上更新一条从库不存在的记录时, 也就是id=2的记录, 你会发现master是可以执行成功的.而slave拿到这个SQL后, 也会照常执行, 不报任何异常, 只是更新操作不影响行数而已.并且你执行命令show slave status, 查看输出, 你会发现没有异常.但是, 如果你是row模式, 由于这行根本不存在, 是会报1062错误的.

#### 怎查看binlog

binlog本身是一类二进制文件.二进制文件更省空间, 写入速度更快, 是无法直接打开来查看的.

因此mysql提供了命令mysqlbinlog进行查看.

* 一般的statement格式的二进制文件, 用下面命令就可以

    ```
    mysqlbinlog mysql-bin.000001
    ```

* 如果是row格式, 加上-v或者-vv参数就行, 如

    ```
    mysqlbinlog -vv mysql-bin.000001
    ```

#### 怎么删binlog

删binlog的方法很多, 有三种是常见的

* 使用`reset master`,该命令将会删除所有日志, 并让日志文件重新从000001开始.

* 使用命令

    ```
    PURGE { BINARY | MASTER } LOGS { TO 'log_name' | BEFORE datetime_expr }
    ```

    例如

    ```
    purge master logs to "binlog_name.00000X" 
    ```

    将会清空00000X之前的所有日志文件

* 使用`expire_logs_days=N`选项指定过了多少天日志自动过期清空.

#### binlog常见参数

常见参数, 列举如下, 有个印象就好.

| 参数名                                       | 含义                                           |
| -------------------------------------------- | ---------------------------------------------- |
| log_bin = {on \| off\| base_name}            | 指定是否启用记录二进制日志或者指定一个日志路径 |
| Sql_log_bin = {on \| off}                    | 指定是否启用记录二进制日志                     |
| expire_logs_days                             | 指定自动删除二进制日志的时间, 即日志过期时间   |
| log_bin_index                                | 指定mysql-bin.index文件的路径                  |
| binlong_format = {mixed \| row \| statement} | 指定二进制日志基于什么模式记录                 |
| max_binlog_size                              | 指定二进制日志文件最大值                       |
| binlog_cache_size                            | 指定事物日志缓存区大小                         |
| max_binlog_cache_size                        | 指定二进制日志缓存最大大小                     |
| sync_binlog = {0 \| n}                       | 指定写缓冲多少次, 刷一次盘                     |

### 开源工具监听 binlog

```xml
<!-- binlog 监听与解析: https://github.com/shyiko/mysql-binlog-connector-java -->
<dependency>
    <groupId>com.github.shyiko</groupId>
    <artifactId>mysql-binlog-connector-java</artifactId>
    <version>0.13.0</version>
</dependency>
```

```java
public class BinlogServiceTest {
    public static void main(String[] args) throws IOException {
        BinaryLogClient client = new BinaryLogClient("127.0.0.1", 3306, "root", "miaoqi");
        // client.setBinlogFilename();
        // client.setBinlogPosition();
        client.registerEventListener(event -> {
            EventData data = event.getData();
            if (data instanceof UpdateRowsEventData) {
                // update ad_unit_keyword set keyword = '奔驰' where keyword = '标志';
                System.out.println("Update---------------");
                System.out.println(data.toString());
            } else if (data instanceof WriteRowsEventData) {
                // insert into `ad_unit_keyword`(`unit_id`, `keyword`) values(10, '标志');
                System.out.println("Write----------------");
                System.out.println(data.toString());
            } else if (data instanceof DeleteRowsEventData) {
                System.out.println("Delete---------------");
                System.out.println(data.toString());
            }
        });
        client.connect();
    }
}
```

**binlog 文件会监听数据库中所有的变化, 所以我们可以自定义一份模板文件, 指定我们想要监听的内容**

```json
{
  "database": "advertisement",
  "tableList": [
    {
      "tableName": "ad_plan",
      "level": 2,
      "insert": [
        {"column": "id"},
        {"column": "user_id"},
        {"column": "plan_status"},
        {"column": "start_date"},
        {"column": "end_date"}
      ],
      "update": [
        {"column": "id"},
        {"column": "user_id"},
        {"column": "plan_status"},
        {"column": "start_date"},
        {"column": "end_date"}
      ],
      "delete": [
        {"column": "id"}
      ]
    },
    {
      "tableName": "ad_unit",
      "level": 3,
      "insert": [
        {"column": "id"},
        {"column": "unit_status"},
        {"column": "position_type"},
        {"column": "plan_id"}
      ],
      "update": [
        {"column": "id"},
        {"column": "unit_status"},
        {"column": "position_type"},
        {"column": "plan_id"}
      ],
      "delete": [
        {"column": "id"}
      ]
    },
    {
      "tableName": "ad_creative",
      "level": 2,
      "insert": [
        {"column": "id"},
        {"column": "type"},
        {"column": "material_type"},
        {"column": "height"},
        {"column": "width"},
        {"column": "audit_status"},
        {"column": "url"}
      ],
      "update": [
        {"column": "id"},
        {"column": "type"},
        {"column": "material_type"},
        {"column": "height"},
        {"column": "width"},
        {"column": "audit_status"},
        {"column": "url"}
      ],
      "delete": [
        {"column": "id"}
      ]
    },
    {
      "tableName": "creative_unit",
      "level": 3,
      "insert": [
        {"column": "creative_id"},
        {"column": "unit_id"}
      ],
      "update": [
      ],
      "delete": [
        {"column": "creative_id"},
        {"column": "unit_id"}
      ]
    },
    {
      "tableName": "ad_unit_district",
      "level": 4,
      "insert": [
        {"column": "unit_id"},
        {"column": "province"},
        {"column": "city"}
      ],
      "update": [
      ],
      "delete": [
        {"column": "unit_id"},
        {"column": "province"},
        {"column": "city"}
      ]
    },
    {
      "tableName": "ad_unit_it",
      "level": 4,
      "insert": [
        {"column": "unit_id"},
        {"column": "it_tag"}
      ],
      "update": [
      ],
      "delete": [
        {"column": "unit_id"},
        {"column": "it_tag"}
      ]
    },
    {
      "tableName": "ad_unit_keyword",
      "level": 4,
      "insert": [
        {"column": "unit_id"},
        {"column": "keyword"}
      ],
      "update": [
      ],
      "delete": [
        {"column": "unit_id"},
        {"column": "keyword"}
      ]
    }
  ]
}
```

**查看表信息**

```sql
select table_schema, table_name, column_name, ordinal_position from information_schema.columns where table_schema = 'advertisement' and table_name = 'ad_unit_keyword';
```





## MyISAM 和 InnoDB

### 区别

1.  InnoDB 支持事务, MyISAM 不支持事务.这是 MySQL 将默认存储引擎从 MyISAM 换到 InnoDB 的重要原因.
2.  InnoDB 支持外键, MyISAM 不支持外键.对一个包含外键的 InnoDB 表转换为 MyISAM 会失败.
3.  InnoDB 是聚集索引, MyISAM 是非聚集索引.聚集索引的文件放在主键索引的叶子节点上, 所以 InnoDB 必须要有主键, 通过主键索引效率很高.MyISAM 是非聚集索引, 数据文件是分离的, 索引保存的是数据文件的指针.主键索引和辅助索引是独立的.
4.  InnoDB 不保存表的具体行数.执行 `SELECT COUNT(*) FROM table` 时需要全表扫描.MyISAM 用一个变量保存了整个表的行数, 因此统计全表行数速度很快.
5.  InnoDB 最小的锁粒度是行锁, MyISAM 最小的锁粒度是表锁.
6.  InnoDB 支持 MVCC, MyISAM 不支持.
7.  InnoDB 5.6 之前不支持全文索引(5.6及之后支持), MyISAM支持.

### 选择

-   是否需要支持事务.如果要支持事务, 选择 InnoDB
-   如果绝大多数是读查询操作, 选择 MyISAM;如果读写均很频繁, 则选择 InnoDB
-   系统崩溃后, MyISAM 恢复更为困难, 如果不能接受, 则选择 InnoDB



| 对比项 | MyISAM                                                | InnoDB                                               |
| ------ | ----------------------------------------------------- | ---------------------------------------------------- |
| 主外键 | 不支持                                                | 支持                                                 |
| 事物   | 不支持                                                | 支持                                                 |
| 行表锁 | 表锁, 即使操作一条记录也会锁住整个表,不适合高并发操作 | 行锁,操作时只锁某一行,不对其他行有影响,适合高并发    |
| 缓存   | 只缓存索引, 不缓存真实数据                            | 不仅缓存索引还缓存真实数据,对内存要求高,内存决定性能 |
| 表空间 | 小                                                    | 大                                                   |
| 关注点 | 性能                                                  | 事务                                                 |

## InnoDB 引擎的行锁和表锁

InnoDB 与 MyISAM 的最大不同有两点: 一是支持事务(TRANSACTION); 二是采用了行级锁. 行级锁与表级锁本来就有许多不同之处, 另外, 事务的引入也带来了一些新问题.下面我们先介绍一点背景知识, 然后详细讨论InnoDB的锁问题.

**在 mysql 的 InnoDB 引擎支持行锁, 与 Oracle 不同, mysql 的行锁是通过索引加载的, 即是行锁是加在索引响应的行上的, 要是对应的SQL语句没有走索引, 则会全表扫描, 行锁则无法实现, 取而代之的是表锁.**

**表锁**: 不会出现死锁, 发生锁冲突几率高, 并发低.

**行锁**: 会出现死锁, 发生锁冲突几率低, 并发高.

**锁冲突**: 例如说事务 A 将某几行上锁后, 事务 B 又对其上锁, 锁不能共存否则会出现锁冲突.**(但是共享锁可以共存, 共享锁和排它锁不能共存, 排它锁和排他锁也不可以)**

**死锁**: 例如说两个事务, 事务 A 锁住了 1~5 行, 同时事务 B 锁住了 6~10 行, 此时事务 A 请求锁住 6~10 行, 就会阻塞直到事务 B 释放 6~10 行的锁, 而随后事务 B 又请求锁住 1~5 行, 事务 B 也阻塞直到事务 A 释放 1~5 行的锁. 死锁发生时, 会产生 Deadlock 错误.

**锁是对表操作的, 所以自然锁住全表的表锁就不会出现死锁.**

### 行锁

优势: 锁粒度小, 发生锁冲突的概率低;处理并发的能力强

劣势: 开销大;加锁慢;会出现死锁

加锁方式: 自动加锁.查询操作不加任何锁;更新操作会自动给涉及的记录加排他锁.

显式加锁: 

*   共享锁 select * from 【tablename】 where …… lock in share more;

*   排他锁 select * from 【tablename】 where …… for update;

行锁优化: 

*   尽可能让所有数据检索都通过索引来完成, 避免无索引或索引失效导致行锁升级为表锁.

*   尽可能避免间隙锁带来的性能下降, 减少或使用合理的检索范围.

*   尽可能减少事务的粒度, 比如控制事务大小, 从而减少锁定资源量和时间长度, 从而减少锁的竞争, 提高性能.

*   尽可能使用低级别的事务隔离级别, 隔离级别越高, 并发的处理能力越低.

#### 行锁的类型

行锁分 共享锁 和 排它锁.

**共享锁又称**: 读锁.当一个事务对某几行上读锁时, 允许其他事务对这几行进行读操作, 但不允许其进行写操作, 也不允许其他事务给这几行上排它锁, 但允许上读锁.

**排它锁又称**: 写锁.当一个事务对某几个上写锁时, 不允许其他事务写, 但允许读.更不允许其他事务给这几行上任何锁.包括写锁.

**上共享锁的写法**: lock in share mode

```mysql
select math from zje where math > 60 lock in share mode;
```

**上排它锁的写法**: for update

```mysql
select math from zje where math > 60 for update;
```

#### **行锁的实现**

1.  行锁必须有索引才能实现, 否则会自动锁全表, 那么就不是行锁了.

2.  必须要有事务, 这样才是行锁

3.  两个事务不能锁同一个索引, 例如:

    ```mysql
    事务A先执行:
    select math from zje where math > 60 for update;
     
    事务B再执行:
    select math from zje where math < 60 for update;
    
    这样的话, 事务 B 是会阻塞的.如果事务 B 把 math索引换成其他索引就不会阻塞
    ```

4.  insert, delete,  update 在事务中都会自动默认加上排它锁.

    行级锁定不是 MySQL 自己实现的锁定方式, 而是由其他存储引擎自己所实现的, 如广为大家所知的 InnoDB 存储引擎, 以及 MySQL 的分布式存储引擎NDBCluster 等都是实现了行级锁定.考虑到行级锁定君由各个存储引擎自行实现, 而且具体实现也各有差别, 而 InnoDB 是目前事务型存储引擎中使用最为广泛的存储引擎, 所以这里我们就主要分析一下 InnoDB 的锁定特性.

    InnoDB 锁定模式及实现机制
    总的来说, InnoDB 的锁定机制和 Oracle 数据库有不少相似之处.InnoDB 的行级锁定同样分为两种类型, 共享锁和排他锁, 而在锁定机制的实现过程中为了让行级锁定和表级锁定共存, InnoDB 也同样使用了意向锁(表级锁定)的概念, 也就有了意向共享锁和意向排他锁这两种.
    当一个事务需要给自己需要的某个资源加锁的时候, 如果遇到一个共享锁正锁定着自己需要的资源的时候, 自己可以再加一个共享锁, 不过不能加排他锁.但是, 如果遇到自己需要锁定的资源已经被一个排他锁占有之后, 则只能等待该锁定释放资源之后自己才能获取锁定资源并添加自己的锁定.而意向锁的作用就是当一个事务在需要获取资源锁定的时候, 如果遇到自己需要的资源已经被排他锁占用的时候, 该事务可以需要锁定行的表上面添加一个合适的意向锁.如果自己需要一个共享锁, 那么就在表上面添加一个意向共享锁.而如果自己需要的是某行(或者某些行)上面添加一个排他锁的话, 则先在表上面添加一个意向排他锁.意向共享锁可以同时并存多个, 但是意向排他锁同时只能有一个存在.所以, 可以说 InnoDB 的锁定模式实际上可以分为四种:共享锁(S), 排他锁(X), 意向共享锁(IS)和意向排他锁(IX), 我们可以通过以下表格来总结上面这四种所的共存逻辑关系:

|                    | 共享锁(S) | 排它锁(X) | 意向共享锁(IS) | 意向排它锁(IX) |
| ------------------ | --------- | --------- | -------------- | -------------- |
| **共享锁(S)**      | 兼容      | 冲突      | 兼容           | 冲突           |
| **排它锁(X)**      | 冲突      | 冲突      | 冲突           | 冲突           |
| **意向共享锁(IS)** | 兼容      | 冲突      | 兼容           | 兼容           |
| **意向排它锁(IX)** | 冲突      | 冲突      | 兼容           | 兼容           |

如果一个事务请求的锁模式与当前的锁兼容, InnoDB就将请求的锁授予该事务;反之, 如果两者不兼容, 该事务就要等待锁释放.
**意向锁是InnoDB自动加的, 不需用户干预.对于UPDATE, DELETE和INSERT语句, InnoDB会自动给涉及数据集加排他锁(X);对于普通SELECT语句, InnoDB不会加任何锁;**

#### 查看锁竞争情况

使用命令 `show status like 'innodb_row_lock%';` 查看锁竞争情况

```mysql
show status like 'innodb_row_lock%';

Innodb_row_lock_current_waits	0
Innodb_row_lock_time	0
Innodb_row_lock_time_avg	0
Innodb_row_lock_time_max	0
Innodb_row_lock_waits	0
```

**如果发现锁争用比较严重, 如 InnoDB_row_lock_waits 和 InnoDB_row_lock_time_avg 的值比较高, 还可以通过设置 InnoDB Monitors 来进一步观察发生锁冲突的表, 数据行等, 并分析锁争用的原因.**



### 表锁

优势: 开销小;加锁快;无死锁

劣势: 锁粒度大, 发生锁冲突的概率高;处理并发的能力弱

加锁方式: 自动加锁.查询操作会自动给涉及的所有表加读锁;更新操作会自动给涉及的表加写锁.

显式加锁: 

-   共享读锁: lock table 【tablename】 read;
-   独占写锁: lock table 【tablename】 write;
-   批量解锁: unlock tables;

表锁中: 读锁会阻塞写, 不会阻塞读;而写锁则会把读写都阻塞.

### 行锁变表锁

1.  当索引生效时使用行锁;没有索引或索引失效时使用表锁

2.  当生效的索引是唯一索引, 则使用行锁;当生效的索引不是唯一索引, 则使用表锁.（用索引字段做为条件进行修改时,  是否表锁的取决于这个索引字段能否确定记录唯一, 当索引值对应记录不唯一, 会进行锁表, 相反则行锁.）

3.  当表的大部分数据需要修改时, 行锁会升级为表锁

4.  多表复杂关联查询时, 行锁会升级为表锁.因为复杂的关联查询, 事务涉及多个表, 很可能引起死锁, 造成大量事务回滚.这种情况若能一次性锁定事务涉及的表, 从而可以避免死锁, 减少数据库因事务回滚带来的开销.

### 锁定义

#### 间隙锁

定义: 当使用范围条件检索数据并请求共享或排他锁时, InnoDB 会给符合条件的已有数据记录的索引项加锁;对于键值在条件范围内但并不存在的记录, 叫做间隙(GAP).InnoDB 也会对这个间隙加锁, 这种锁机制就是所谓的间隙锁(Next-Key锁).

危害: 若执行的条件范围过大, 则 InnoDB 会将整个范围内所有的索引键值全部锁定, 很容易对性能造成影响.

#### 排他锁

定义: 排他锁也称为写锁, 独占锁, 当前写操作没有完成前, 会阻断其他写锁和读锁.

排他锁是行锁

#### 共享锁

定义: 共享锁也称为读锁, 多用于判断数据是否存在.多个读操作可以同时进行而不会互相影响, 但会阻塞对同一表的写操作, 只有当读锁释放后, 才能执行其他进程的写操作.如果事务对读锁进行修改操作, 很可能会造成死锁.

共享锁是行锁

#### 意向锁

意向锁是表锁

意向共享锁: 事务在请求共享锁时, 需要先获取意向共享锁

意向排他锁: 事务在请求排他锁时, 需要先获取意向排他锁

为什么意向锁是表锁: 当需要一个排他锁时, 需要根据意向锁判断表中有没有数据行被锁定: 

-   如果意向锁是行锁, 则需要遍历每一行去确认
-   如果意向锁是表锁, 则只需要一次即可知道有没有数据行被锁定, 提升性能











### 间隙锁(Next-Key锁)

当我们用范围条件而不是相等条件检索数据, 并请求共享或排他锁时, InnoDB会给符合条件的已有数据的索引项加锁;对于键值在条件范围内但并不存在的记录, 叫做“间隙(GAP)”, InnoDB也会对这个“间隙”加锁, 这种锁机制就是间隙锁(Next-Key锁).

举例来说, 假如emp表中只有101条记录, 其empid的值分别是1,2,...,100,101, 下面的SQL:

```mysql
SELECT * FROM emp WHERE empid > 100 FOR UPDATE
```

是一个范围条件的检索, InnoDB不仅会对符合条件的empid值为101的记录加锁, 也会对empid大于101(这些记录并不存在)的“间隙”加锁.

InnoDB使用间隙锁的目的, 一方面是为了防止幻读, 以满足相关隔离级别的要求, 对于上面的例子, 要是不使用间隙锁, 如果其他事务插入了empid大于100的任何记录, 那么本事务如果再次执行上述语句, 就会发生幻读;另一方面, 是为了满足其恢复和复制的需要.有关其恢复和复制对机制的影响, 以及不同隔离级别下InnoDB使用间隙锁的情况.

很显然, 在使用范围条件检索并锁定记录时, InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入, 这往往会造成严重的锁等待.因此, 在实际开发中, 尤其是并发插入比较多的应用, 我们要尽量优化业务逻辑, 尽量使用相等条件来访问更新数据, 避免使用范围条件.











































## MySQL 遇到的问题

### MySQL索引与字段的关系

在做Quartz的练习时, 需要创建Quartz需要用到的表, 但是在执行SQL的过程中报出如下错误

**Error : Specified key was too long; max key length is 767 bytes**

这句话的意思是索引的最大长度为767字节(byte), 而我得索引列长度超过了767字节, 所以报出上述的错误, 接下来我们具体分析一下这个错误

首先看一下建表语句

```mysql
CREATE TABLE QRTZ_JOB_DETAILS(
    SCHED_NAME VARCHAR(120) NOT NULL,
    JOB_NAME VARCHAR(200) NOT NULL,
    JOB_GROUP VARCHAR(200) NOT NULL,
    DESCRIPTION VARCHAR(250) NULL,
    JOB_CLASS_NAME VARCHAR(250) NOT NULL,
    IS_DURABLE VARCHAR(1) NOT NULL,
    IS_NONCONCURRENT VARCHAR(1) NOT NULL,
    IS_UPDATE_DATA VARCHAR(1) NOT NULL,
    REQUESTS_RECOVERY VARCHAR(1) NOT NULL,
    JOB_DATA BLOB NULL,
	PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)
)ENGINE=InnoDB;
```

我们可以看到这个建表语句创建了一个复合索引**PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)**, 我创建数据库的时候使用的是utf8mb4字符集, **一个字符会占用4个字节**, 而3个字段的长度是120 + 200 + 200 = 520, 复合索引的长度是2080字节, 单个索引的长度分别是480, 800, 800字节

**经过查阅得知, MySQL在创建单个字段索引时, 主要的限制是字段长度, 如果单个字段长度不超过767字节, 不会出现问题但复合索引的情况与单字段索引有所不同. 复合索引中除了单字段长度不能超过767字节外, 索引中所有字段长度的总合不能超过3072字节. **

#### 测试单列索引的情况

首先修改创建表的语句如下

```mysql
CREATE TABLE QRTZ_JOB_DETAILS(
    SCHED_NAME VARCHAR(120) NOT NULL,
    JOB_NAME VARCHAR(200) NOT NULL,
    JOB_GROUP VARCHAR(200) NOT NULL,
    DESCRIPTION VARCHAR(250) NULL,
    JOB_CLASS_NAME VARCHAR(250) NOT NULL,
    IS_DURABLE VARCHAR(1) NOT NULL,
    IS_NONCONCURRENT VARCHAR(1) NOT NULL,
    IS_UPDATE_DATA VARCHAR(1) NOT NULL,
    REQUESTS_RECOVERY VARCHAR(1) NOT NULL,
    JOB_DATA BLOB NULL
)ENGINE=InnoDB;
```

**首先我们为 SCHED_NAME 添加主键索引**

```mysql
mysql [quartz_db]> ALTER TABLE `QRTZ_JOB_DETAILS` ADD PRIMARY KEY `idx_details_sn` (SCHED_NAME) COMMENT '单一varchar字段的索引, 不指定索引前缀的长度';
Query OK, 0 rows affected (0.009 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

可以看到语句执行成功了, 因为SCHED_NAME的长度是120个字符, 1个字符占用4字节, 4 * 120 = 480 < 767可以创建成功

**接下来我们为 JOB_NAME 添加主键索引**

```mysql
mysql [quartz_db]> ALTER TABLE `QRTZ_JOB_DETAILS` ADD PRIMARY KEY `idx_details_jn` (JOB_NAME) COMMENT '单一varchar字段的索引, 不指定索引前缀的长度';
ERROR 1071 (42000): Specified key was too long; max key length is 767 bytes
```

可以看到语句并没有执行成功, 而是说索引列太长了, 不能超过 767 个字节, 因为 JOB_NAME 字段时200个字符, 1 个字符占用4字节, 4 * 200 = 800, 所以创建失败

**接下来我们为JOB_NAME添加前缀主键索引**

```mysql
mysql [quartz_db]> ALTER TABLE `QRTZ_JOB_DETAILS` ADD PRIMARY KEY `pre_idx_details_jn` (JOB_NAME(190)) COMMENT '单一varchar字段的索引, 指定索引前缀的长度为190个字符';
Query OK, 0 rows affected (0.010 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

这次我们依旧是使用 JOB_NAME 字段创建索引, **但是在创建索引的时候指定了索引前缀**, 即只使用 JOB_NAME 列的前190个字符进行索引, 190 * 4 = 760 < 767, 所以创建成功

#### 测试复合索引的情况

为了方便测试, 我们在添加几个字段

```mysql
ALTER TABLE QRTZ_JOB_DETAILS ADD COLUMN t1 VARCHAR(150);
ALTER TABLE QRTZ_JOB_DETAILS ADD COLUMN t2 VARCHAR(150);
ALTER TABLE QRTZ_JOB_DETAILS ADD COLUMN t3 VARCHAR(150);
ALTER TABLE QRTZ_JOB_DETAILS ADD COLUMN t4 VARCHAR(150);
ALTER TABLE QRTZ_JOB_DETAILS ADD COLUMN t5 VARCHAR(150);
```

**首先我们为SCHED_NAME, t1, t2, t3创建复合主键索引**

```mysql
mysql [quartz_db]> ALTER TABLE QRTZ_JOB_DETAILS ADD PRIMARY KEY idx_details_snt1t2t3(SCHED_NAME, t1, t2, t3);
Query OK, 0 rows affected (0.026 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

可以看到语句执行成功了, 因为SCHED_NAME的长度是120个字符, 1个字符占用4字节, 4 * 120 = 480 < 767可以创建成功, 4列的字符数分别是, 120, 150, 150, 150, 均满足单列字节不超过767的限制, 总的字节数是 (120 + 150 + 150 + 150) * 4 = 2280 < 3072, 也满足总长度不超过3072字节

**接下来我们为JOB_NAME, t1, t2, t3创建复合主键索引**

```mysql
mysql [quartz_db]> ALTER TABLE QRTZ_JOB_DETAILS ADD PRIMARY KEY idx_details_snt1t2t3(JOB_NAME, t1, t2, t3);
ERROR 1071 (42000): Specified key was too long; max key length is 767 bytes
```

这次添加失败了, 因为JOB_NAME是200个字符, 200 * 4 = 800 > 767, 复合索引中的某一列的字节数超过限制, 索引创建失败

接下来我们为SCHED_NAME, t1, t2, t3, t4, t5创建复合主键索引

```mysql
mysql [quartz_db]> ALTER TABLE QRTZ_JOB_DETAILS ADD PRIMARY KEY idx_details_snt1t2t3(JOB_NAME, t1, t2, t3, t4, t5);
ERROR 1071 (42000): Specified key was too long; max key length is 767 bytes
```

显然这次也会失败了, 虽然SCHED_NAME, t1, t2, t3, t4, t5的单列长度均没有超出767的长度限制, 但是总的长度 120 + 150 + 150 + 150 + 150 + 150 = 870 * 4 = 3480 > 3072, 所以超出了总长度的限制

#### 总结

通过上面一系列的试验, 我们明确知道MySQL创建索引时, 单字段索引的字段长度不能超过767字节, 超过时需要指定索引前缀;创建复合索引时, 单字段长度不能超过767字节, 且索引中所有字段的总长度不能超过3072字节, **违反这些约束时需要删减字段或是为长度较大的字段指定索引前缀或者修改字符集**. 在MySQL 5.6.28中, 字符类型的长度指的是字符数, 而不是字节数, 每个字符占用的字节数和使用的字符集相关



### MySQL存储emoji表情

在存储用户昵称时遇到如下错误

```mysql
java.sql.SQLException: Incorrect string value: ‘\xF0\x9F\x92\x94’ for colum n ‘name’ at row 1 
```

使用mysql数据库的时候, 如果字符集是UTF-8并且在java服务器上, 当存储emoji表情的时候, 会抛出以上异常(比如微信开发获取用户昵称, 有的用户的昵称用的是emoji的图像)

这是由于mysql字符集不支持的异常导致的, **在mysql中的utf-8字符集最多只支持3个字节的存储, 如果一个字符的utf8编码占用4个字节(最常见的就是ios中的emoji表情字符), 那么在写入数据库时就会报错**Ï

mysql从5.5.3版本开始, 才支持4字节的utf8编码, 编码名称为utf8mb4(mb4的意思是max bytes 4), 这种编码方式最多用4个字节存储一个字符. 

因此, 要解决上述异常的发生, 需要使用utf8mb4编码. 

解决数据库编码后, 还需要解决客户端Connection连接对象使用的编码问题. 

#### 解决方式(三种)

从数据库层面进行解决(mysql支持utf8mb4的版本是5.5.3+, 必须升级到较新版本)

1. 修改database, table, column字符集

    ```mysql
    ALTER DATABASE database_name CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci; 
    ALTER TABLE table_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; 
    ALTER TABLE table_name CHANGE column_name VARCHAR(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
    ```

1. 修改mysql配置文件my.cnf

    ```mysql
    [client] 
    default-character-set = utf8mb4 
    [mysql] 
    default-character-set = utf8mb4 
    [mysqld] 
    character-set-client-handshake = FALSE 
    character-set-server = utf8mb4 
    collation-server = utf8mb4_unicode_ci 
    init_connect=’SET NAMES utf8mb4’
    ```

1. 用的是java服务器, 升级或者确保mysql connection版本高于5.1.13否则仍然不能试用utf8mb4 

1. 服务器端的db配置文件

    ```properties
    jdbc.driverClassName=com.mysql.jdbc.Driver 
    jdbc.url=jdbc:mysql://localhost:3306/database?useUnicode=true&characterEncoding=utf8&autoReconnect=true&rewriteBatchedStatements=TRUE 
    jdbc.username=root 
    jdbc.password=password
    ```

    如果升级了mysql-connector, 其中的characterEncoding=utf8可以自动被识别为utf8mb4(兼容原来的utf8), 而 autoReconnection(当数据库连接异常中断时, 是否自动重新连接？默认为false)强烈建议配上, 忽略这个属性, 可能导致缓存缘故, 没有读取到DB最新的配置, 导致一直无法试用utf8mb4字符集;

修改数据库连接池配置

- 如果项目中使用了DataSource数据源, 只需要对数据源进行相关配置即可, 这里以apache的DBCP数据源为例讲解, 在spring框架下配置如下:

    ```xml
    <!-- 数据源 -->
    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource">
    	<property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
    	<property name="url" value="jdbc:mysql://${${data-source.prefix}.data-source.host-name}:3306/${${data-source.prefix}.data-source.db-name}?characterEncoding=utf8&amp;autoReconnect=true&amp;failOverReadOnly=false&amp;maxReconnects=10&amp;allowMultiQueries=true" />
    	<property name="username" value="${${data-source.prefix}.data-source.username}" />
    	<property name="password" value="${${data-source.prefix}.data-source.password}" />
    	<property name="maxActive" value="150" />
    	<property name="maxIdle" value="2" />
    	<property name="testOnBorrow" value="true" />
    	<property name="testOnReturn" value="true" />
    	<property name="testWhileIdle" value="true" />
    	<property name="validationQuery" value="select 1" />
    	<!-- 此配置用于在创建Connection对象时执行指定的初始化sql -->
    	<property name="connectionInitSqls">
    		<list>
    			<value>set names 'utf8mb4'</value>
    		</list>
    	</property>
    </bean>
    ```

- 在springcloud项目中进行配置

    ```yaml
    spring:
      datasource:
        connection-init-sqls: set names 'utf8mb4'
    ```

- 该设置的解释引用自mysql参考手册:

    ```mysql
    SET NAMES 'charset_name'
    
    SET NAMES显示客户端发送的SQL语句中使用什么字符集. 
    
    因此, SET NAMES 'utf8mb4'语句告诉服务器:“将来从这个客户端传来的信息采用字符集utf8mb4”. 它还为服务器发送回客户端的结果指定了字符集. (例如, 如果你使用一个SELECT语句, 它表示列值使用了什么字符集. )
    
    SET NAMES 'x'语句与这三个语句等价:
    
    mysql> SET character_set_client = x;
    
    mysql> SET character_set_results = x;
    
    mysql> SET character_set_connection = x;
    ```

从应用层的方面进行解决 

1. 在获得数据之后往数据库存之前先进行编码:

    ```java
    URLEncoder.encode(nickName, “utf-8”);
    ```

1. 当从数据库中取出准备显示的时候进行解码, 

    ```java
    URLDecoder.decode(nickname, “utf-8”); 
    ```

从应用层进行解决的时候建议不要在对象getter, setter方法中直接编码, 因为放入对象的时候setter方法将nickname进行编码, 当插入数据库的时候相当于从对象中调用getter方法将你参考取出这就将之前setter编码过的nickname又重新解码了, 等于未对Nickname进行任何操作. 依然会出现以上问题. 



### Mysql中自增字段(AUTO_INCREMENT)的一些常识

在系统开发过程中, 我们经常要用到唯一编号. 使用过mysql的人都应该知道, mysql有一个定义列为自增的属性:AUTO_INCREMENT. 

指定了AUTO_INCREMENT的列必须要建索引, 不然会报错, 索引可以为主键索引, 当然也可以为非主键索引. **(不一定要做主键)**

```mysql
mysql> create table user (id int auto_increment);
ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key
```

下面的定义把user表的主键定义为了name, 而非自增的id字段

```mysql
mysql> create table user (id int auto_increment,name varchar(20) primary key,key(id)); 
Query OK, 0 rows affected (0.01 sec)
```

#### 指定了auto_increment的列

- 如果把一个NULL插入到一个AUTO_INCREMENT数据列里去, MySQL将自动生成下一个序列编号. 编号从1开始, 并1为基数递增. 

- 当插入记录时, 没有为AUTO_INCREMENT明确指定值, 则等同插入NULL值. 

    ```mysql
    mysql> insert into user (id,name) values (null,'test');
    Query OK, 1 row affected (0.00 sec)
        
    mysql> select * from user;
    +----+------+
    | id | name |
    +----+------+
    |  1 | test |
    +----+------+
    1 row in set (0.00 sec)
    ```

    上面语句等同于下面语句:

    ```mysql
    insert into user (name) values ('test');
    ```

- 当插入记录时, 如果为AUTO_INCREMENT字段明确指定了一个数值, 则会出现两种情况:

    - **如果插入的值与已有的编号重复, 则会出现出 错信息, 因为AUTO_INCREMENT数据列的值必须是唯一的**
    - **如果插入的值大于已编号的值, 则会把该插入到数据列中, 并使在下一个编号将从这个新值开始递增. **

    **总结一句话就是auto_increment会从最后一次insert语句开始递增**

    - **如果在小于AUTO_INCREMENT字段上插入一个小于AUTO_INCREMENT的值, 比如当前AUTO_INCREMENT是50, 我插入一个47的值, 那再往后插入的值还是从50开始的, 并不会受之前的插入操作影响**

- 当更新AUTO_INCREMENT字段时, 根据存储引擎的不同, 会出现两种情况:

    - **对于MyISAM表, 如果用UPDATE命令更新自增列, 如果列值与已有的值重复, 则会出错. 如果大于已有值, 则下一个编号从该值开始递增****
    - **对于Innodb表, update auto_increment字段, 可能会导致发生报错, 如果将一个id更新为12, 当前AUTO_INCREMEN是10并不会发生变化, Innodb表继续插入记录, 当主键插入到12时会发生报错, 但只会报错一次, 跳过12之后会正常插入**

- 被delete语句删除的id值, 除非sql中将id重新插入, 否则前面空余的id不会复用. 

    - **当前AUTO_INCREMENT=30, delete掉id为10的记录, 下一次插入会是31, 并不会复用空余的10**

- truncate table user 该语句会引起auto_increment的变化, 从头开始. 

- 修改AUTO_INCREMENT字段的起始值

    - **可用alter table table_name AUTO_INCREMENT=n命令来重设自增的起始值. **
    - **但是如果设置的n比目前的数值小的话, 执行的sql不会报错, 但是不会生效! MyISAM和Innodb均是如此. **

### MySQL插入语句 insert ignore, insert 和 replace 区别

我们先把结论贴出来

| 指令          | 已存在       | 不存在 | 不存在                                                  |
| ------------- | ------------ | ------ | ------------------------------------------------------- |
| insert        | 报错         | 插入   | insert into names(name, age) values(“小明”, 23);        |
| insert ignore | 忽略         | 插入   | insert ignore into names(name, age) values(“小明”, 24); |
| replace       | 先删除再插入 | 插入   | replace into names(name, age) values(“小明”, 25);       |

表要求: **有PrimaryKey, 或者unique索引** 

结果: **表id都会自增**

#### 创建测试环境

创建表

```mysql
CREATE TABLE names(
    id INT(10) PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) UNIQUE,
    age INT(10)
)
```

插入数据

```mysql
mysql> insert into names(name, age) values("小明", 24);
mysql> insert into names(name, age) values("大红", 24);
mysql> insert into names(name, age) values("大壮", 24);
mysql> insert into names(name, age) values("秀英", 24);

mysql> select * from names;
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  1 | 小明   |   24 |
|  2 | 大红   |   24 |
|  3 | 大壮   |   24 |
|  4 | 秀英   |   24 |
+----+--------+------+
```

#### 测试 Insert

插入已存在, id会自增, 但是插入不成功, 会报错

```
mysql> insert into names(name, age) values("小明", 23);

ERROR 1062 (23000): Duplicate entry '小明' for key 'name'
```

提示我们插入失败, 因为'name'字段冲突了

#### 测试 replace

**已存在替换, 删除原来的记录, 添加新的记录**

```mysql
mysql> replace into names(name, age) values("小明", 23);
Query OK, 2 rows affected (0.00 sec)

mysql> select * from names;
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  2 | 大红   |   24 |
|  3 | 大壮   |   24 |
|  4 | 秀英   |   24 |
|  6 | 小明   |   23 |
+----+--------+------+
```

id为1的记录被删除了, 新增的记录id是6, name是小名, replace会先删除已经存在的记录, 在创建新的记录, 而id为6是之前insert时id会自增

**不存在替换, 添加新的记录**

```mysql
mysql> replace into names(name, age) values("大名", 23);
Query OK, 1 row affected (0.00 sec)

mysql> select * from names;
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  2 | 大红   |   24 |
|  3 | 大壮   |   24 |
|  4 | 秀英   |   24 |
|  6 | 小明   |   23 |
|  7 | 大名   |   23 |
+----+--------+------+
```

这次没有重复的记录, 直接添加id为7的记录

#### insert ignore

**插入已存在, 忽略新插入的记录, id会自增, 不会报错**

```mysql
mysql> insert ignore into names(name, age) values("大壮", 25);
Query OK, 0 rows affected, 1 warning (0.00 sec)
```

大壮是已经存在的记录, 但是并没有报错, 而是忽略这一条记录, 当我们进行批量插入的时候, 也可以使用insert ingore避免主键冲突对其他插入语句的影响

**插入不存在, 添加新的记录**

```mysql
mysql> insert ignore into names(name, age) values("壮壮", 25);
Query OK, 1 row affected (0.01 sec)

mysql> select * from  names;
+----+--------+------+
| id | name   | age  |
+----+--------+------+
|  2 | 大红   |   24 |
|  3 | 大壮   |   24 |
|  4 | 秀英   |   24 |
|  6 | 小明   |   23 |
|  7 | 大名   |   23 |
|  9 | 壮壮   |   25 |
+----+--------+------+
```

这次没有重复的记录, 壮壮可以直接插入进来, 并且id自增了



## 查询优化

### JOIN查询

SQL执行顺序:  

* 手写

    ```mysql
    select distinct <select_list>
    from <left_table> <join_type> join <right_table> on <join_condition>
    where <where_condition>
    group by <group_by_list>
    having <having_condition>
    order by <order_by_condition>
    limit <limit number>
    ```

* 机读

    ```mysql
    from <left_table> on <join_condition> <join_type> join <right_table>
    where <where_condition>
    group by <group_by_list>
    having <having_condition>
    select distinct <select_list>
    order by <order_by_condition>
    limit <limit_number>
    
    http://www.cnblogs.com/qanholas/archive/2010/10/24/1859924.html
    ```

* 练习

    ```mysql
    create table tbl_dept(
        id int(11) not null auto_increment,
        dept_name varchar(30) default null,
        ioc_add varchar(40) default null,
        primary key(id)
    )engine=innodb auto_increment=1 default charset=utf8;
    
    create table tbl_emp(
        id int(11) not null auto_increment,
        name varchar(20) default null,
        dept_id int(11) default null,
        primary key(id),
        key fk_dept_id(dept_id)
        #constraint fk_dept_id foreign key (dept_id) references tbl_dept(id)
    )engine=innodb auto_increment=1 default charset=utf8;
    
    insert into tbl_dept(dept_name,ioc_add) values('RD',11);
    insert into tbl_dept(dept_name,ioc_add) values('HR',12);
    insert into tbl_dept(dept_name,ioc_add) values('MK',13);
    insert into tbl_dept(dept_name,ioc_add) values('MIS',14);
    insert into tbl_dept(dept_name,ioc_add) values('FD',15);
    
    insert into tbl_emp(name,dept_id) values('z3',1);
    insert into tbl_emp(name,dept_id) values('z4',1);
    insert into tbl_emp(name,dept_id) values('z5',1);
    insert into tbl_emp(name,dept_id) values('w5',2);
    insert into tbl_emp(name,dept_id) values('w6',2);
    insert into tbl_emp(name,dept_id) values('s7',3);
    insert into tbl_emp(name,dept_id) values('s8',4);
    insert into tbl_emp(name,dept_id) values('s9',51);
    
    select * from tbl_dept, tbl_emp;
    select * from tbl_emp e inner join tbl_dept d on e.dept_id = d.id;
    select * from tbl_emp e, tbl_dept d on e.dept_id = d.id;
    select * from tbl_emp e left join tbl_dept d on e.dept_id = d.id;
    select * from tbl_emp e right join tbl_dept d on e.dept_id = d.id;
    select * from tbl_emp e left join tbl_dept d on e.dept_id = d.id where d.id is null;
    select * from tbl_emp e right join tbl_dept d on e.dept_id = d.id where e.dept_id is null;
    #select * from tbl_emp e full outer join tbl_dept d on e.dept_id = d.id; oracle
    select * from tbl_emp e left join tbl_dept d on e.dept_id = d.id union select * from tbl_emp e right join tbl_dept d on e.dept_id = d.id;
    select * from tbl_emp e left join tbl_dept d on e.dept_id = d.id where d.id is null union select * from tbl_emp e right join tbl_dept d on e.dept_id = d.id where e.dept_id is null;
    
    union,union all合并结果集
    union:去重,按照字段排序,效率低
    union all:不去重,不排序,效率高
    ```

### 性能分析

MySql Query Optimizer

* 通过计算分析系统中收集的统计信息, 为客户端提供请求的Query提高它认为最优的执行计划(不见得是DBA认为最优的)

* 当客户端向MySql请求一条Query, 命令解析器模块完成请求分类, 区别出是select并转发给mysql query optimizer, 首先会对整条Query进行优化,处理掉一些常量表达式的预算, 直接换算成常量值, 并对Query中的查询进行简化和转换, 如去掉一些无用或显而易见的条件, 结构调整,等, 然后分析Hint(如果有), 看Hint信息是否可以完全确定该Query的执行计划, 如果没有Hint或Hint信息不足以完全确定执行计划, 则会读取所涉及对象的统计信息, 根据Query进行写相应的计算分析, 最后得出执行计划.

MySql的常见瓶颈

* CPU: CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候

* IO: 磁盘I/O瓶颈发生装入数据远大于内存容量的时候
    服务器硬件性能: top, free, iostat和vmstat来查看系统性能

Explain

* 是什么: 使用explain关键字可以模拟优化器执行SQL查询语句, 从而知道MySql是如何处理你的SQL语句, 分析你的查询语句或是表结构的性能瓶颈.

* 干什么: 表的读取顺序, 数据读取操作的操作类型, 哪些索引可以使用, 哪些索引被实际使用, 表之间的引用, 每张表有多少行被优化器查询

* 怎么用: explain + sql语句

    id select_type table type possible_keys key key_len ref rows Extra

* 名词解释

    * id*: select查询的序列号, 包含一组数字, 表示查询中执行select子句或操作表的顺序

        * id相同, 执行顺序由上至下

        * id不同, 如果是子查询, id的序号会递增, id值越大优先级越高, 越先被执行

        * id相同不同,同时存在

    * select_type: 查询类型

        * SIMPLE: 简单的select查询, 查询中不包含子查询或union

        * PRIMARY: 查询中包含任何复杂的子部分, 最外层查询则被标记为

        * SUBQUERY: 子查询

        * DERIVED: 在from列表中包含的子查询被标记为derived, mysql会递归执行这些子查询, 把结果放在临时表

        * UNION: 若第二个select出现在union之后, 标记为union, 若union包含在from子句的子查询中, 外层select被标记为derived

        * UNION RESULT: 从union表获取结果的select

    * table: 显示这一行的数据是关于哪张表

    * type*: 显示查询使用了何种类型

        最好到最差

        system > const > eq_ref > ref > range > index > all

        system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_query > index_subquery > range > idnex > all

        一般来说,保证查询能到range级别,最好能到ref级别

        system: 表只有一行记录(等于系统表), 这是const类型的特例, 平时不会出现
        const: 表示通过索引一次就找到了, 用于比较primary key或者unique索引, 因为只匹配一行数据, 所以速度很快.(主键)

        eq_ref: 唯一索引扫描, 对于每个索引键, 表中只有一条记录与之匹配

        ref: 非唯一索引扫描, 返回匹配某个单独值的所有行本质上也是一种索引访问, 但是会匹配多个值

        rang: 只检索给定范围的行, 使用一个索引来选择行. key列显示使用了哪个索引
        index: full index scan, index与all的区别为indx类型只遍历索引树, 而all是遍历数据文件.

        all: 全数据文件扫描

        possible_keys: 显示可能应用在这张表的索引, 一个或多个, 查询涉及的字段上若存在索引, 则该索引将被列出, 但不一定被查询实际使用

    * key*: 实际使用的索引, 若为NULL, 则没有使用索引查询中若使用了覆盖索引, 则该索引只出现在key列表中覆盖索引: 查询列与复合索引的个数顺序一致, 则自动按照复合索引去查询

    * key_len: 表示索引中使用的字节数, 可通过该列计算查询中使用索引的长度, 在不损失精度的情况下, 长度越短越好,

    * key_len显示的值为索引字段的最大可能长度, 并非实际使用长度, 即key_len是根据表定义计算而得, 不是通过表内检索得出.

    * ref: 显示索引的哪一列被使用了, 如果可能的话, 是一个常数, 哪些列或常量被用于查找索引列上的值

    * rows*: 根据表统计信息及索引选用情况, 大致估算出找到所需的记录所需读取的行数

    * Extra*: 包含不适合在其他列显示但十分重要的信息
      
1. using filesort: 说明mysql会对数据使用一个外部的索引排序, 而不是按照表内的索引顺序进行读取, 称为"文件排序"
   
2. using temporary: 使用了临时表保存中间结果, mysql在对查询结果排序时使用临时表. 常见于排序order by和分组查询group by
   
3. using index: 表示相应的select操作使用了覆盖索引, 避免访问了表的数据行.
        
    如果同时出现using where 表明索引被用来执行索引键值的查找
        
    如果没有出现using where 表明索引用来读取数据而非执行查找操作
        
    覆盖索引: select的数据列只用从索引表就能够取得, 不用读取数据表.条件是查询列的顺序要和索引顺序相同
    
4. using where: 表明使用了where过滤
   
5. using join buffer: 使用了连接缓存
   
6. impossible where: where子句的值总是false, 不能用来获取任何元组
   
7. select table optimized away: 
   
8. distinct: 

### 索引优化

索引: 索引(index)是帮助mysql高效获取数据的数据结构,本质:数据结构

B树索引: 索引单独维护了一个索引文件, 索引文件使用二叉树结构, 指向对象的数据

优势: 

* 提高数据检索的效率, 降低数据库的IO    
* 降低数据排序成本, 降低了CPU消耗

劣势:         

* 实际上索引也是一张表, 保存了主键与索引字段, 并指向实体表记录, 所以索引列也是占空间的       
* 大大提高了查询速度, 会降低更新表的速度, 如对表insert, update和delete.      
* 索引只是提高效率的一个因素, 如果你的mysql有大数据的表, 就需要花时间研究建立最优秀的索引, 或优化

分类

* 单值索引: 即一个索引只包含单列, 一个表可以有多个单列索引    
* 唯一索引: 索引列的值必须唯一, 但允许有空值     
* 复合索引: 即一个索引包含多个列
          

语法

* 创建 

    ```mysql
    create [unique] index indexName on mytable(columnname(length));
    
    alter mytable add [unique] index [indexName] on (columnname(length));
    ```

* 删除

    ```mysql
    drop index [indexName] on mytable;
    ```

* 查看 

    ```mysql
    show index from table_name;
    
    alter table tbl_name add primary_key(column_list)	      该语句添加一个主键, 这意味着索引值必须唯一, 且不能为空
    alter table tbl_name add unique index index_name(column_list) 这条语句创建索引的值必须是唯一的, 但可以为NULL, NULL可能出现多次
    alter table tbl_name add idnex index_name(column_list) 添加普通索引, 索引值可以出现多次
    alter table tbl_name add fulltext index_name(column_list) 添加全文索引
    ```

* mysql索引结构:     

    * BTree索引 3层的b+树可以表示上百万条数据     
    * Hash索引     
    * full-text索引     
    * R-Tree索引

* 哪些情况建索引:

    * 主键自动建立唯一索引
    * 频繁作为查询条件的字段
    * 查询中与其他表关联的字段,外键关系建立索引
    * 频繁更新得字段不适合创建索引 - 更新时不单单更新了记录还会更新索引
    * where条件里用不到的字段不要创建索引
    * 单值索引和组合索引的选择?(高并发情况下倾向创建组合索引)
    * 查询中排序的字段, 排序字段若通过索引会大大提高查询速度
    * 查询中统计或者分组的字段

* 哪些情况不要建索引:

    * 表记录太少
    * 经常增删改的表 - 提高了查询速度, 同时却会降低更新表的速度
    * 如果某个数据列包含许多重复的内容, 为它建立索引就没有太大的实际效果

* 练习

    ```mysql
    create table staffs(
        id int primary key auto_increment,
        name varchar(24) not null default '',
        age int not null default 0,
        pos varchar(20) not null default '',
        add_time timestamp default current_timestamp
    );
    
    insert into staffs(name, age, pos, add_time)values('z3',22,'manager',now());
    insert into staffs(name, age, pos, add_time)values('july',23,'dev',now());
    insert into staffs(name, age, pos, add_time)values('2000',23,'dev',now());
    alter table staffs add index idx_staffs_nameAgePos(name, age, pos);
    
    1. 全值匹配
        explain select * from staffs where name = 'july';
        explain select * from staffs where name = 'july' and age = 25;
        explain select * from staffs where name = 'july' and age = 25 and pos = 'dev';
        
    2. 最佳左前缀法则: 如果索引了多列, 要遵守最左前缀法则, 指的是查询从索引的最左前缀开始并且不跳过索引中的列.
        where name = 'july' and pos = 'dev';
        
    3. 不在索引列上做任何操作(计算, 函数, 类型转换), 会导致索引失效而转向全表扫描
        explain select * from staffs where left(name,3) = 'july';
    
    4. 存储引擎不能使用索引中范围条件右边的列
        explain select * from staffs where name = 'july' and age > 23 and pos = 'dev';
        
    5. 尽量使用覆盖索引, 减少select *
        explain select * from staffs where name = 'july' and age = 23 and pos = 'dev';		
        
    6. mysql在使用不等于(!=或者<>)的时候无法使用索引会导致全表扫描
    
    7. is null和is not null也无法使用索引
    
    8. like以通配符开头('%abc')mysql索引会失效变成全表扫描
    
        explain select * from staffs where name like '%july%';
        explain select * from staffs where name like '%july';
    explain select * from staffs where name like 'july%';
    
    create table tbl_user(
        id int auto_increment,
        name varchar(20) default null,
        age int default null,
        email varchar(20) default null,
        primary key(id)
    );
    insert into tbl_user(name, age, email) values('1aa1',21,'a@qq.com');
    insert into tbl_user(name, age, email) values('2aa2',221,'b@qq.com');
    insert into tbl_user(name, age, email) values('3aa3',231,'c@qq.com');
    insert into tbl_user(name, age, email) values('4aa4',251,'d@qq.com');
    insert into tbl_user(name, age, email) values('aa',251,'e@qq.com');
    
    create index idx_user_nameAge on tbl_user(name, age);
    
    
    explain select name, age from tbl_user where name like '%aa%';
    
    explain select id from tbl_user where name like '%aa%';
    explain select name from tbl_user where name like '%aa%';
    explain select age from tbl_user where name like '%aa%';
    
    explain select id, name from tbl_user where name like '%aa%';
    explain select id, name, age from tbl_user where name like '%aa%';
    explain select name, age from tbl_user where name like '%aa%';
    
    explain select * from tbl_user where name like '%aa%';
    explain select id, name, age, email from tbl_user where name like '%aa%';
    利用覆盖索引解决like的%问题
    
    9. 字符串不加单引号索引失效
        select * from staffs where name = '2000';
        select * from staffs where name = 2000;
    10. 少用or, 用它来连接时索引会失效
    explain select * from staffs where name = 'july' or name = 'z3';
    
    练习: 假设index(a,b,c)
    where a = 3 使用到a
    where a = 3 and b = 5 使用到a,b
    where a = 3 and b = 5 and c = 4 使用到a,b,c
    where b = 3 或者 b = 3 and c = 4 或者 where c = 4 不能
    where a = 3 and c = 5 用到a
    where a = 3 and b > 4 and c = 5 使用到a,b
    where a = 3 and b like 'kk%' and c = 4 使用到a,b,c
    where a = 3 and b like '%kk' and c = 4 使用到a
    where a = 3 and b like '%kk%' and c = 4 使用到a
    where a = 3 and b like 'k%kk%' and c = 4 使用到a,b,c
    
    create table test03(
        id int primary key auto_increment,
        c1 char(10),
        c2 char(10),
        c3 char(10),
        c4 char(10),
        c5 char(10)
    );
    
    insert into test03(c1,c2,c3,c4,c5) values('a1','a2','a3','a4','a5');
    insert into test03(c1,c2,c3,c4,c5) values('b1','b2','b3','b4','b5');
    insert into test03(c1,c2,c3,c4,c5) values('c1','c2','c3','c4','c5');
    insert into test03(c1,c2,c3,c4,c5) values('d1','d2','d3','d4','d5');
    insert into test03(c1,c2,c3,c4,c5) values('e1','e2','e3','e4','e5');
    
    select * from test03;
    
    create index idx_test03_c1234 on test03(c1,c2,c3,c4);
    
    explain select * from test03 where c1 = 'a1';
    explain select * from test03 where c1 = 'a1' and c2 = 'a2';
    explain select * from test03 where c1 = 'a1' and c2 = 'a2' and c3 = 'a3';
    explain select * from test03 where c1 = 'a1' and c2 = 'a2' and c3 = 'a3' and c4 = 'a4';
    
    explain select * from test03 where c1 = 'a1' and c2 = 'a2' and c4 = 'a4' and c3 = 'a3';查询优化器(都是常量)
    explain select * from test03 where c4 = 'a4' and c3 = 'a3' and c2 = 'a2' and c1 = 'a1';
    explain select * from test03 where c1 = 'a1' and c2 = 'a2' and c3 > 'a3' and c4 = 'a4';用了 c1,c2,c3
    explain select * from test03 where c1 = 'a1' and c2 = 'a2' and c4 > 'a4' and c3 = 'a3';用了 c1,c2,c3,c4(查询优化器)
    explain select * from test03 where c1 = 'a1' and c2 = 'a2' and c4 = 'a4' order by c3; c3作用是排序
    explain select * from test03 where c1 = 'a1' and c2 = 'a2' order by c3;
    explain select * from test03 where c1 = 'a1' and c2 = 'a2' order by c4; 出现了filesort
    explain select * from test03 where c1 = 'a1' and c5 = 'a5' order by c2,c3; 查找用c1, 排序用c2,c3
    explain select * from test03 where c1 = 'a1' and c5 = 'a5' order by c3,c2; 查找用c1, 排序没有用到
    explain select * from test03 where c1 = 'a1' and c2 = 'a2' order by c2,c3; 查找用c1, c2, 排序用c2,c3
    explain select * from test03 where c1 = 'a1' and c2 = 'a2' and c5 = 'a5' order by c2,c3; 查找用c1, c2, 排序用c2,c3
    explain select * from test03 where c1 = 'a1' and c2 = 'a2' and c5 = 'c5' order by c3,c2;
    explain select * from test03 where c1 = 'a1' and c4 = 'a4' group by c2,c3;
    explain select * from test03 where c1 = 'a1' and c4 = 'a4' group by c3,c2;分组之前必排序, 会产生临时表
    
    建议: 对于单键索引, 尽量选择针对当前query过滤性更好的条件在组合索引时, 当前query过滤性最好的字段在索引顺序中越靠左越好在组合索引时,   
        
    尽量选择可以能够包含当前query中where中更多的字段尽可能通过分析统计信息调整sql达到选择合适索引的目的
    ```


* 小表驱动大表

    ```mysql
    select * from A where id in (select id from B)
    等价于:
    for select id from B
    for select * from A where A.id = B.id
    当B表的数据集必须小于A表的数据集时, 用in优于exists
    
    select * from A where exists (select 1 from B where B.id = A.id)
    等价于:
    for select * from A
    for select * from B where B.id = A.id
    当A表的数据集小于B表的数据集时, 用exists优于in
    
    A表与B表的id字段应建立索引
    
    exists:
    select ... from table where exists(subquery)
    理解为: 将主查询的数据, 放到子查询中做条件验证, 根据验证结果(true或false)来决定主查询的数据结果是否得以保留
    
    order by关键字优化:
    create table tblA(
        id int primary key auto_increment,
        age int,
        birth timestamp not null
    );
    
    insert into tblA(age,birth) values(22,now());
    insert into tblA(age,birth) values(23,now());
    insert into tblA(age,birth) values(24,now());
    	
    create index idx_A_ageBirth on tblA(age, birth);
    	
    explain select * from tblA where age > 20 order by age;
    explain select * from tblA where age > 20 order by age,birth;
    explain select * from tblA where age > 20 order by birth;
    explain select * from tblA where age > 20 order by birth,age;
    explain select * from tblA order by birth;
    explain select * from tblA where birth > '2017-01-01 00:00:00' order by birth;
    explain select * from tblA where birth > '2017-01-01 00:00:00' order by age;
    explain select * from tblA order by age asc, birth desc; order by 默认是升序
    
    index效率高, filesort效率低
    
    order by满足两种情况, 会使用index排序:
        1. order by语句使用索引最左前列
        2. 使用where子句与order by子句条件组合满足索引最前列
    ```

* 如果不在索引列上, filesort有两种算法

    * 双路排序: mysql4.1之前是使用双路排序, 字面意思是两次扫描磁盘, 最终得到数据
        读取行指针和order by列, 对他们进行排序, 然后扫描已经排序好的列表, 按照列表中的值重新
        从列表中的值从新从列表中读取对应的数据进行输出

    * 单路排序: 

* 为排序使用索引

    mysql两种排序方式: 文件排序和扫描有序索引排序
    mysql能为排序与查询使用相同索引

    key a_b_c(a,b,c);

    order by a;
    order by a, b;
    order by a, b, c;
    order by a desc, b desc, c desc;

    where a = const order by b, c;
    where a = const and b = const order by c;
    where a = const and b > const order by b, c;

    不能使用:
    order by a asc, b desc, c desc  排序不一致
    where a = const order by c  丢失b索引
    where a = const order by a, d;  d不是索引的一部分
    where a in (...) order by b, c;  对于排序来说, 多个相等条件也是范围查询

* group by

    实质是先排序后进行分组, 遵照索引建的最佳左前缀

    当无法使用索引列, 增大max_length_for_sort_data, sort_buffer_size
    其他均和order by一样

