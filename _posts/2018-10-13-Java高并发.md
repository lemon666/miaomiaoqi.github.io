---
layout: post
title:  "Java高并发程序设计"
date:   2018-10-13 10:58:21
categories: Java
tags: Concurrency
author: miaoqi
---

* content
{:toc}
            
## 为什么需要并行

* 业务需求

* 性能


## 几个重要概念

* 同步(synchronous)和异步(asynchronous)

    同步和异步通常用来形容一次方法调用。

    同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。
    异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。

    ![http://www.miaomiaoqi.cn/images/currency/1.png](http://www.miaomiaoqi.cn/images/currency/1.png)

* 并发(Concurrency)和并行(Parallelism)

    * 并发: 时间段内有很多的线程或进程在执行，但何时间点上都只有一个在执行，多个线程或进程争抢时间片轮流执行。

    * 并行: 时间段和时间点上都有多个线程或进程在执行。
    
    * **单核cpu的话只能是并发，多核cpu才能做到并行执行。**

* 临界区

    临界区用来表示一种公共资源或者说是共享数据, 可以被多个线程使用. 但是每一次, 只能有一个线程使用它, 一旦临界区资源被占用, 其他线程想使用这个资源, 就必须等待

    进程 -> 进入去(申请资源, 资源被占有, 暂时不能访问, 进入阻塞等待队列) -> 临界区 -> 退出去(释放资源)

* 阻塞(Blocking)和非阻塞(Non-Blocking)

    * 阻塞和非阻塞通常用来形容多线程间的相互影响, 比如一个线程占用了临界区资源, 那么其他所有需要这个资源的线程就必须在这个临界区中进行等待, 等待会导致线程挂起, 这种情况就是阻塞. 此时如果占用资源的线程一直不释放资源, 那么其他所有阻塞在这个临界区的线程都不能工作

    * 非阻塞允许多个线程同时进行临界区

* 死锁(DeadLock), 饥饿(Starvation)和活锁(Livelock)

    * 死锁是多个线程互相等待, 谁也无法继续往下执行

    * 饥饿是指某一个或者多个线程因为种种原因无法获得所需要的资源, 导致一直无法执行

* 并行的级别

## 多线程

### 什么是多线程

### 线程的基本操作

### 守护线程

### 线程的优先级

### 基本的线程同步操作
    
    