---
layout: post
title:  "Java高并发程序设计"
date:   2018-10-13 10:58:21
categories: Java
tags: Concurrency
author: miaoqi
---

* content
{:toc}
            
## 为什么需要并行

* 业务需求

* 性能


## 几个重要概念

* 同步(synchronous)和异步(asynchronous)

    同步和异步通常用来形容一次方法调用。

    同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。
    异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。

    ![http://www.miaomiaoqi.cn/images/currency/1.png](http://www.miaomiaoqi.cn/images/currency/1.png)

* 并发(Concurrency)和并行(Parallelism)

    * 并发: 时间段内有很多的线程或进程在执行，但何时间点上都只有一个在执行，多个线程或进程争抢时间片轮流执行。

    * 并行: 时间段和时间点上都有多个线程或进程在执行。
    
    * **单核cpu的话只能是并发，多核cpu才能做到并行执行。**

* 临界区

    临界区用来表示一种公共资源或者说是共享数据, 可以被多个线程使用. 但是每一次, 只能有一个线程使用它, 一旦临界区资源被占用, 其他线程想使用这个资源, 就必须等待

    进程 -> 进入去(申请资源, 资源被占有, 暂时不能访问, 进入阻塞等待队列) -> 临界区 -> 退出去(释放资源)

* 阻塞(Blocking)和非阻塞(Non-Blocking)

    * 阻塞和非阻塞通常用来形容多线程间的相互影响, 比如一个线程占用了临界区资源, 那么其他所有需要这个资源的线程就必须在这个临界区中进行等待, 等待会导致线程挂起, 这种情况就是阻塞. 此时如果占用资源的线程一直不释放资源, 那么其他所有阻塞在这个临界区的线程都不能工作

    * 非阻塞允许多个线程同时进行临界区

* 死锁(DeadLock), 饥饿(Starvation)和活锁(Livelock)

    * 死锁是多个线程互相等待, 谁也无法继续往下执行

    * 饥饿是指某一个或者多个线程因为种种原因无法获得所需要的资源, 导致一直无法执行

* 并行的级别

## 多线程

### 什么是多线程

### 线程的基本操作

### 守护线程

### 线程的优先级

### 基本的线程同步操作

## JDK并发包

* ReentrantLock

    该类是synchronized的增强版

    * 可重入

        单线程可以重复进入，但要重复退出, 可以在一个锁内再次对这个锁进行加锁

            lock.lock();
            lock.lock();
            
            lock.unlock();
            lock.unlock();

    * 可中断

            lockInterruptibly()

    * 可限时

        超时不能获得锁，就返回false，不会永久等待构成死锁

            try {
                // 2秒如果不能获得锁就中断
                lock.tryLock(2, TimeUnit.SECONDS);
            } catch (InterruptedException e1) {
                e1.printStackTrace();
            }

    * 公平锁

        先来先得

            public ReentrantLock(boolean fair)
            public static ReentrantLock fairLock = new ReentrantLock(true);

* Condition

    类似于 Object.wait()和Object.notify() 与ReentrantLock结合使用

    * 主要接口

            void await() throws InterruptedException;
            void awaitUninterruptibly();
            long awaitNanos(long nanosTimeout) throws InterruptedException; boolean await(long time, TimeUnit unit) throws InterruptedException; boolean awaitUntil(Date deadline) throws InterruptedException;
            void signal();
            void signalAll();

        await()方法会使当前线程等待，同时释放当前锁，当其他线程中使用signal()时或者signalAll()方法时，线程会重新获得锁并继续执行。或者当线程被中断时，也能跳出等待。这和Object.wait()方法很相似。

        awaitUninterruptibly()方法与await()方法基本相同，但是它并不会再等待过程中响应中断。

        singal()方法用于唤醒一个在等待中的线程。相对的singalAll()方法会唤醒所有在等待中的线程。这和Object.notify()方法很类似。

* Semaphore

    共享锁, 运行多个线程同时临界区

    * 主要接口

            public void acquire()
            public void acquireUninterruptibly()
            public boolean tryAcquire()
            public boolean tryAcquire(long timeout, TimeUnit unit) public void release()

* ReadWriteLock
    
    ReadWriteLock是JDK5中提供的读写分离锁

    读-读不互斥:读读之间不阻塞。 

    读-写互斥:读阻塞写，写也会阻塞读。 

    写-写互斥:写写阻塞。

    * 主要接口

            private static ReentrantReadWriteLock readWriteLock=new ReentrantReadWriteLock();
            private static Lock readLock = readWriteLock.readLock();
            private static Lock writeLock = readWriteLock.writeLock();

* CountDownLatch

    倒数计时器 一种典型的场景就是火箭发射。在火箭发射前，为了保证万无一失，往往还要进行各项设备、仪器的检查。 只有等所有检查完毕后，引擎才能点火。这种场景就非常适合使用CountDownLatch。它可以使得点火线程 ，等待所有检查线程全部完工后，再执行

        static final CountDownLatch end = new CountDownLatch(10);
        end.countDown(); // 计数器-1
        end.await(); // 计数器为0的时候向下执行

* CyclicBarrier

    循环栅栏 Cyclic意为循环，也就是说这个计数器可以反复使用。比如，假设我们将计数器设置为10。那么凑齐第一批10个线程后，计数器就会归零，然后接着凑齐下一批10个线程

        public CyclicBarrier(int parties, Runnable barrierAction)
        barrierAction就是当计数器一次计数完成后，系统会执行的动作
    
    
## 并发容器及典型源码分析

* HashMap

        public static Map m = Collections.synchronizedMap(newHashMap());

* synchronizedList

* synchronizedSet

* ConcurrentHashMap

    高性能HashMap

* BlockingQueue

    阻塞队列

## 线程池

### JDK为我们提供了哪些支持

![http://www.miaomiaoqi.cn/images/currency/1.png](http://www.miaomiaoqi.cn/images/currency/1.png)

### 线程池的使用

* 线程池的种类

    newFixedThreadPool
    
    newSingleThreadExecutor
    
    newCachedThreadPool
    
    newScheduledThreadPool

    
    
    
    
    
    
    