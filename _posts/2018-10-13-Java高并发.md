---
layout: post
title:  "Java高并发程序设计"
date:   2018-10-13 10:58:21
categories: Java
tags: Concurrency
author: miaoqi
---

* content
{:toc}

## 基本概念

* 并发

    同时拥有两个或者多个线程, 如果程序在单核处理器上运行, 多个线程将交替地换入或者换出内存, 这些线程是同时"存在"的, 每个线程都处于执行过程中的某个状态, 如果运行在多核处理器上, 此时, 程序中的每个线程都将分配到一个处理器核上, 因此可以同时运行

    多个线程操作相同的资源, **保证线程安全**, 合理使用资源

* 高并发

    高并发(High Concurrency)是互联网分布式系统架构设计中必须考虑的因素之一, 它通常是指, 通过设计保证系统能够**同时并行处理**很多请求

    服务能同时处理很多请求, **提高程序性能**

* CPU多级缓存

    CPU的频率太快了, 快到主存跟不上, 这样在处理器时钟周期内, CPU常常需要等待主存, 浪费资源. 所以Cache出现, 是为了缓解CPU和内存之间速度的不匹配问题(结构: cpu -> cache -> memory)

    * CPU Cache有什么意义

        1. 时间局部性: 如果某个数据被访问, 那么在不久的将来它可能再次被访问

        1. 空间局部性: 如果某个数据被访问, 那么与它相邻的数据很快也可能被访问

    * 缓存一致性(MESI)

        用于保证多个CPU Cache之间缓存共享数据的一致

        ![http://www.miaomiaoqi.cn/images/concurrency/1.png](http://www.miaomiaoqi.cn/images/concurrency/1.png)

* CPU乱序执行优化

    处理器为提高运算速度而做出违背代码原有顺序的优化

* Java内存模型(Java Memory Model, JMM)

    规范Java虚拟机与计算机内存是如何协调工作的, 规定了一个线程如何和何时可以看到其他线程修改过的共享变量的值, 以及在必须时如何同步地访问共享变量

    ![http://www.miaomiaoqi.cn/images/concurrency/1.png](http://www.miaomiaoqi.cn/images/concurrency/2.png)

    * 同步八种操作

        1. lock(锁定)

            作用于主内存的变量, 把一个变量标识位一条线程独占的状态

        1. unlock(解锁)

            作用于主内存的变量, 把一个处于锁定状态的变量释放出来, 释放后的变量才可以被其他线程锁定

        1. read(读取)

            作用于主内存的变量, 把一个变量值从主内存传输到线程的工作内存中, 以便随后的load动作使用

        1. load(载入)

            作用于工作内存的变量, 它把read操作从主内存中得到的变量值放入工作内存的变量副本中

        1. use(使用)

            作用于工作内存的变量, 把工作内存中的一个变量值传递给执行引擎

        1. assign(赋值)

            作用于工作内存的变量, 它把一个从执行引擎接收到的值赋值给工作内存的变量

        1. store(存储)

            作用于工作内存的变量, 把工作内存中的一个变量的值传送到主内存中, 以便随后的write的操作

        1. write(写入)

            作用于主内存的变量, 它把store操作从工作内存中一个变量的值传送到主内存的变量中

    * 同步规则

        1. 如果要把一个变量从主内存中复制到工作内存中, 就需要按顺序的执行read和load操作, 如果把变量从工作内存中同步回主内存中, 就要按顺序的执行store和write操作. 但java内存模型只要求上述操作必须按顺序执行, 而没有保证必须是连续执行

        1. 不允许read和load, store和write操作之一单独出现

        1. 不允许一个线程丢弃它的最近assign的操作, 即变量在工作内存中改变了之后必须同步到主内存中

        1. 不允许一个线程无原因地(没有发生过任何assign操作)把数据从工作内存同步回主内存中

        1. 一个新的变量只能在主内存中诞生, 不允许在工作内存中直接使用一个未初始化(load或assign)的变量. 即就是对一个变量实施use和store操作之前, 必须先执行过了assign和load操作

        1. 一个变量在同一时刻只允许一条线程对其进行lock操作, 但lock操作可以被同一条线程重复执行多次, 多次执行lock后, 只有执行相同次数的unlock操作, 变量才会被解锁. lock和unlock必须成对出现

        1. 如果一个变量执行lock操作, 将会清空工作内存中此变量的值, 在执行引擎使用这个变量前需重新执行load或assign操作初始化变量的值

        1. 如果一个变量事先没有被lock操作锁定, 则不允许对它执行unlock操作; 也不允许去unlock一个被其他线程锁定的变量

        1. 对一个变量执行unlock操作之前, 必须先把此变量同步到主内存中(执行store和write操作)

        ![http://www.miaomiaoqi.cn/images/concurrency/1.png](http://www.miaomiaoqi.cn/images/concurrency/3.png)
        
        ![http://www.miaomiaoqi.cn/images/concurrency/1.png](http://www.miaomiaoqi.cn/images/concurrency/4.png)

## 并发模拟

* Postman

    Http请求模拟工具

* Apache Bench(AB)

    Apache附带的工具, 测试网站性能

* JMeter

    Apache组织开发的压力测试工具

        jmeter.sh

* 代码

    Semaphore, CountDownLatch等

## 线程安全性

* 当多个线程访问某个类时, 不管运行时环境采用何种调度方式或者这些进程将如何交替执行, 并且在主调代码中不需要任何额外的同步或协同, 这个类都能表现出正确的行为, 那么就称这个类是线程安全的

    * 原子性

        提供了互斥访问, 同一时刻只能有一个线程来对它进行操作

        * Atomic包
        
            AtomicXXX: CAS, Unsafe.compareAndSwapInt
    
            AtomicLong和LongAdder
    
            AtomicReference, AtomicXxxFieldUpdater
            
            AtomicStampReference 解决CAS的ABA问题
    
            AtomicBoolean

        * 锁

            synchronized 依赖 JVM

            * 修饰代码块

                大括号括起来的对象, 作用于**调用的对象**

            * 修饰方法

                整个方法, 作用于**调用的对象**
                
            * 修饰静态方法

                整个静态方法, 作用于**所有对象**

            * 修饰类

                括号括起来的部分, 作用于**所有对象**
            
            Lock 依赖特殊的CPU指令, 代码实现, ReentrantLock

        * 对比

            * synchronized

                不可中断锁, 适合竞争不激烈, 可读性好

            * Lock

                可中断锁, 多样化同步, 竞争激烈时能维持常态

            * Atomic

                竞争激烈时能维持常态, 比Lock性能好, 但只能同步一个值

    * 可见性

        一个线程对主内存的修改可以及时的被其他线程观察到

        导致共享变量在线程间不可见的原因

        * 线程交叉执行

        * 重排序结合线程交叉执行

        * 共享变量更新后的值没有在工作内存与主内存间及时更新

        JMM关于synchronized的两条规定

        * 线程解锁前, 必须把共享变量的最新值刷新到主内存中

        * 线程加锁前, 将清空工作内存中共享变量的值, 从而使用共享变量时需要从主内存中重新读取最新的值**(加锁与解锁是同一把锁)**

        volatile关键字, 通过加入内存屏障和禁止重排序优化来实现

        * 对volatile变量写操作时, 会在写操作后加入一条store屏障指令, 将本地内存中的共享变量值刷新到主存中

            ![http://miaomiaoqi.cn/images/concurrency/5.png](http://miaomiaoqi.cn/images/concurrency/5.png)

        * 对volatile变量读操作时, 会在读操作前加入一条load屏障指令, 从主内存中读取共享变量

            ![http://miaomiaoqi.cn/images/concurrency/6.png](http://miaomiaoqi.cn/images/concurrency/6.png)

    * 有序性

        一个线程观察其他线程中的指令执行顺序, 由于指令重排序的存在, 该观察结果一般杂乱无序

        在Java内存模型中, 允许编译器和处理器对指令进行重排序, 但是重排序过程不会影响到单线程程序的执行, 却会影响到多线程并发执行的正确性

        * happens-before原则

            * 程序次序规则

                一个线程内, 按照代码顺序, 书写在前面的操作先行发生于书写在后面的操作, 只是保证单线程操作的正确性

            * 锁定规则

                一个unlock操作先行发生于后面对同一个锁的lock操作

            * volatile变量规则

                对一个变量的写操作先行发生于后面对这个变量的读操作

            * 传递规则

                如果操作A先行发生于操作B, 而操作B又先行发生于操作C, 则可以得出操作A先行发生于操作C

            * 线程启动原则

                Thread对象的start()方法先行发生于此线程的每一个动作

            * 线程中断规则

                对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生

            * 线程终结规则

                线程中所有操作都先行发生于线程的终止检测, 我们可以通过Thread.join()方法结束. Thread.isAlive()的返回值手段检测到线程已经终止执行

            * 对象终结规则

                一个对象的初始化完成先行发生于他的finalize()方法的开始


## 安全发布对象
    
* 发布对象

    使一个对象能够被当前范围之外的代码所使用
    
* 对象逸出

    一种错误的发布, 当一个对象还没有构造完成时, 就使它被其他线程所见

### 安全发布对象的四中方法

* 在静态初始化函数中

* 将对象的引用保存到volatile类型域或者AtomicReference对象中

* 将对象的引用保存到某个正确构造对象的final类型域中

* 将对象的引用保存到一个由锁保护的域中
    
    
    